From b10b4be033a5f2226a386fe52bb78df679c31ce0 Mon Sep 17 00:00:00 2001
From: Rameshkumar Sundaram <quic_ramess@quicinc.com>
Date: Wed, 1 Nov 2023 21:42:25 +0530
Subject: [PATCH 1/2] hostapd: add support for FT Over the Air in MLO

Following changes have been added to bring in FT OTA support
for ML Associations,

Add PMKID in Link KDEs of EAPOL message 3/4, these KDE's will
carry RSNE(along with PMKID) and RSNXE per link for FT Initial
association.

Add MLO GTK/IGTK/BIGTK Subelements to FT reassoc response to
carry Group key information of all links to MLD STA during
FT Reassociation.

Use Station(as S0/1 Keyholder) and AP's MLD address
for deriving/storing ft pmk for an ML association.

For MLO, RSNIE/XE of all associated links has to be protected
in FT reassoc response, as well as link address of AP and STA
in increasing order of link id has to be included in MIC
calculation.
Add change to pass associated link addresses and link RSNIE
and RSNXE (in increasing order of link id) and to MIC
calculation APIs.
Use ML address for FT RRB message header if its an
ML association.
Add changes to share ft pmk cache across links of an MLD, use
refcount and deinit the cache only when all links associated
with the cache has deinited it.
Fragment FTIE if its length exceeds 255.

Signed-off-by: Rameshkumar Sundaram <quic_ramess@quicinc.com>
---
 src/ap/wpa_auth.c       | 111 +++++----
 src/ap/wpa_auth_ft.c    | 482 ++++++++++++++++++++++++++++++++++++----
 src/ap/wpa_auth_i.h     |  19 ++
 src/common/wpa_common.c |  57 ++++-
 src/common/wpa_common.h |  21 ++
 src/rsn_supp/wpa_ft.c   |   4 +-
 wlantest/rx_mgmt.c      |   4 +-
 7 files changed, 605 insertions(+), 93 deletions(-)

--- a/src/ap/wpa_auth.c
+++ b/src/ap/wpa_auth.c
@@ -86,25 +86,6 @@ static const int dot11RSNAConfigPMKReaut
 static const int dot11RSNAConfigSATimeout = 60;
 
 
-static const u8 * wpa_auth_get_aa(const struct wpa_state_machine *sm)
-{
-#ifdef CONFIG_IEEE80211BE
-	if (sm->mld_assoc_link_id >= 0)
-		return sm->wpa_auth->mld_addr;
-#endif /* CONFIG_IEEE80211BE */
-	return sm->wpa_auth->addr;
-}
-
-
-static const u8 * wpa_auth_get_spa(const struct wpa_state_machine *sm)
-{
-#ifdef CONFIG_IEEE80211BE
-	if (sm->mld_assoc_link_id >= 0)
-		return sm->peer_mld_addr;
-#endif /* CONFIG_IEEE80211BE */
-	return sm->addr;
-}
-
 
 static void wpa_gkeydone_sta(struct wpa_state_machine *sm)
 {
@@ -775,14 +756,22 @@ struct wpa_authenticator * wpa_init(cons
 	}
 
 #ifdef CONFIG_IEEE80211R_AP
-	wpa_auth->ft_pmk_cache = wpa_ft_pmk_cache_init();
-	if (!wpa_auth->ft_pmk_cache) {
-		wpa_printf(MSG_ERROR, "FT PMK cache initialization failed.");
-		os_free(wpa_auth->group);
-		os_free(wpa_auth->wpa_ie);
-		pmksa_cache_auth_deinit(wpa_auth->pmksa);
-		os_free(wpa_auth);
-		return NULL;
+	/* if MLD share FT PMK cache across link BSS
+	 * refcount is used to check and free the cache during link BSS's deinit.
+	 */
+	if (!conf->first_link_auth) {
+		wpa_auth->ft_pmk_cache = wpa_ft_pmk_cache_init();
+		if (!wpa_auth->ft_pmk_cache) {
+			wpa_printf(MSG_ERROR, "FT PMK cache initialization failed.");
+			os_free(wpa_auth->group);
+			os_free(wpa_auth->wpa_ie);
+			pmksa_cache_auth_deinit(wpa_auth->pmksa);
+			os_free(wpa_auth);
+			return NULL;
+		}
+	} else {
+		wpa_auth->ft_pmk_cache = conf->first_link_auth->ft_pmk_cache;
+		wpa_ft_pmk_cache_inc_refcount(wpa_auth->ft_pmk_cache);
 	}
 #endif /* CONFIG_IEEE80211R_AP */
 
@@ -4490,6 +4479,10 @@ static size_t wpa_auth_ml_kdes_len(struc
 		if (!wpa_auth)
 			continue;
 
+#ifdef CONFIG_IEEE80211R_AP
+		if (wpa_key_mgmt_ft(sm->wpa_key_mgmt))
+			kde_len += 2 + PMKID_LEN; /* PMKR1Name into RSN IE */
+#endif
 		/* MLO Link KDE */
 		kde_len += 2 + RSN_SELECTOR_LEN + 1 + ETH_ALEN;
 
@@ -4536,7 +4529,7 @@ static u8 * wpa_auth_ml_kdes(struct wpa_
 {
 #ifdef CONFIG_IEEE80211BE
 	u8 link_id;
-	u8 *start = pos;
+	u8 *start = pos, *len_pos;
 
 	if (sm->mld_assoc_link_id < 0)
 		return pos;
@@ -4550,6 +4543,7 @@ static u8 * wpa_auth_ml_kdes(struct wpa_
 		const u8 *rsne, *rsnxe, *rsnoe, *rsno2e, *rsnxoe;
 		size_t rsne_len, rsnxe_len, rsnoe_len, rsno2e_len, rsnxoe_len;
 		size_t kde_len;
+		u8 *rsne_start;
 
 		wpa_auth = wpa_get_link_auth(sm->wpa_auth, link_id);
 		if (!wpa_auth)
@@ -4570,6 +4564,7 @@ static u8 * wpa_auth_ml_kdes(struct wpa_
 
 		/* MLO Link KDE */
 		*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+		len_pos = pos;
 		*pos++ = RSN_SELECTOR_LEN + 1 + ETH_ALEN +
 			rsne_len + rsnxe_len;
 
@@ -4587,11 +4582,31 @@ static u8 * wpa_auth_ml_kdes(struct wpa_
 		os_memcpy(pos, wpa_auth->addr, ETH_ALEN);
 		pos += ETH_ALEN;
 
+		rsne_start = pos;
 		if (rsne_len) {
 			os_memcpy(pos, rsne, rsne_len);
 			pos += rsne_len;
 		}
 
+#ifdef CONFIG_IEEE80211R_AP
+		if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
+			int res;
+			size_t e_len = pos - rsne_start;
+
+			res = wpa_insert_pmkid(rsne_start, &e_len, sm->pmk_r1_name, true);
+			if (res < 0) {
+				wpa_printf(MSG_ERROR,
+					   "FT: Failed to insert PMKR1Name into RSN IE in EAPOL-Key data");
+			}
+			/*
+			 * Add the additional length increased in pmkid insertion
+			 * to totol IE len.
+			 */
+			*len_pos = *len_pos + e_len - (pos - rsne_start);
+			pos = rsne_start + e_len;
+		}
+#endif /* CONFIG_IEEE80211R_AP */
+
 		if (rsnxe_len) {
 			os_memcpy(pos, rsnxe, rsnxe_len);
 			pos += rsnxe_len;
@@ -4663,7 +4678,7 @@ static u8 * wpa_auth_ml_kdes(struct wpa_
 SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
 {
 	u8 rsc[WPA_KEY_RSC_LEN], *_rsc, *gtk, *kde = NULL, *pos, stub_gtk[32];
-	size_t gtk_len, kde_len = 0, wpa_ie_len;
+	size_t gtk_len, kde_len = 0, wpa_ie_len = 0;
 	struct wpa_group *gsm = sm->group;
 	u8 *wpa_ie;
 	int secure, gtkidx, encr = 0;
@@ -4696,17 +4711,19 @@ SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
 	os_memset(rsc, 0, WPA_KEY_RSC_LEN);
 	wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, rsc);
 	/* If FT is used, wpa_auth->wpa_ie includes both RSNIE and MDIE */
-	wpa_ie = sm->wpa_auth->wpa_ie;
-	wpa_ie_len = sm->wpa_auth->wpa_ie_len;
-	if (sm->wpa == WPA_VERSION_WPA && (conf->wpa & WPA_PROTO_RSN) &&
-	    wpa_ie_len > wpa_ie[1] + 2U && wpa_ie[0] == WLAN_EID_RSN) {
-		/* WPA-only STA, remove RSN IE and possible MDIE */
-		wpa_ie = wpa_ie + wpa_ie[1] + 2;
-		if (wpa_ie[0] == WLAN_EID_RSNX)
-			wpa_ie = wpa_ie + wpa_ie[1] + 2;
-		if (wpa_ie[0] == WLAN_EID_MOBILITY_DOMAIN)
+	if (!is_mld) {
+		wpa_ie = sm->wpa_auth->wpa_ie;
+		wpa_ie_len = sm->wpa_auth->wpa_ie_len;
+		if (sm->wpa == WPA_VERSION_WPA && (conf->wpa & WPA_PROTO_RSN) &&
+		    wpa_ie_len > wpa_ie[1] + 2U && wpa_ie[0] == WLAN_EID_RSN) {
+			/* WPA-only STA, remove RSN IE and possible MDIE */
 			wpa_ie = wpa_ie + wpa_ie[1] + 2;
-		wpa_ie_len = wpa_ie[1] + 2;
+			if (wpa_ie[0] == WLAN_EID_RSNX)
+				wpa_ie = wpa_ie + wpa_ie[1] + 2;
+			if (wpa_ie[0] == WLAN_EID_MOBILITY_DOMAIN)
+				wpa_ie = wpa_ie + wpa_ie[1] + 2;
+			wpa_ie_len = wpa_ie[1] + 2;
+		}
 	}
 	if ((conf->rsn_override_key_mgmt || conf->rsn_override_key_mgmt_2) &&
 	    !rsn_is_snonce_cookie(sm->SNonce)) {
@@ -4840,7 +4857,8 @@ SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
 		kde_len += 2 + RSN_SELECTOR_LEN + 2 + gtk_len;
 #ifdef CONFIG_IEEE80211R_AP
 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
-		kde_len += 2 + PMKID_LEN; /* PMKR1Name into RSN IE */
+		if (!is_mld)
+			kde_len += 2 + PMKID_LEN; /* PMKR1Name into RSN IE */
 		kde_len += 300; /* FTIE + 2 * TIE */
 	}
 #endif /* CONFIG_IEEE80211R_AP */
@@ -4877,7 +4895,7 @@ SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
 		pos += wpa_ie_len;
 	}
 #ifdef CONFIG_IEEE80211R_AP
-	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
+	if (!is_mld && wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
 		int res;
 		size_t elen;
 
@@ -4911,6 +4929,16 @@ SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
 #ifdef CONFIG_IEEE80211R_AP
 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
 		int res;
+		if (is_mld) {
+			res = wpa_write_mdie(conf,
+					     pos, kde + kde_len - pos);
+			if (res < 0) {
+				wpa_printf(MSG_ERROR,
+					   "Failed to add MDIE into EAPOL-key data");
+				goto done;
+			}
+			pos += res;
+		}
 
 		if (sm->assoc_resp_ftie &&
 		    kde + kde_len - pos >= 2 + sm->assoc_resp_ftie[1]) {
@@ -7430,6 +7458,7 @@ void wpa_auth_set_ml_info(struct wpa_sta
 			continue;
 
 		os_memcpy(sm_link->peer_addr, link->peer_addr, ETH_ALEN);
+		os_memcpy(sm_link->own_addr, link->local_addr, ETH_ALEN);
 
 		wpa_printf(MSG_DEBUG,
 			   "WPA_AUTH: MLD: id=%u, peer=" MACSTR,
@@ -7462,3 +7491,19 @@ void wpa_auth_set_ml_info(struct wpa_sta
 	}
 #endif /* CONFIG_IEEE80211BE */
 }
+
+
+void wpa_auth_reset_ml_link_info(struct wpa_state_machine *sm, u8 mld_assoc_link_id) {
+#ifdef CONFIG_IEEE80211BE
+	struct mld_link *link;
+	u8 link_id;
+
+	for_each_sm_auth(sm, link_id) {
+		link = &sm->mld_links[link_id];
+		if (link_id != mld_assoc_link_id)
+			wpa_group_put(link->wpa_auth, link->wpa_auth->group);
+		link->wpa_auth = NULL;
+		link->valid = false;
+	}
+#endif /* CONFIG_IEEE80211BE */
+}
--- a/src/ap/wpa_auth_ft.c
+++ b/src/ap/wpa_auth_ft.c
@@ -28,6 +28,7 @@
 #include "wpa_auth.h"
 #include "wpa_auth_i.h"
 #include "pmksa_cache_auth.h"
+#include "sta_info.h"
 
 
 #ifdef CONFIG_IEEE80211R_AP
@@ -818,6 +819,7 @@ int wpa_write_ftie(struct wpa_auth_confi
 	u8 *pos = buf, *ielen;
 	size_t hdrlen;
 	u16 mic_control = rsnxe_used ? FTE_MIC_CTRL_RSNXE_USED : 0;
+	size_t curr_len;
 
 	if (key_mgmt == WPA_KEY_MGMT_FT_SAE_EXT_KEY &&
 	    key_len == SHA256_MAC_LEN)
@@ -891,13 +893,44 @@ int wpa_write_ftie(struct wpa_auth_confi
 		pos += r0kh_id_len;
 	}
 
-	if (subelem) {
+	curr_len = pos - buf - 2;
+	if (!subelem) {
+		*ielen = curr_len;
+		return pos - buf;
+	}
+	/* Fragment FTIE if length is exceeding 255. */
+	if ((curr_len + subelem_len) > 255) {
+		size_t frag_len;
+
+		*ielen = 255;
+		os_memcpy(pos, subelem, 255 - curr_len);
+		subelem += (255 - curr_len);
+		subelem_len -= (255 - curr_len);
+		pos += (255 - curr_len);
+		curr_len = pos - buf;
+		do {
+			frag_len = subelem_len > 255 ? 255 : subelem_len;
+			/* Make sure we still have space in input buffer
+			 * for current fragment. (header (2) + content)
+			 */
+			if (curr_len + (frag_len + 2) > len) {
+				wpa_printf(MSG_DEBUG, "FT: No Space left in input buffer for FTIE fragment");
+				return -1;
+			}
+			*pos++ = WLAN_EID_FRAGMENT;
+			*pos++ = frag_len;
+			os_memcpy(pos, subelem, frag_len);
+			pos += frag_len;
+			subelem += frag_len;
+			subelem_len -= frag_len;
+			curr_len = pos - buf;
+		} while (subelem_len);
+	} else {
 		os_memcpy(pos, subelem, subelem_len);
 		pos += subelem_len;
+		*ielen = pos - buf - 2;
 	}
 
-	*ielen = pos - buf - 2;
-
 	return pos - buf;
 }
 
@@ -1237,6 +1270,7 @@ struct wpa_ft_pmk_r1_sa {
 struct wpa_ft_pmk_cache {
 	struct dl_list pmk_r0; /* struct wpa_ft_pmk_r0_sa */
 	struct dl_list pmk_r1; /* struct wpa_ft_pmk_r1_sa */
+	unsigned int ref_count;
 };
 
 
@@ -1321,6 +1355,11 @@ static void wpa_ft_expire_pmk_r1(void *e
 	wpa_ft_free_pmk_r1(r1);
 }
 
+void wpa_ft_pmk_cache_inc_refcount(struct wpa_ft_pmk_cache *cache)
+{
+	if (cache)
+		cache->ref_count++;
+}
 
 struct wpa_ft_pmk_cache * wpa_ft_pmk_cache_init(void)
 {
@@ -1330,6 +1369,7 @@ struct wpa_ft_pmk_cache * wpa_ft_pmk_cac
 	if (cache) {
 		dl_list_init(&cache->pmk_r0);
 		dl_list_init(&cache->pmk_r1);
+		cache->ref_count++;
 	}
 
 	return cache;
@@ -1341,6 +1381,9 @@ void wpa_ft_pmk_cache_deinit(struct wpa_
 	struct wpa_ft_pmk_r0_sa *r0, *r0prev;
 	struct wpa_ft_pmk_r1_sa *r1, *r1prev;
 
+	cache->ref_count--;
+	if (cache->ref_count)
+		return;
 	dl_list_for_each_safe(r0, r0prev, &cache->pmk_r0,
 			      struct wpa_ft_pmk_r0_sa, list)
 		wpa_ft_free_pmk_r0(r0);
@@ -1977,7 +2020,7 @@ static int wpa_ft_pull_pmk_r1(struct wpa
 		{ .type = FT_RRB_PMK_R0_NAME, .len = WPA_PMK_NAME_LEN,
 		  .data = pmk_r0_name },
 		{ .type = FT_RRB_S1KH_ID, .len = ETH_ALEN,
-		  .data = sm->addr },
+		  .data = wpa_auth_get_spa(sm) },
 		{ .type = FT_RRB_LAST_EMPTY, .len = 0, .data = NULL },
 	};
 	struct tlv_list req_auth[] = {
@@ -2151,15 +2194,15 @@ int wpa_auth_derive_ptk_ft(struct wpa_st
 	}
 
 	if (wpa_derive_pmk_r0(mpmk, mpmk_len, ssid, ssid_len, mdid,
-			      r0kh, r0kh_len, sm->addr,
+			      r0kh, r0kh_len, wpa_auth_get_spa(sm),
 			      pmk_r0, pmk_r0_name,
 			      sm->wpa_key_mgmt) < 0 ||
-	    wpa_derive_pmk_r1(pmk_r0, pmk_r0_len, pmk_r0_name, r1kh, sm->addr,
+	    wpa_derive_pmk_r1(pmk_r0, pmk_r0_len, pmk_r0_name, r1kh, wpa_auth_get_spa(sm),
 			      pmk_r1, sm->pmk_r1_name) < 0)
 		return -1;
 
 	return wpa_pmk_r1_to_ptk(pmk_r1, pmk_r1_len, sm->SNonce, sm->ANonce,
-				 sm->addr, sm->wpa_auth->addr, sm->pmk_r1_name,
+				 wpa_auth_get_spa(sm), wpa_auth_get_aa(sm), sm->pmk_r1_name,
 				 ptk, ptk_name, sm->wpa_key_mgmt, sm->pairwise,
 				 kdk_len);
 }
@@ -2191,12 +2234,12 @@ void wpa_auth_ft_store_keys(struct wpa_s
 	session_timeout = wpa_ft_get_session_timeout(sm->wpa_auth, sm->addr);
 
 
-	wpa_ft_store_pmk_r0(sm->wpa_auth, sm->addr, pmk_r0, key_len,
+	wpa_ft_store_pmk_r0(sm->wpa_auth, wpa_auth_get_spa(sm), pmk_r0, key_len,
 			    pmk_r0_name,
 			    sm->pairwise, &vlan, expires_in,
 			    session_timeout, identity, identity_len,
 			    radius_cui, radius_cui_len);
-	wpa_ft_store_pmk_r1(sm->wpa_auth, sm->addr, pmk_r1, key_len,
+	wpa_ft_store_pmk_r1(sm->wpa_auth, wpa_auth_get_spa(sm), pmk_r1, key_len,
 			    sm->pmk_r1_name, sm->pairwise, &vlan,
 			    expires_in, session_timeout, identity,
 			    identity_len, radius_cui, radius_cui_len);
@@ -2211,6 +2254,246 @@ static inline int wpa_auth_get_seqnum(st
 	return wpa_auth->cb->get_seqnum(wpa_auth->cb_ctx, addr, idx, seq);
 }
 
+#ifdef CONFIG_IEEE80211BE
+static int wpa_add_per_link_ft_mlo_gtk_subelem(struct wpa_authenticator *wpa_auth,
+					       u8 **pos, u8 link_id,
+					       struct wpa_state_machine *sm)
+{
+	u8 *subelem = *pos;
+	struct wpa_group *gsm = wpa_auth->group;
+	size_t subelem_len, gtk_len, kek_len;
+	const u8 *gtk, *kek;
+
+	if (!gsm)
+		return -1;
+
+	if (wpa_key_mgmt_fils(sm->wpa_key_mgmt)) {
+		kek = sm->PTK.kek2;
+		kek_len = sm->PTK.kek2_len;
+	} else {
+		kek = sm->PTK.kek;
+		kek_len = sm->PTK.kek_len;
+	}
+
+	gtk_len = gsm->GTK_len;
+
+	gtk = gsm->GTK[gsm->GN - 1];
+
+	/*
+	 * Sub-elem ID[1] | Length[1] | Key Info[2] | LINK INFO[1] | Key Length[1] |
+	 * RSC[8] | Key[5..32].
+	 */
+	subelem_len = 14 + gtk_len + 8;
+	subelem[0] = FTIE_SUBELEM_MLO_GTK;
+	subelem[1] = subelem_len - 2;
+	/* Key ID in B0-B1 of Key Info */
+	WPA_PUT_LE16(&subelem[2], gsm->GN & 0x03);
+	subelem[4] = link_id;
+	subelem[5] = gtk_len;
+	wpa_auth_get_seqnum(wpa_auth, NULL, gsm->GN, subelem + 6);
+	if (aes_wrap(kek, kek_len, gtk_len / 8, gtk, subelem + 14)) {
+		wpa_printf(MSG_DEBUG,
+			   "FT: GTK subelem encryption failed: kek_len=%d",
+			   (int) kek_len);
+		return -1;
+	}
+	*pos += subelem_len;
+	return 0;
+}
+
+static int wpa_add_per_link_ft_mlo_igtk_subelem(struct wpa_authenticator *wpa_auth,
+						u8 **pos, u8 link_id,
+						struct wpa_state_machine *sm)
+{
+	u8 *subelem = *pos;
+	struct wpa_group *gsm = wpa_auth->group;
+	size_t subelem_len, igtk_len, kek_len;
+	const u8 *igtk, *kek;
+
+	if (!gsm)
+		return -1;
+
+	if (wpa_key_mgmt_fils(sm->wpa_key_mgmt)) {
+		kek = sm->PTK.kek2;
+		kek_len = sm->PTK.kek2_len;
+	} else {
+		kek = sm->PTK.kek;
+		kek_len = sm->PTK.kek_len;
+	}
+
+	igtk_len = wpa_cipher_key_len(wpa_auth->conf.group_mgmt_cipher);
+
+	igtk = gsm->IGTK[gsm->GN_igtk - 4];
+
+	/* Sub-elem ID[1] | Length[1] | KeyID[2] | IPN[6] | LINK INFO[1] |
+	 *  Key Length[1] | Key[16+8]
+	 */
+	subelem_len = 12 + igtk_len + 8;
+
+	subelem[0] = FTIE_SUBELEM_MLO_IGTK;
+	subelem[1] = subelem_len - 2;
+	WPA_PUT_LE16(&subelem[2], gsm->GN_igtk);
+	wpa_auth_get_seqnum(wpa_auth, NULL, gsm->GN_igtk, subelem + 4);
+	subelem[10] = link_id;
+	subelem[11] = igtk_len;
+	if (aes_wrap(kek, kek_len, igtk_len / 8, igtk, subelem + 12)) {
+		wpa_printf(MSG_DEBUG,
+			   "FT: IGTK subelem encryption failed: kek_len=%d",
+			   (int) kek_len);
+		return -1;
+	}
+
+	*pos += subelem_len;
+	return 0;
+}
+
+static int wpa_add_per_link_ft_mlo_bigtk_subelem(struct wpa_authenticator *wpa_auth,
+						 u8 **pos, u8 link_id,
+						 struct wpa_state_machine *sm)
+{
+	u8 *subelem = *pos;
+	struct wpa_group *gsm = wpa_auth->group;
+	size_t subelem_len, bigtk_len, kek_len;
+	const u8 *bigtk, *kek;
+
+	if (!gsm)
+		return -1;
+
+	if (wpa_key_mgmt_fils(sm->wpa_key_mgmt)) {
+		kek = sm->PTK.kek2;
+		kek_len = sm->PTK.kek2_len;
+	} else {
+		kek = sm->PTK.kek;
+		kek_len = sm->PTK.kek_len;
+	}
+
+	bigtk_len = wpa_cipher_key_len(wpa_auth->conf.group_mgmt_cipher);
+
+	bigtk = gsm->BIGTK[gsm->GN_bigtk - 6];
+
+	/* Sub-elem ID[1] | Length[1] | KeyID[2] | IPN[6] | LINK INFO[1] |
+	 *  Key Length[1] | Key[16+8]
+	 */
+	subelem_len = 12 + bigtk_len + 8;
+
+	subelem[0] = FTIE_SUBELEM_MLO_BIGTK;
+	subelem[1] = subelem_len - 2;
+	WPA_PUT_LE16(&subelem[2], gsm->GN_bigtk);
+	wpa_auth_get_seqnum(wpa_auth, NULL, gsm->GN_bigtk, subelem + 4);
+	subelem[10] = link_id;
+	subelem[11] = bigtk_len;
+	if (aes_wrap(kek, kek_len, bigtk_len / 8, bigtk, subelem + 12)) {
+		wpa_printf(MSG_DEBUG,
+			   "FT: BIGTK subelem encryption failed: kek_len=%d",
+			   (int) kek_len);
+		return -1;
+	}
+
+	*pos += subelem_len;
+	return 0;
+}
+
+int wpa_add_ft_mlo_subelems(struct wpa_state_machine *sm, u8 *pos)
+{
+	int link_id, ret = 0;
+	u8 *start = pos;
+
+	if (sm->mld_assoc_link_id < 0)
+		return ret;
+
+	for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
+		if (sm->mld_links[link_id].valid &&
+		    sm->mld_links[link_id].wpa_auth) {
+			struct wpa_authenticator *wpa_auth = sm->mld_links[link_id].wpa_auth;
+
+			ret = wpa_add_per_link_ft_mlo_gtk_subelem(wpa_auth, &pos, link_id, sm);
+			if (!ret && sm->mgmt_frame_prot)
+				ret = wpa_add_per_link_ft_mlo_igtk_subelem(wpa_auth, &pos, link_id, sm);
+			if (!ret && sm->mgmt_frame_prot && wpa_auth->conf.beacon_prot)
+				ret = wpa_add_per_link_ft_mlo_bigtk_subelem(wpa_auth, &pos, link_id, sm);
+		}
+		if (ret)
+			return ret;
+	}
+
+	wpa_hexdump(MSG_DEBUG, "MLO-FT-Group-subelems:", start, (pos - start));
+	return ret;
+}
+
+static size_t wpa_add_to_mlo_ft_gtk_subelem_length(struct wpa_authenticator *wpa_auth)
+{
+	size_t len = 0;
+	size_t gtk_len;
+	struct wpa_group *gsm = wpa_auth->group;
+
+	if (!gsm)
+		return len;
+	len = 2; /* Sub element id and length */
+	len += 2; /* Key-idx */
+	len++; /* Link info */
+	len++; /* GTK key length */
+	len += 8; /* PN */
+
+	/*
+	 * GTK
+	 */
+	gtk_len = gsm->GTK_len;
+	len += gtk_len + 8; /* 16 bytes GTK key length and 8 bytes wrap around */
+	return len;
+}
+
+static size_t wpa_add_to_mlo_ft_igtk_subelem_length(struct wpa_state_machine *sm,
+						    struct wpa_authenticator *wpa_auth)
+{
+	size_t len = 0;
+
+	if (sm->mgmt_frame_prot) {
+		len = 2; /* Sub element id and length */
+		len += 2; /* Key-idx */
+		len += 6; /* IPN */
+		len++; /* Link info */
+		len++; /* IGTK key length */
+		len += wpa_cipher_key_len(wpa_auth->conf.group_mgmt_cipher) + 8;
+	}
+	return len;
+}
+
+static size_t wpa_add_to_mlo_ft_bigtk_subelem_length(struct wpa_state_machine *sm,
+						     struct wpa_authenticator *wpa_auth)
+{
+	size_t len = 0;
+
+	if (sm->mgmt_frame_prot && wpa_auth->conf.beacon_prot) {
+		len = 2; /* Sub element id and length */
+		len += 2; /* Key-idx */
+		len += 6; /* BIPN */
+		len++; /* Link info */
+		len++; /* BIGTK key length */
+		len += wpa_cipher_key_len(wpa_auth->conf.group_mgmt_cipher) + 8;
+	}
+	return len;
+}
+
+size_t wpa_ft_mlo_subelems_len(struct wpa_state_machine *sm)
+{
+	int link_id;
+	size_t len = 0;
+
+	for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
+		if (sm->mld_links[link_id].valid &&
+		    sm->mld_links[link_id].wpa_auth) {
+			struct wpa_authenticator *wpa_auth = sm->mld_links[link_id].wpa_auth;
+
+			len += wpa_add_to_mlo_ft_gtk_subelem_length(wpa_auth);
+			len += wpa_add_to_mlo_ft_igtk_subelem_length(sm, wpa_auth);
+			len += wpa_add_to_mlo_ft_bigtk_subelem_length(sm, wpa_auth);
+		}
+	}
+	wpa_printf(MSG_DEBUG, "MLO-FT-Group-subelems length %zu", len);
+	return len;
+}
+
+#endif /* CONFIG_IEEE80211BE */
 
 static u8 * wpa_ft_gtk_subelem(struct wpa_state_machine *sm, size_t *len)
 {
@@ -2574,6 +2857,8 @@ u8 * wpa_sm_write_assoc_resp_ies(struct
 	const u8 *kck;
 	size_t kck_len;
 	size_t key_len;
+	bool is_mld = false;
+	struct ft_mld_links_data ml_links_data = {0};
 
 	if (sm == NULL)
 		return pos;
@@ -2646,19 +2931,25 @@ u8 * wpa_sm_write_assoc_resp_ies(struct
 	mdie_len = res;
 	pos += res;
 
+#ifdef CONFIG_IEEE80211BE
+	is_mld = sm->mld_assoc_link_id >= 0 ? true : false;
+#endif /* CONFIG_IEEE80211BE */
 	/* Fast BSS Transition Information */
 	if (auth_alg == WLAN_AUTH_FT) {
-		subelem = wpa_ft_gtk_subelem(sm, &subelem_len);
-		if (!subelem) {
-			wpa_printf(MSG_DEBUG,
-				   "FT: Failed to add GTK subelement");
-			return NULL;
+		if (!is_mld) {
+			subelem = wpa_ft_gtk_subelem(sm, &subelem_len);
+			if (!subelem) {
+				wpa_printf(MSG_DEBUG,
+					   "FT: Failed to add GTK subelement");
+				return NULL;
+			}
 		}
 		r0kh_id = sm->r0kh_id;
 		r0kh_id_len = sm->r0kh_id_len;
 		anonce = sm->ANonce;
 		snonce = sm->SNonce;
-		if (sm->mgmt_frame_prot) {
+
+		if (sm->mgmt_frame_prot && !is_mld) {
 			u8 *igtk;
 			size_t igtk_len;
 			u8 *nbuf;
@@ -2680,7 +2971,7 @@ u8 * wpa_sm_write_assoc_resp_ies(struct
 			subelem_len += igtk_len;
 			os_free(igtk);
 		}
-		if (sm->mgmt_frame_prot && conf->beacon_prot) {
+		if (sm->mgmt_frame_prot && conf->beacon_prot && !is_mld) {
 			u8 *bigtk;
 			size_t bigtk_len;
 			u8 *nbuf;
@@ -2740,6 +3031,30 @@ u8 * wpa_sm_write_assoc_resp_ies(struct
 				return NULL;
 			}
 		}
+#ifdef CONFIG_IEEE80211BE
+		if (is_mld) {
+			/* Add Group key subelems for all links */
+			size_t ft_mlo_subelems_len;
+
+			ft_mlo_subelems_len = wpa_ft_mlo_subelems_len(sm);
+			if (!ft_mlo_subelems_len)
+				return NULL;
+
+			subelem = os_zalloc(ft_mlo_subelems_len);
+			if (!subelem) {
+				wpa_printf(MSG_DEBUG, "FT: Failed to allocate buffer of size %zu"
+					   "for ML Group sub elements", ft_mlo_subelems_len);
+				return NULL;
+			}
+			if (wpa_add_ft_mlo_subelems(sm, subelem) < 0) {
+				os_free(subelem);
+				wpa_printf(MSG_DEBUG, "FT: Failed to build ML Group subelems for STA "MACSTR,
+					   MAC2STR(wpa_auth_get_spa(sm)));
+				return NULL;
+			}
+			subelem_len += ft_mlo_subelems_len;
+		}
+#endif /* CONFIG_IEEE80211BE */
 #endif /* CONFIG_OCV */
 	} else {
 		r0kh_id = conf->r0_key_holder;
@@ -2801,8 +3116,11 @@ u8 * wpa_sm_write_assoc_resp_ies(struct
 		fte_mic = _ftie->mic;
 		elem_count = &_ftie->mic_control[1];
 	}
+	/* For RSNIE/XE elem_count will be incremented in wpa_ft_mic()
+	 * based on number of elements considered for protection.
+	 */
 	if (auth_alg == WLAN_AUTH_FT)
-		*elem_count = 3; /* Information element count */
+		*elem_count = 2; /* Information element count */
 
 	ric_start = pos;
 	if (wpa_ft_parse_ies(req_ies, req_ies_len, &parse,
@@ -2837,8 +3155,6 @@ u8 * wpa_sm_write_assoc_resp_ies(struct
 		rsnxe_len = sm->wpa_auth->conf.rsnxe_override_ft_len;
 	}
 #endif /* CONFIG_TESTING_OPTIONS */
-	if (auth_alg == WLAN_AUTH_FT && rsnxe_len)
-		*elem_count += 1;
 
 	if (wpa_key_mgmt_fils(sm->wpa_key_mgmt)) {
 		kck = sm->PTK.kck2;
@@ -2847,21 +3163,70 @@ u8 * wpa_sm_write_assoc_resp_ies(struct
 		kck = sm->PTK.kck;
 		kck_len = sm->PTK.kck_len;
 	}
+#ifdef CONFIG_IEEE80211BE
+	struct link_data *assoc_link_data = NULL;
+
+	if (is_mld && auth_alg == WLAN_AUTH_FT) {
+		int pos, link_id, rsnie_pos;
+
+		assoc_link_data = os_zalloc((sm->n_mld_affiliated_links + 1) * sizeof(struct link_data));
+		if (!assoc_link_data) {
+			wpa_printf(MSG_DEBUG, "MLO FT: " MACSTR " failed"
+				   "to allocate memory for MIC elements",
+				   MAC2STR(wpa_auth_get_spa(sm)));
+			return NULL;
+		}
+		for (pos = 0, link_id = 0; link_id < MAX_NUM_MLD_LINKS &&
+		     pos < (sm->n_mld_affiliated_links + 1); link_id++) {
+			struct mld_link *sm_link = &sm->mld_links[link_id];
+
+			if (!sm_link->valid)
+				continue;
+
+			assoc_link_data[pos].link_id = link_id;
+			os_memcpy(assoc_link_data[pos].link_addr, sm_link->own_addr, ETH_ALEN);
+			rsnie_pos = wpa_write_rsn_ie(&sm_link->wpa_auth->conf, assoc_link_data[pos].link_rsnie,
+						     sizeof(assoc_link_data[pos].link_rsnie), sm->pmk_r1_name);
+			if (rsnie_pos < 0) {
+				wpa_printf(MSG_DEBUG, "FT: Failed to write link RSN IE for link %d", link_id);
+				os_free(assoc_link_data);
+				return NULL;
+			}
+			assoc_link_data[pos].link_rsnie_len = rsnie_pos;
+			assoc_link_data[pos].link_rsnxe = sm_link->rsnxe;
+			assoc_link_data[pos].link_rsnxe_len = sm_link->rsnxe_len;
+			pos++;
+
+		}
+		ml_links_data.num_links = sm->n_mld_affiliated_links + 1;
+		ml_links_data.link_data = assoc_link_data;
+		ml_links_data.has_rsn = true;
+		ml_links_data.has_rsnx = true;
+	}
+#endif
 	if (auth_alg == WLAN_AUTH_FT &&
 	    wpa_ft_mic(sm->wpa_key_mgmt, kck, kck_len,
-		       sm->addr, sm->wpa_auth->addr, 6,
+		       wpa_auth_get_spa(sm), wpa_auth_get_aa(sm), 6,
 		       mdie, mdie_len, ftie, ftie_len,
 		       rsnie, rsnie_len,
 		       ric_start, ric_start ? pos - ric_start : 0,
-		       rsnxe_len ? rsnxe : NULL, rsnxe_len,
-		       NULL,
-		       fte_mic) < 0) {
+		       rsnxe_len ? rsnxe : NULL, rsnxe_len, NULL,
+		       elem_count,
+		       is_mld ? &ml_links_data : NULL, fte_mic) < 0) {
 		wpa_printf(MSG_DEBUG, "FT: Failed to calculate MIC");
+#ifdef CONFIG_IEEE80211BE
+		if (assoc_link_data)
+			os_free(assoc_link_data);
+#endif
 		pos = NULL;
 		goto fail;
 	}
 
 	os_free(sm->assoc_resp_ftie);
+#ifdef CONFIG_IEEE80211BE
+	if (assoc_link_data)
+		os_free(assoc_link_data);
+#endif
 	sm->assoc_resp_ftie = os_malloc(ftie_len);
 	if (!sm->assoc_resp_ftie) {
 		pos = NULL;
@@ -2992,17 +3357,17 @@ static int wpa_ft_psk_pmk_r1(struct wpa_
 	pairwise = sm->pairwise;
 
 	for (;;) {
-		pmk = wpa_ft_get_psk(wpa_auth, sm->addr, sm->p2p_dev_addr,
+		pmk = wpa_ft_get_psk(wpa_auth, wpa_auth_get_spa(sm), sm->p2p_dev_addr,
 				     pmk);
 		if (pmk == NULL)
 			break;
 
 		if (wpa_derive_pmk_r0(pmk, PMK_LEN, ssid, ssid_len, mdid, r0kh,
-				      r0kh_len, sm->addr,
+				      r0kh_len, wpa_auth_get_spa(sm),
 				      pmk_r0, pmk_r0_name,
 				      WPA_KEY_MGMT_FT_PSK) < 0 ||
 		    wpa_derive_pmk_r1(pmk_r0, PMK_LEN, pmk_r0_name, r1kh,
-				      sm->addr, pmk_r1, pmk_r1_name) < 0 ||
+				      wpa_auth_get_spa(sm), pmk_r1, pmk_r1_name) < 0 ||
 		    os_memcmp_const(pmk_r1_name, req_pmk_r1_name,
 				    WPA_PMK_NAME_LEN) != 0)
 			continue;
@@ -3016,7 +3381,7 @@ static int wpa_ft_psk_pmk_r1(struct wpa_
 		os_memcpy(sm->PMK, pmk, PMK_LEN);
 		sm->pmk_len = PMK_LEN;
 		if (out_vlan &&
-		    wpa_ft_get_vlan(sm->wpa_auth, sm->addr, out_vlan) < 0) {
+		    wpa_ft_get_vlan(sm->wpa_auth, wpa_auth_get_spa(sm), out_vlan) < 0) {
 			wpa_printf(MSG_DEBUG, "FT: vlan not available for STA "
 				   MACSTR, MAC2STR(sm->addr));
 			return -1;
@@ -3024,17 +3389,17 @@ static int wpa_ft_psk_pmk_r1(struct wpa_
 
 		if (out_identity && out_identity_len) {
 			*out_identity_len = wpa_ft_get_identity(
-				sm->wpa_auth, sm->addr, out_identity);
+				sm->wpa_auth, wpa_auth_get_spa(sm), out_identity);
 		}
 
 		if (out_radius_cui && out_radius_cui_len) {
 			*out_radius_cui_len = wpa_ft_get_radius_cui(
-				sm->wpa_auth, sm->addr, out_radius_cui);
+				sm->wpa_auth, wpa_auth_get_spa(sm), out_radius_cui);
 		}
 
 		if (out_session_timeout) {
 			*out_session_timeout = wpa_ft_get_session_timeout(
-				sm->wpa_auth, sm->addr);
+				sm->wpa_auth, wpa_auth_get_spa(sm));
 		}
 
 		return 0;
@@ -3115,7 +3480,7 @@ static int wpa_ft_local_derive_pmk_r1(st
 		return -1; /* not our R0KH-ID */
 
 	wpa_printf(MSG_DEBUG, "FT: STA R0KH-ID matching local configuration");
-	if (wpa_ft_fetch_pmk_r0(sm->wpa_auth, sm->addr, req_pmk_r0_name, &r0) <
+	if (wpa_ft_fetch_pmk_r0(sm->wpa_auth, wpa_auth_get_spa(sm), req_pmk_r0_name, &r0) <
 	    0)
 		return -1; /* no matching PMKR0Name in local cache */
 
@@ -3123,7 +3488,7 @@ static int wpa_ft_local_derive_pmk_r1(st
 
 	if (wpa_derive_pmk_r1(r0->pmk_r0, r0->pmk_r0_len, r0->pmk_r0_name,
 			      conf->r1_key_holder,
-			      sm->addr, out_pmk_r1, out_pmk_r1_name) < 0)
+			      wpa_auth_get_spa(sm), out_pmk_r1, out_pmk_r1_name) < 0)
 		return -1;
 
 	os_get_reltime(&now);
@@ -3133,7 +3498,7 @@ static int wpa_ft_local_derive_pmk_r1(st
 	if (r0->session_timeout)
 		session_timeout = r0->session_timeout - now.sec;
 
-	wpa_ft_store_pmk_r1(wpa_auth, sm->addr, out_pmk_r1, r0->pmk_r0_len,
+	wpa_ft_store_pmk_r1(wpa_auth, wpa_auth_get_spa(sm), out_pmk_r1, r0->pmk_r0_len,
 			    out_pmk_r1_name,
 			    sm->pairwise, r0->vlan, expires_in, session_timeout,
 			    r0->identity, r0->identity_len,
@@ -3234,6 +3599,20 @@ static int wpa_ft_process_auth_req(struc
 	if (wpa_ft_set_key_mgmt(sm, &parse) < 0)
 		goto out;
 
+	if (parse.rsnxe && parse.rsnxe_len) {
+		if (!sm->rsnxe || sm->rsnxe_len < (parse.rsnxe_len + 2)) {
+			if (sm->rsnxe)
+				os_free(sm->rsnxe);
+			sm->rsnxe = os_malloc(parse.rsnxe_len + 2);
+			if (!sm->rsnxe)
+				return WLAN_STATUS_UNSPECIFIED_FAILURE;
+		}
+		sm->rsnxe[0] = WLAN_EID_RSNX;
+		sm->rsnxe[1] = parse.rsnxe_len;
+		os_memcpy(sm->rsnxe + 2, parse.rsnxe, parse.rsnxe_len);
+		sm->rsnxe_len = parse.rsnxe_len + 2;
+	}
+
 	wpa_hexdump(MSG_DEBUG, "FT: Requested PMKR0Name",
 		    parse.rsn_pmkid, WPA_PMK_NAME_LEN);
 
@@ -3241,7 +3620,7 @@ static int wpa_ft_process_auth_req(struc
 	    wpa_key_mgmt_ft_psk(sm->wpa_key_mgmt)) {
 		if (wpa_derive_pmk_r1_name(parse.rsn_pmkid,
 					   sm->wpa_auth->conf.r1_key_holder,
-					   sm->addr, pmk_r1_name, PMK_LEN) < 0)
+					   wpa_auth_get_spa(sm), pmk_r1_name, PMK_LEN) < 0)
 			goto out;
 		if (wpa_ft_psk_pmk_r1(sm, pmk_r1_name, pmk_r1, &pairwise,
 				      &vlan, &identity, &identity_len,
@@ -3268,10 +3647,10 @@ static int wpa_ft_process_auth_req(struc
 			continue;
 		if (wpa_derive_pmk_r1_name(parse.rsn_pmkid,
 					   sm->wpa_auth->conf.r1_key_holder,
-					   sm->addr, pmk_r1_name, len) < 0)
+					   wpa_auth_get_spa(sm), pmk_r1_name, len) < 0)
 			continue;
 
-		if (wpa_ft_fetch_pmk_r1(sm->wpa_auth, sm->addr, pmk_r1_name,
+		if (wpa_ft_fetch_pmk_r1(sm->wpa_auth, wpa_auth_get_spa(sm), pmk_r1_name,
 					pmk_r1, &pmk_r1_len, &pairwise, &vlan,
 					&identity, &identity_len, &radius_cui,
 					&radius_cui_len,
@@ -3370,7 +3749,7 @@ pmk_r1_derived:
 		kdk_len = 0;
 
 	if (wpa_pmk_r1_to_ptk(pmk_r1, pmk_r1_len, sm->SNonce, sm->ANonce,
-			      sm->addr, sm->wpa_auth->addr, pmk_r1_name,
+			      wpa_auth_get_spa(sm), wpa_auth_get_aa(sm), pmk_r1_name,
 			      &sm->PTK, ptk_name, parse.key_mgmt,
 			      pairwise, kdk_len) < 0)
 		goto out;
@@ -3389,18 +3768,18 @@ pmk_r1_derived:
 	sm->tk_already_set = false;
 	wpa_ft_install_ptk(sm, 0);
 
-	if (wpa_ft_set_vlan(sm->wpa_auth, sm->addr, &vlan) < 0) {
+	if (wpa_ft_set_vlan(sm->wpa_auth, wpa_auth_get_spa(sm), &vlan) < 0) {
 		wpa_printf(MSG_DEBUG, "FT: Failed to configure VLAN");
 		goto out;
 	}
-	if (wpa_ft_set_identity(sm->wpa_auth, sm->addr,
+	if (wpa_ft_set_identity(sm->wpa_auth, wpa_auth_get_spa(sm),
 				identity, identity_len) < 0 ||
-	    wpa_ft_set_radius_cui(sm->wpa_auth, sm->addr,
+	    wpa_ft_set_radius_cui(sm->wpa_auth, wpa_auth_get_spa(sm),
 				  radius_cui, radius_cui_len) < 0) {
 		wpa_printf(MSG_DEBUG, "FT: Failed to configure identity/CUI");
 		goto out;
 	}
-	wpa_ft_set_session_timeout(sm->wpa_auth, sm->addr, session_timeout);
+	wpa_ft_set_session_timeout(sm->wpa_auth, wpa_auth_get_spa(sm), session_timeout);
 
 	buflen = 2 + sizeof(struct rsn_mdie) + 2 + sizeof(struct rsn_ftie) +
 		2 + FT_R1KH_ID_LEN + 200;
@@ -3416,6 +3795,11 @@ pmk_r1_derived:
 		goto fail;
 	pos += ret;
 
+	ret = wpa_write_rsnxe(conf, pos, end - pos);
+	if (ret < 0)
+		goto fail;
+	pos += ret;
+
 	ret = wpa_write_mdie(conf, pos, end - pos);
 	if (ret < 0)
 		goto fail;
@@ -3487,7 +3871,7 @@ void wpa_ft_process_auth(struct wpa_stat
 
 
 int wpa_ft_validate_reassoc(struct wpa_state_machine *sm, const u8 *ies,
-			    size_t ies_len)
+			    size_t ies_len, struct mld_info *mld_info)
 {
 	struct wpa_ft_ies parse;
 	struct rsn_mdie *mdie;
@@ -3497,6 +3881,8 @@ int wpa_ft_validate_reassoc(struct wpa_s
 	const u8 *kck;
 	size_t kck_len;
 	struct wpa_auth_config *conf;
+	bool is_mld = false;
+	struct ft_mld_links_data ml_links_data = {0};
 	int retval = WLAN_STATUS_UNSPECIFIED_FAILURE;
 
 	if (sm == NULL)
@@ -3644,8 +4030,46 @@ int wpa_ft_validate_reassoc(struct wpa_s
 		kck = sm->PTK.kck;
 		kck_len = sm->PTK.kck_len;
 	}
+#ifdef CONFIG_IEEE80211BE
+	struct link_data *assoc_link_data = NULL;
+	is_mld = sm->mld_assoc_link_id >= 0 ? true : false;
+
+	if (is_mld && mld_info) {
+		int pos, link_id, num_links = 0;
+
+		for (pos = 0, link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
+			struct mld_link_info *link_info = &mld_info->links[link_id];
+
+			if (!link_info->valid)
+				continue;
+			num_links++;
+		}
+
+		assoc_link_data = os_zalloc(num_links * sizeof(struct link_data));
+		if (!assoc_link_data) {
+			wpa_printf(MSG_DEBUG, "MLO FT: " MACSTR " failed"
+				   "to allocate memory for MIC elements",
+				   MAC2STR(wpa_auth_get_spa(sm)));
+			retval = WLAN_STATUS_UNSPECIFIED_FAILURE;
+			goto out;
+		}
+		for (pos = 0, link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
+			struct mld_link_info *link_info = &mld_info->links[link_id];
+
+			if (!link_info->valid)
+				continue;
+
+			assoc_link_data[pos].link_id = link_id;
+			os_memcpy(assoc_link_data[pos].link_addr, link_info->peer_addr, ETH_ALEN);
+			pos++;
+		}
+		ml_links_data.num_links = pos;
+		ml_links_data.link_data = assoc_link_data;
+	}
+#endif /* CONFIG_IEEE80211BE */
+
 	if (wpa_ft_mic(sm->wpa_key_mgmt, kck, kck_len,
-		       sm->addr, sm->wpa_auth->addr, 5,
+		       wpa_auth_get_spa(sm), wpa_auth_get_aa(sm), 5,
 		       parse.mdie - 2, parse.mdie_len + 2,
 		       parse.ftie - 2, parse.ftie_len + 2,
 		       parse.rsn - 2, parse.rsn_len + 2,
@@ -3653,15 +4077,23 @@ int wpa_ft_validate_reassoc(struct wpa_s
 		       parse.rsnxe ? parse.rsnxe - 2 : NULL,
 		       parse.rsnxe ? parse.rsnxe_len + 2 : 0,
 		       NULL,
-		       mic) < 0) {
+		       NULL, is_mld ? &ml_links_data : NULL, mic) < 0) {
 		wpa_printf(MSG_DEBUG, "FT: Failed to calculate MIC");
+#ifdef CONFIG_IEEE80211BE
+		if (assoc_link_data)
+			os_free(assoc_link_data);
+#endif /* CONFIG_IEEE80211BE */
 		goto out;
 	}
 
+#ifdef CONFIG_IEEE80211BE
+	if (assoc_link_data)
+		os_free(assoc_link_data);
+#endif /* CONFIG_IEEE80211BE */
 	if (os_memcmp_const(mic, parse.fte_mic, mic_len) != 0) {
 		wpa_printf(MSG_DEBUG, "FT: Invalid MIC in FTIE");
 		wpa_printf(MSG_DEBUG, "FT: addr=" MACSTR " auth_addr=" MACSTR,
-			   MAC2STR(sm->addr), MAC2STR(sm->wpa_auth->addr));
+			   MAC2STR(wpa_auth_get_spa(sm)), MAC2STR(wpa_auth_get_aa(sm)));
 		wpa_hexdump(MSG_MSGDUMP, "FT: Received MIC",
 			    parse.fte_mic, mic_len);
 		wpa_hexdump(MSG_MSGDUMP, "FT: Calculated MIC", mic, mic_len);
--- a/src/ap/wpa_auth_i.h
+++ b/src/ap/wpa_auth_i.h
@@ -184,7 +184,10 @@ struct wpa_state_machine {
 	struct mld_link {
 		bool valid;
 		u8 peer_addr[ETH_ALEN];
+		u8 own_addr[ETH_ALEN];
 
+		const u8 *rsnxe;
+		size_t rsnxe_len;
 		struct wpa_authenticator *wpa_auth;
 	} mld_links[MAX_NUM_MLD_LINKS];
 #endif /* CONFIG_IEEE80211BE */
@@ -344,9 +347,28 @@ void wpa_auth_ft_store_keys(struct wpa_s
 			    size_t key_len);
 struct wpa_ft_pmk_cache * wpa_ft_pmk_cache_init(void);
 void wpa_ft_pmk_cache_deinit(struct wpa_ft_pmk_cache *cache);
+void wpa_ft_pmk_cache_inc_refcount(struct wpa_ft_pmk_cache *cache);
 void wpa_ft_install_ptk(struct wpa_state_machine *sm, int retry);
 int wpa_ft_store_pmk_fils(struct wpa_state_machine *sm, const u8 *pmk_r0,
 			  const u8 *pmk_r0_name);
 #endif /* CONFIG_IEEE80211R_AP */
 
+static const u8 *wpa_auth_get_aa(const struct wpa_state_machine *sm)
+{
+#ifdef CONFIG_IEEE80211BE
+	if (sm->mld_assoc_link_id >= 0)
+		return sm->wpa_auth->mld_addr;
+#endif /* CONFIG_IEEE80211BE */
+	return sm->wpa_auth->addr;
+}
+
+static const u8 *wpa_auth_get_spa(const struct wpa_state_machine *sm)
+{
+#ifdef CONFIG_IEEE80211BE
+	if (sm->mld_assoc_link_id >= 0)
+		return sm->peer_mld_addr;
+#endif /* CONFIG_IEEE80211BE */
+	return sm->addr;
+}
+
 #endif /* WPA_AUTH_I_H */
--- a/src/common/wpa_common.c
+++ b/src/common/wpa_common.c
@@ -899,10 +899,12 @@ int wpa_ft_mic(int key_mgmt, const u8 *k
 	       const u8 *ric, size_t ric_len,
 	       const u8 *rsnxe, size_t rsnxe_len,
 	       const struct wpabuf *extra,
+	       u8 *elem_count,
+	       struct ft_mld_links_data *assoc_links_data,
 	       u8 *mic)
 {
-	const u8 *addr[11];
-	size_t len[11];
+	const u8 *addr[20];
+	size_t len[20];
 	size_t i, num_elem = 0;
 	u8 zero_mic[32];
 	size_t mic_len, fte_fixed_len;
@@ -938,10 +940,29 @@ int wpa_ft_mic(int key_mgmt, const u8 *k
 	len[num_elem] = 1;
 	num_elem++;
 
+#ifdef CONFIG_IEEE80211BE
+	/* Add Link RSN IEs if this is an ML association
+	 */
+	if (assoc_links_data && assoc_links_data->has_rsn) {
+		for (i = 0; i < assoc_links_data->num_links; i++) {
+			if (assoc_links_data->link_data[i].link_rsnie_len) {
+				wpa_printf(MSG_WARNING, "FT MIC link %zu rsn ie len %d curr index %zu",
+					   i, assoc_links_data->link_data[i].link_rsnie_len, num_elem);
+				addr[num_elem] = assoc_links_data->link_data[i].link_rsnie;
+				len[num_elem] = assoc_links_data->link_data[i].link_rsnie_len;
+				num_elem++;
+				if (elem_count)
+					*elem_count += 1;
+			}
+		}
+	} else
+#endif /*CONFIG_IEEE80211BE */
 	if (rsnie) {
 		addr[num_elem] = rsnie;
 		len[num_elem] = rsnie_len;
 		num_elem++;
+		if (elem_count)
+			*elem_count += 1;
 	}
 	if (mdie) {
 		addr[num_elem] = mdie;
@@ -974,10 +995,30 @@ int wpa_ft_mic(int key_mgmt, const u8 *k
 		num_elem++;
 	}
 
+#ifdef CONFIG_IEEE80211BE
+	/* Add Link RSNXEs if this is an ML association.
+	 */
+	if (assoc_links_data && assoc_links_data->has_rsnx) {
+		for (i = 0; i < assoc_links_data->num_links; i++) {
+			if (assoc_links_data->link_data[i].link_rsnxe_len) {
+				wpa_printf(MSG_DEBUG, "FT MIC link %zu rsnxe len %d curr index %zu",
+					   i, assoc_links_data->link_data[i].link_rsnxe_len, num_elem);
+				addr[num_elem] = assoc_links_data->link_data[i].link_rsnxe;
+				len[num_elem] = assoc_links_data->link_data[i].link_rsnxe_len;
+				num_elem++;
+				if (elem_count)
+					*elem_count += 1;
+			}
+		}
+	} else
+#endif /* CONFIG_IEEE80211BE */
+
 	if (rsnxe) {
 		addr[num_elem] = rsnxe;
 		len[num_elem] = rsnxe_len;
 		num_elem++;
+		if (elem_count)
+			*elem_count += 1;
 	}
 
 	if (extra) {
@@ -986,6 +1027,18 @@ int wpa_ft_mic(int key_mgmt, const u8 *k
 		num_elem++;
 	}
 
+#ifdef CONFIG_IEEE80211BE
+	if (assoc_links_data) {
+		for (i = 0; i < assoc_links_data->num_links ; i++) {
+			wpa_printf(MSG_DEBUG, " FT MIC link %zu addr %pM curr index %zu",
+				   i, assoc_links_data->link_data[i].link_addr, num_elem);
+			addr[num_elem] = assoc_links_data->link_data[i].link_addr;
+			len[num_elem] = ETH_ALEN;
+			num_elem++;
+		}
+	}
+#endif /* CONFIG_IEEE80211BE */
+
 	for (i = 0; i < num_elem; i++)
 		wpa_hexdump(MSG_MSGDUMP, "FT: MIC data", addr[i], len[i]);
 	res = -1;
--- a/src/common/wpa_common.h
+++ b/src/common/wpa_common.h
@@ -443,6 +443,22 @@ struct rsn_rdie {
 	le16 status_code;
 } STRUCT_PACKED;
 
+struct link_data {
+	u8 link_id;
+	u8 link_addr[ETH_ALEN];
+	const u8 link_rsnie[255];
+	int link_rsnie_len;
+	const u8 *link_rsnxe;
+	int link_rsnxe_len;
+};
+
+struct ft_mld_links_data {
+	u8 num_links;
+	struct link_data *link_data;
+	bool has_rsn;
+	bool has_rsnx;
+};
+
 /* WFA Transition Disable KDE (using OUI_WFA) */
 /* Transition Disable Bitmap bits */
 #define TRANSITION_DISABLE_WPA3_PERSONAL BIT(0)
@@ -492,6 +508,8 @@ int wpa_ft_mic(int key_mgmt, const u8 *k
 	       const u8 *ric, size_t ric_len,
 	       const u8 *rsnxe, size_t rsnxe_len,
 	       const struct wpabuf *extra,
+	       u8 *elem_count,
+	       struct ft_mld_links_data *assoc_links_data,
 	       u8 *mic);
 int wpa_derive_pmk_r0(const u8 *xxkey, size_t xxkey_len,
 		      const u8 *ssid, size_t ssid_len,
--- a/src/rsn_supp/wpa_ft.c
+++ b/src/rsn_supp/wpa_ft.c
@@ -476,7 +476,7 @@ static u8 * wpa_ft_gen_req_ies(struct wp
 			       (u8 *) rsnie, 2 + rsnie->len, ric_ies,
 			       ric_ies_len, rsnxe_len ? rsnxe : NULL, rsnxe_len,
 			       NULL,
-			       fte_mic) < 0) {
+			       NULL, NULL, fte_mic) < 0) {
 			wpa_printf(MSG_INFO, "FT: Failed to calculate MIC");
 			os_free(buf);
 			return NULL;
@@ -1159,7 +1159,7 @@ int wpa_ft_validate_reassoc_resp(struct
 		       parse.rsnxe ? parse.rsnxe - 2 : NULL,
 		       parse.rsnxe ? parse.rsnxe_len + 2 : 0,
 		       NULL,
-		       mic) < 0) {
+		       NULL, NULL, mic) < 0) {
 		wpa_printf(MSG_DEBUG, "FT: Failed to calculate MIC");
 		goto fail;
 	}
--- a/wlantest/rx_mgmt.c
+++ b/wlantest/rx_mgmt.c
@@ -1703,7 +1703,7 @@ static void rx_mgmt_reassoc_req(struct w
 			       parse.rsnxe ? parse.rsnxe - 2 : NULL,
 			       parse.rsnxe ? parse.rsnxe_len + 2 : 0,
 			       extra,
-			       mic) < 0) {
+			       NULL, NULL, mic) < 0) {
 			wpabuf_free(extra);
 			add_note(wt, MSG_INFO, "FT: Failed to calculate MIC");
 			goto out;
@@ -2398,7 +2398,7 @@ static void rx_mgmt_reassoc_resp(struct
 			       rsnxe ? wpabuf_head(rsnxe) : NULL,
 			       rsnxe ? wpabuf_len(rsnxe) : 0,
 			       extra,
-			       mic) < 0) {
+			       NULL, NULL, mic) < 0) {
 			add_note(wt, MSG_INFO, "FT: Failed to calculate MIC");
 			goto out;
 		}
--- a/src/ap/ieee802_11_eht.c
+++ b/src/ap/ieee802_11_eht.c
@@ -1085,6 +1085,7 @@ static const u8 * auth_skip_fixed_fields
 	 * (Presence of fields and elements in Authentications frames) */
 	switch (auth_alg) {
 	case WLAN_AUTH_OPEN:
+	case WLAN_AUTH_FT:
 		return pos;
 #ifdef CONFIG_SAE
 	case WLAN_AUTH_SAE:
@@ -1105,7 +1106,6 @@ static const u8 * auth_skip_fixed_fields
 		return pos;
 #endif /* CONFIG_SAE */
 	/* TODO: Support additional algorithms that can be used for MLO */
-	case WLAN_AUTH_FT:
 	case WLAN_AUTH_FILS_SK:
 	case WLAN_AUTH_FILS_SK_PFS:
 	case WLAN_AUTH_FILS_PK:
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -2965,12 +2965,12 @@ static void handle_auth(struct hostapd_d
 
 	wpa_printf(MSG_DEBUG, "authentication: STA=" MACSTR " auth_alg=%d "
 		   "auth_transaction=%d status_code=%d wep=%d%s "
-		   "seq_ctrl=0x%x%s%s",
+		   "seq_ctrl=0x%x%s%s ml sta %d",
 		   MAC2STR(sa), auth_alg, auth_transaction,
 		   status_code, !!(fc & WLAN_FC_ISWEP),
 		   challenge ? " challenge" : "",
 		   seq_ctrl, (fc & WLAN_FC_RETRY) ? " retry" : "",
-		   from_queue ? " (from queue)" : "");
+		   from_queue ? " (from queue)" : "", mld_sta);
 
 #ifdef CONFIG_NO_RC4
 	if (auth_alg == WLAN_AUTH_SHARED_KEY) {
@@ -3304,14 +3304,26 @@ static void handle_auth(struct hostapd_d
 #ifdef CONFIG_IEEE80211R_AP
 	case WLAN_AUTH_FT:
 		sta->auth_alg = WLAN_AUTH_FT;
-		if (sta->wpa_sm == NULL)
+		if (sta->wpa_sm == NULL) {
 			sta->wpa_sm = wpa_auth_sta_init(hapd->wpa_auth,
 							sta->addr, NULL);
-		if (sta->wpa_sm == NULL) {
-			wpa_printf(MSG_DEBUG, "FT: Failed to initialize WPA "
-				   "state machine");
-			resp = WLAN_STATUS_UNSPECIFIED_FAILURE;
-			goto fail;
+			if (sta->wpa_sm == NULL) {
+				wpa_printf(MSG_DEBUG, "FT: Failed to initialize WPA "
+					   "state machine");
+				resp = WLAN_STATUS_UNSPECIFIED_FAILURE;
+				goto fail;
+			}
+#ifdef CONFIG_IEEE80211BE
+			struct mld_info *sta_mld_info = &sta->mld_info;
+			if (ap_sta_is_mld(hapd, sta)) {
+				wpa_printf(MSG_DEBUG,
+					   "MLD: Set ML info in RSN Authenticator");
+				wpa_auth_set_ml_info(sta->wpa_sm,
+						     hapd->mld_link_id,
+						     sta->mld_assoc_link_id,
+						     sta_mld_info);
+			}
+#endif /* CONFIG_IEEE80211BE */
 		}
 		wpa_ft_process_auth(sta->wpa_sm,
 				    auth_transaction, mgmt->u.auth.variable,
@@ -4218,8 +4230,13 @@ static int __check_assoc_ies(struct host
 				return WLAN_STATUS_UNSPECIFIED_FAILURE;
 			}
 
+#ifdef CONFIG_IEEE80211BE
+			resp = wpa_ft_validate_reassoc(sta->wpa_sm, ies,
+						       ies_len, &sta->mld_info);
+#else /* CONFIG_IEEE80211BE */
 			resp = wpa_ft_validate_reassoc(sta->wpa_sm, ies,
-						       ies_len);
+						       ies_len, NULL);
+#endif /* CONFIG_IEEE80211BE */
 			if (resp != WLAN_STATUS_SUCCESS)
 				return resp;
 		}
@@ -4227,6 +4244,22 @@ static int __check_assoc_ies(struct host
 
 		if (link)
 			goto skip_sae_owe;
+#ifdef CONFIG_IEEE80211BE
+		/*
+		 * For FT, since the MIC has been validated, reset the affiliated
+		 * links' auth references of previous association.
+		 */
+		if (info->mld_sta && sta->auth_alg == WLAN_AUTH_FT) {
+			sta->wpa_sm->n_mld_affiliated_links = 0;
+			wpa_auth_reset_ml_link_info(sta->wpa_sm, sta->mld_assoc_link_id);
+			wpa_printf(MSG_DEBUG,
+				   "MLD: Set ML info in RSN Authenticator");
+			wpa_auth_set_ml_info(sta->wpa_sm,
+					     hapd->mld_link_id,
+					     sta->mld_assoc_link_id,
+					     info);
+		}
+#endif /* CONFIG_IEEE80211BE */
 #ifdef CONFIG_SAE
 		if (wpa_auth_uses_sae(sta->wpa_sm) && sta->sae &&
 		    sta->sae->state == SAE_ACCEPTED)
@@ -4499,11 +4532,16 @@ static int check_assoc_ies(struct hostap
 #ifdef CONFIG_IEEE80211BE
 
 static void ieee80211_ml_build_assoc_resp(struct hostapd_data *hapd,
+					    struct hostapd_data *phapd,
+					    struct sta_info *sta,
 					  struct mld_link_info *link)
 {
 	u8 buf[EHT_ML_MAX_STA_PROF_LEN];
 	u8 *p = buf;
 	size_t buflen = sizeof(buf);
+	u8 assoc_rsne[128];
+	u8 link_rsne[128];
+	size_t assoc_rsn_len, link_rsn_len;
 
 	/* Capability Info */
 	WPA_PUT_LE16(p, hostapd_own_capab_info(hapd));
@@ -4523,6 +4561,22 @@ static void ieee80211_ml_build_assoc_res
 	p = hostapd_eid_ht_capabilities(hapd, p);
 	p = hostapd_eid_ht_operation(hapd, p);
 
+#ifdef CONFIG_IEEE80211R_AP
+	if (phapd && hapd && (sta->auth_alg == WLAN_AUTH_FT)) {
+		assoc_rsn_len = wpa_write_rsn_ie(&phapd->wpa_auth->conf,
+						 assoc_rsne, sizeof(assoc_rsne),
+						 sta->wpa_sm->pmk_r1_name);
+		link_rsn_len = wpa_write_rsn_ie(&hapd->wpa_auth->conf, link_rsne,
+						sizeof(link_rsne),
+						sta->wpa_sm->pmk_r1_name);
+		if ((assoc_rsn_len != link_rsn_len) ||
+		    (os_memcmp(assoc_rsne, link_rsne, assoc_rsn_len) != 0)) {
+			os_memcpy(p, link_rsne, link_rsn_len);
+			p += link_rsn_len;
+		}
+	}
+#endif
+
 	if (hapd->iconf->ieee80211ac && !hapd->conf->disable_11ac) {
 		p = hostapd_eid_vht_capabilities(hapd, p, 0);
 		p = hostapd_eid_vht_operation(hapd, p);
@@ -4560,6 +4614,7 @@ out:
 
 
 static int ieee80211_ml_process_link(struct hostapd_data *hapd,
+				      struct hostapd_data *phapd,
 				     struct sta_info *origin_sta,
 				     struct mld_link_info *link,
 				     const u8 *ies, size_t ies_len,
@@ -4670,7 +4725,7 @@ out:
 	link->status = status;
 
 	if (!offload)
-		ieee80211_ml_build_assoc_resp(hapd, link);
+		ieee80211_ml_build_assoc_resp(hapd, phapd, sta, link);
 
 	wpa_printf(MSG_DEBUG, "MLD: link: status=%u", status);
 	if (status != WLAN_STATUS_SUCCESS) {
@@ -4735,14 +4790,14 @@ int hostapd_process_assoc_ml_info(struct
 
 			link->status = WLAN_STATUS_UNSPECIFIED_FAILURE;
 			if (!offload)
-				ieee80211_ml_build_assoc_resp(hapd, link);
+				ieee80211_ml_build_assoc_resp(hapd, NULL, sta, link);
 		} else if (tx_link_status != WLAN_STATUS_SUCCESS) {
 			/* TX link rejected the connection */
 			link->status = WLAN_STATUS_DENIED_TX_LINK_NOT_ACCEPTED;
 			if (!offload)
-				ieee80211_ml_build_assoc_resp(hapd, link);
+				ieee80211_ml_build_assoc_resp(hapd, NULL, sta, link);
 		} else {
-			if (ieee80211_ml_process_link(bss, sta, link,
+			if (ieee80211_ml_process_link(bss, hapd, sta, link,
 						      ies, ies_len, reassoc,
 						      offload))
 				return -1;
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -663,7 +663,7 @@ int hostapd_notif_assoc(struct hostapd_d
 #ifdef CONFIG_IEEE80211R_AP
 		if (sta->auth_alg == WLAN_AUTH_FT) {
 			status = wpa_ft_validate_reassoc(sta->wpa_sm, req_ies,
-							 req_ies_len);
+							 req_ies_len, NULL);
 			if (status != WLAN_STATUS_SUCCESS) {
 				if (status == WLAN_STATUS_INVALID_PMKID)
 					reason = WLAN_REASON_INVALID_IE;
--- a/src/ap/wpa_auth.h
+++ b/src/ap/wpa_auth.h
@@ -552,7 +552,7 @@ void wpa_ft_process_auth(struct wpa_stat
 				    const u8 *ies, size_t ies_len),
 			 void *ctx);
 int wpa_ft_validate_reassoc(struct wpa_state_machine *sm, const u8 *ies,
-			    size_t ies_len);
+			    size_t ies_len, struct mld_info *mld_info);
 int wpa_ft_action_rx(struct wpa_state_machine *sm, const u8 *data, size_t len);
 int wpa_ft_rrb_rx(struct wpa_authenticator *wpa_auth, const u8 *src_addr,
 		  const u8 *data, size_t data_len);
@@ -669,6 +669,7 @@ void wpa_auth_sta_radius_psk_resp(struct
 
 void wpa_auth_set_ml_info(struct wpa_state_machine *sm,
 			  u8 mld_assoc_link_id, struct mld_info *info);
+void wpa_auth_reset_ml_link_info(struct wpa_state_machine *sm, u8 mld_assoc_link_id);
 void wpa_auth_ml_get_key_info(struct wpa_authenticator *a,
 			      struct wpa_auth_ml_link_key_info *info,
 			      bool mgmt_frame_prot, bool beacon_prot,
