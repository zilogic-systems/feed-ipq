From 8de75eca2dd7f21335de5a57448ae1eb00d11ce3 Mon Sep 17 00:00:00 2001
From: Balamurugan Mahalingam <quic_bmahalin@quicinc.com>
Date: Mon, 10 Jun 2024 15:53:29 -0700
Subject: [PATCH] hostapd: Add support for configuring interface offload type

Add support to configure interface offload type through the configuration
file. This configuration allows to choose datapath offload type on a per
netdevice basis. Configure the datapath offload type using option 'ppe_vp'
in the uci under the wifi iface and then option would be configured to
the driver using a vendor command. The hostapd reads this configured value
from the config file and then sends the vendor command to configure the
driver to use the right datapath offload as instructed by the user

Patch-dependency: None

Signed-off-by: Balamurugan Mahalingam <quic_bmahalin@quicinc.com>
---
 hostapd/config_file.c                |   2 +
 hostapd/main.c                       |   3 +
 src/ap/ap_config.h                   |   2 +
 src/ap/ap_drv_ops.c                  |  19 ++++-
 src/ap/ap_drv_ops.h                  |   3 +-
 src/ap/hostapd.c                     |   2 +-
 src/common/qca-vendor.h              |  57 ++++++++++++++
 src/drivers/driver.h                 |  15 +++-
 src/drivers/driver_bsd.c             |   2 +-
 src/drivers/driver_nl80211.c         | 109 +++++++++++++++++++++++----
 src/drivers/driver_nl80211.h         |   3 +-
 src/drivers/driver_nl80211_monitor.c |   2 +-
 wpa_supplicant/config.c              |   1 +
 wpa_supplicant/config.h              |  11 +++
 wpa_supplicant/driver_i.h            |  23 +++++-
 wpa_supplicant/wpa_priv.c            |   5 +-
 wpa_supplicant/wpa_supplicant.c      |   4 +-
 17 files changed, 232 insertions(+), 31 deletions(-)

--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -2403,6 +2403,8 @@ static int hostapd_config_fill(struct ho
 			os_strlcpy(bss->wds_bridge, pos, sizeof(bss->wds_bridge));
 	} else if (os_strcmp(buf, "bridge_hairpin") == 0) {
 		bss->bridge_hairpin = atoi(pos);
+	} else if (os_strcmp(buf, "ppe_vp") == 0) {
+		bss->ppe_vp_type = atoi(pos);
 	} else if (os_strcmp(buf, "snoop_iface") == 0) {
 		os_strlcpy(bss->snoop_iface, pos, sizeof(bss->snoop_iface));
 	} else if (os_strcmp(buf, "vlan_bridge") == 0) {
--- a/hostapd/main.c
+++ b/hostapd/main.c
@@ -240,6 +240,7 @@ static int hostapd_driver_init(struct ho
 
 	params.num_bridge = hapd->iface->num_bss;
 	params.bridge = os_calloc(hapd->iface->num_bss, sizeof(char *));
+	params.ppe_vp_type = conf ? conf->ppe_vp_type : -1;
 	if (params.bridge == NULL)
 		return -1;
 	for (i = 0; i < hapd->iface->num_bss; i++) {
@@ -270,6 +271,10 @@ static int hostapd_driver_init(struct ho
 
 #ifdef CONFIG_IEEE80211BE
 pre_setup_mld:
+	if (hostapd_drv_mark_ppe_vp_type(hapd))
+		wpa_printf(MSG_ERROR, "ppe_vp vendor command failed: %s",
+			   hapd->conf->iface);
+
 	/*
 	 * This is the first interface added to the AP MLD, so have the
 	 * interface hardware address be the MLD address, while the link address
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -13,6 +13,7 @@
 #include "utils/list.h"
 #include "ip_addr.h"
 #include "common/wpa_common.h"
+#include "common/qca-vendor.h"
 #include "common/ieee802_11_defs.h"
 #include "common/ieee802_11_common.h"
 #include "crypto/sha256.h"
@@ -1018,6 +1019,8 @@ struct hostapd_bss_config {
 
 	bool wmm_override;
 	struct hostapd_wmm_ac_params wmm_ac_params[4];
+
+	enum qca_wlan_intf_offload_type ppe_vp_type;
 };
 
 /**
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -24,6 +24,7 @@
 #include "ap_drv_ops.h"
 #ifdef CONFIG_IEEE80211BE
 #include "scs.h"
+#include "common/qca-vendor.h"
 #endif
 
 u32 hostapd_sta_flags_to_drv(u32 flags)
@@ -391,7 +392,7 @@ int hostapd_vlan_if_add(struct hostapd_d
 		addr = hapd->own_addr;
 
 	return hostapd_if_add(hapd, WPA_IF_AP_VLAN, ifname, addr,
-			      NULL, NULL, force_ifname, if_addr, NULL, 0);
+			      NULL, NULL, force_ifname, if_addr, NULL, 0, hapd->conf->ppe_vp_type);
 }
 
 
@@ -465,6 +466,18 @@ int hostapd_set_scs_params(struct hostap
 	os_memcpy(scs_drv.peer_mac, scs_m->peer_mac, 6);
 	return hapd->driver->set_scs(hapd->drv_priv, &scs_drv);
 }
+
+int hostapd_drv_mark_ppe_vp_type(struct hostapd_data *hapd)
+{
+	if (hapd->driver == NULL || hapd->driver->mark_ppe_vp_type == NULL)
+		return -1;
+
+	return hapd->driver->mark_ppe_vp_type(hapd->drv_priv,
+			OUI_QCA,
+			QCA_NL80211_VENDOR_SUBCMD_SET_WIFI_CONFIGURATION,
+			NULL, 0, 0, NULL, hapd->conf->iface,
+			hapd->conf->ppe_vp_type, true);
+}
 #endif
 
 int hostapd_sta_auth(struct hostapd_data *hapd, const u8 *addr,
@@ -632,13 +645,13 @@ int hostapd_set_ssid(struct hostapd_data
 int hostapd_if_add(struct hostapd_data *hapd, enum wpa_driver_if_type type,
 		   const char *ifname, const u8 *addr, void *bss_ctx,
 		   void **drv_priv, char *force_ifname, u8 *if_addr,
-		   const char *bridge, int use_existing)
+		   const char *bridge, int use_existing, int ppe_vp_type)
 {
 	if (hapd->driver == NULL || hapd->driver->if_add == NULL)
 		return -1;
 	return hapd->driver->if_add(hapd->drv_priv, type, ifname, addr,
 				    bss_ctx, drv_priv, force_ifname, if_addr,
-				    bridge, use_existing, 1);
+				    bridge, use_existing, 1, ppe_vp_type);
 }
 
 
--- a/src/ap/ap_drv_ops.h
+++ b/src/ap/ap_drv_ops.h
@@ -65,7 +65,7 @@ int hostapd_set_ssid(struct hostapd_data
 int hostapd_if_add(struct hostapd_data *hapd, enum wpa_driver_if_type type,
 		   const char *ifname, const u8 *addr, void *bss_ctx,
 		   void **drv_priv, char *force_ifname, u8 *if_addr,
-		   const char *bridge, int use_existing);
+		   const char *bridge, int use_existing, int ppe_vp_type);
 int hostapd_if_remove(struct hostapd_data *hapd, enum wpa_driver_if_type type,
 		      const char *ifname);
 int hostapd_if_link_remove(struct hostapd_data *hapd,
@@ -165,6 +165,7 @@ int hostapd_drv_set_secure_ranging_ctx(s
 #ifdef CONFIG_IEEE80211BE
 int hostapd_set_scs_params(struct hostapd_data *hapd, struct sta_info *sta,
 			   struct hostapd_qos_mandatory_scs_param *scs_m, u8 req_type);
+int hostapd_drv_mark_ppe_vp_type(struct hostapd_data *hapd);
 #endif
 
 #include "drivers/driver.h"
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -1697,7 +1697,7 @@ int hostapd_setup_bss(struct hostapd_dat
 				   conf->iface, addr, hapd,
 				   &hapd->drv_priv, force_ifname, if_addr,
 				   conf->bridge[0] ? conf->bridge : NULL,
-				   first == -1)) {
+				   first == -1, hapd->conf->ppe_vp_type)) {
 			wpa_printf(MSG_ERROR, "Failed to add BSS (BSSID="
 				   MACSTR ")", MAC2STR(hapd->own_addr));
 			hapd->interface_added = 0;
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -23,6 +23,7 @@
 #include "common/ieee802_11_defs.h"
 #include "common/wpa_common.h"
 #include "common/nan.h"
+#include "common/qca-vendor.h"
 #ifdef CONFIG_MACSEC
 #include "pae/ieee802_1x_kay.h"
 #endif /* CONFIG_MACSEC */
@@ -2780,6 +2781,7 @@ struct wpa_init_params {
 	size_t num_bridge;
 
 	u8 *own_addr; /* buffer for writing own MAC address */
+	enum qca_wlan_intf_offload_type ppe_vp_type;
 };
 
 
@@ -3703,7 +3705,8 @@ struct wpa_driver_ops {
 	 * This function can be used instead of init() if the driver wrapper
 	 * uses global data.
 	 */
-	void * (*init2)(void *ctx, const char *ifname, void *global_priv);
+	void * (*init2)(void *ctx, const char *ifname, void *global_priv,
+			int ppe_vp_type);
 
 	/**
 	 * get_interfaces - Get information about available interfaces
@@ -4114,7 +4117,8 @@ struct wpa_driver_ops {
 	int (*if_add)(void *priv, enum wpa_driver_if_type type,
 		      const char *ifname, const u8 *addr, void *bss_ctx,
 		      void **drv_priv, char *force_ifname, u8 *if_addr,
-		      const char *bridge, int use_existing, int setup_ap);
+		      const char *bridge, int use_existing, int setup_ap,
+		      int ppe_vp_type);
 
 	/**
 	 * if_remove - Remove a virtual interface
@@ -5613,6 +5617,13 @@ struct wpa_driver_ops {
 	 */
 	int (*ml_reconfig_link_remove)(void *priv, enum wpa_driver_if_type type,
 				        const struct driver_reconfig_link_removal_params *params);
+	int (*mark_ppe_vp_type)(void *priv, unsigned int vendor_id,
+				unsigned int subcmd, const u8 *data,
+				size_t data_len,
+				enum nested_attr nested_attr_flag,
+				struct wpabuf *buf, const char *ifname,
+				int ppe_vp_type, bool is_bss);
+
 #endif /* CONFIG_IEEE80211BE */
 };
 
--- a/src/drivers/driver_bsd.c
+++ b/src/drivers/driver_bsd.c
@@ -1558,7 +1558,7 @@ get80211opmode(struct bsd_driver_data *d
 }
 
 static void *
-wpa_driver_bsd_init(void *ctx, const char *ifname, void *priv)
+wpa_driver_bsd_init(void *ctx, const char *ifname, void *priv, int ppe_vp_type)
 {
 #define	GETPARAM(drv, param, v) \
 	(((v) = get80211param(drv, param)) != -1)
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -216,6 +216,14 @@ static int i802_sta_disassoc(void *priv,
 			     u16 reason, int link_id);
 
 
+static int nl80211_vendor_cmd_if_offload_type(void *priv,  unsigned int vendor_id,
+					      unsigned int subcmd,
+					      const u8 *data,
+					      size_t data_len,
+					      enum nested_attr nested_attr,
+					      struct wpabuf *buf, const char *ifname,
+					      int ppe_vp_type, bool is_bss);
+
 /* Converts nl80211_chan_width to a common format */
 enum chan_width convert2width(int width)
 {
@@ -2320,7 +2328,8 @@ wpa_driver_nl80211_drv_init_rfkill(struc
 static void * wpa_driver_nl80211_drv_init(void *ctx, const char *ifname,
 					  void *global_priv, int hostapd,
 					  const u8 *set_addr,
-					  const char *driver_params)
+					  const char *driver_params,
+					  int ppe_vp_type)
 {
 	struct wpa_driver_nl80211_data *drv;
 	struct i802_bss *bss;
@@ -2374,6 +2383,7 @@ static void * wpa_driver_nl80211_drv_ini
 	bss = drv->first_bss;
 	bss->drv = drv;
 	bss->ctx = ctx;
+	bss->ppe_vp_type = ppe_vp_type;
 
 	os_strlcpy(bss->ifname, ifname, sizeof(bss->ifname));
 	drv->monitor_ifidx = -1;
@@ -2447,10 +2457,10 @@ failed:
  * Returns: Pointer to private data, %NULL on failure
  */
 static void * wpa_driver_nl80211_init(void *ctx, const char *ifname,
-				      void *global_priv)
+				      void *global_priv, int ppe_vp_type)
 {
 	return wpa_driver_nl80211_drv_init(ctx, ifname, global_priv, 0, NULL,
-					   NULL);
+					   NULL, ppe_vp_type);
 }
 
 
@@ -6354,15 +6364,13 @@ static int nl80211_create_iface_once(str
 	return ifidx;
 }
 
-
 int nl80211_create_iface(struct wpa_driver_nl80211_data *drv,
 			 const char *ifname, enum nl80211_iftype iftype,
 			 const u8 *addr, int wds,
 			 int (*handler)(struct nl_msg *, void *),
-			 void *arg, int use_existing)
+			 void *arg, int use_existing, int ppe_vp_type)
 {
 	int ret;
-
 	ret = nl80211_create_iface_once(drv, ifname, iftype, addr, wds, handler,
 					arg);
 
@@ -6400,10 +6408,13 @@ int nl80211_create_iface(struct wpa_driv
 		nl80211_disable_11b_rates(drv, ret, 1);
 	}
 
+	nl80211_vendor_cmd_if_offload_type((void *)drv,  OUI_QCA,
+					   QCA_NL80211_VENDOR_SUBCMD_SET_WIFI_CONFIGURATION,
+					   NULL, 0, 0, NULL, ifname,
+					   ppe_vp_type, false);
 	return ret;
 }
 
-
 static int nl80211_setup_ap(struct i802_bss *bss)
 {
 	struct wpa_driver_nl80211_data *drv = bss->drv;
@@ -7667,6 +7678,12 @@ static int nl80211_set_mode(struct i802_
 	wpa_printf(MSG_DEBUG, "nl80211: Set mode ifindex %d iftype %d (%s)",
 		   ifindex, mode, nl80211_iftype_str(mode));
 
+	if (bss->ppe_vp_type > 0)
+		nl80211_vendor_cmd_if_offload_type((void *)drv,  OUI_QCA,
+						   QCA_NL80211_VENDOR_SUBCMD_SET_WIFI_CONFIGURATION,
+						   NULL, 0, 0, NULL, bss->ifname,
+						   bss->ppe_vp_type, false);
+
 	msg = nl80211_cmd_msg(bss, 0, NL80211_CMD_SET_INTERFACE);
 	if (!msg || nla_put_u32(msg, NL80211_ATTR_IFTYPE, mode))
 		goto fail;
@@ -8772,10 +8789,10 @@ static int i802_set_wds_sta(void *priv,
 
 	if (val) {
 		if (!if_nametoindex(name)) {
+			/* TODO: Fix PPE_VP_TYPE for VLAN interface */
 			if (nl80211_create_iface(drv, name,
 						 NL80211_IFTYPE_AP_VLAN,
-						 bss->addr, 1, NULL, NULL, 0) <
-			    0)
+						 bss->addr, 1, NULL, NULL, 0, 0) <  0)
 				return -1;
 
 			if (bridge_ifname)
@@ -8928,7 +8945,8 @@ static void *i802_init(struct hostapd_da
 
 	bss = wpa_driver_nl80211_drv_init(hapd, params->ifname,
 					  params->global_priv, 1,
-					  params->bssid, params->driver_params);
+					  params->bssid, params->driver_params,
+					  params->ppe_vp_type);
 	if (bss == NULL)
 		return NULL;
 
@@ -9132,7 +9150,7 @@ static int wpa_driver_nl80211_if_add(voi
 				     void *bss_ctx, void **drv_priv,
 				     char *force_ifname, u8 *if_addr,
 				     const char *bridge, int use_existing,
-				     int setup_ap)
+				     int setup_ap, int ppe_vp_type)
 {
 	enum nl80211_iftype nlmode;
 	struct i802_bss *bss = priv;
@@ -9149,7 +9167,7 @@ static int wpa_driver_nl80211_if_add(voi
 		os_memset(&p2pdev_info, 0, sizeof(p2pdev_info));
 		ifidx = nl80211_create_iface(drv, ifname, nlmode, addr,
 					     0, nl80211_wdev_handler,
-					     &p2pdev_info, use_existing);
+					     &p2pdev_info, use_existing, ppe_vp_type);
 		if (!p2pdev_info.wdev_id_set || ifidx != 0) {
 			wpa_printf(MSG_ERROR, "nl80211: Failed to create a P2P Device interface %s",
 				   ifname);
@@ -9165,7 +9183,7 @@ static int wpa_driver_nl80211_if_add(voi
 			   (long long unsigned int) p2pdev_info.wdev_id);
 	} else {
 		ifidx = nl80211_create_iface(drv, ifname, nlmode, addr,
-					     0, NULL, NULL, use_existing);
+					     0, NULL, NULL, use_existing, ppe_vp_type);
 		if (use_existing && ifidx == -ENFILE) {
 			added = 0;
 			ifidx = if_nametoindex(ifname);
@@ -12240,6 +12258,69 @@ static bool is_cmd_with_nested_attrs(uns
 	}
 }
 
+static int nl80211_vendor_cmd_if_offload_type(void *priv,  unsigned int vendor_id,
+					      unsigned int subcmd,
+					      const u8 *data,
+					      size_t data_len,
+					      enum nested_attr nested_attr,
+					      struct wpabuf *buf, const char *ifname,
+					      int ppe_vp_type, bool is_bss)
+{
+	struct i802_bss *bss = NULL;
+	struct wpa_driver_nl80211_data *drv =  NULL;
+	struct nl_msg *msg;
+	struct nlattr *attr;
+	int ret;
+	int ifidx;
+
+	if (is_bss) {
+		bss = priv;
+		drv = bss->drv;
+		bss->ppe_vp_type = ppe_vp_type;
+	} else {
+		drv = priv;
+	}
+
+	if (!drv)
+		return -EINVAL;
+
+	ifidx = if_nametoindex(ifname);
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -EINVAL;
+
+	if (!genlmsg_put(msg, 0, 0, drv->global->nl80211_id,
+			0,  0, NL80211_CMD_VENDOR, 0))
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, ifidx) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, vendor_id) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, subcmd))
+		goto fail;
+
+	attr = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if(!attr)
+		goto fail;
+
+	if (nla_put_u8(msg, QCA_WLAN_VENDOR_ATTR_CONFIG_INTF_OFFLOAD_TYPE,
+		       ppe_vp_type))
+		goto fail;
+
+	nla_nest_end(msg, attr);
+
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret)
+		wpa_printf(MSG_ERROR, "nl80211: vendor command failed err=%d",
+			   ret);
+	else
+		wpa_printf(MSG_INFO, "nl80211: vendorcmd ppe: ifname %s ppe_vp %d",
+			   ifname, ppe_vp_type);
+	return ret;
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
 
 static int nl80211_vendor_cmd(void *priv, unsigned int vendor_id,
 			      unsigned int subcmd, const u8 *data,
@@ -15055,6 +15136,7 @@ static int wpa_driver_nl80211_can_share_
 	bss = drv->first_bss;
 	bss->drv = drv;
 	bss->ctx = ctx;
+	bss->ppe_vp_type = params->ppe_vp_type;
 
 	os_strlcpy(bss->ifname, params->ifname, sizeof(bss->ifname));
 
@@ -15090,7 +15172,7 @@ static int wpa_driver_nl80211_can_share_
 				      params->ifname, addr, ctx, drv_priv,
 				      force_ifname, if_addr,
 				      params->num_bridge && params->bridge[0] ? params->bridge[0] : NULL,
-				      1, 1)) {
+				      1, 1, params->ppe_vp_type)) {
 		wpa_printf(MSG_DEBUG, "nl80211: Failed to add BSS. Expect issues!");
 		goto free_all;
 	}
@@ -15346,6 +15428,7 @@ const struct wpa_driver_ops wpa_driver_n
 	.can_share_drv = wpa_driver_nl80211_can_share_drv,
 	.set_scs = nl80211_set_scs,
 	.ml_reconfig_link_remove = driver_nl80211_ml_reconfig_link_removal,
+	.mark_ppe_vp_type = nl80211_vendor_cmd_if_offload_type,
 #endif /* CONFIG_IEEE80211BE */
 #ifdef CONFIG_TESTING_OPTIONS
 	.register_frame = testing_nl80211_register_frame,
--- a/src/drivers/driver_nl80211.h
+++ b/src/drivers/driver_nl80211.h
@@ -96,6 +96,7 @@ struct i802_bss {
 	struct nl80211_wiphy_data *wiphy_data;
 	struct dl_list wiphy_list;
 	u8 rand_addr[ETH_ALEN];
+	int ppe_vp_type;
 };
 
 struct drv_nl80211_if_info {
@@ -314,7 +315,7 @@ int nl80211_create_iface(struct wpa_driv
 			 const char *ifname, enum nl80211_iftype iftype,
 			 const u8 *addr, int wds,
 			 int (*handler)(struct nl_msg *, void *),
-			 void *arg, int use_existing);
+			 void *arg, int use_existing, int ppe_vp_type);
 void nl80211_remove_iface(struct wpa_driver_nl80211_data *drv, int ifidx);
 unsigned int nl80211_get_assoc_freq(struct wpa_driver_nl80211_data *drv);
 int nl80211_get_assoc_ssid(struct wpa_driver_nl80211_data *drv, u8 *ssid);
--- a/src/drivers/driver_nl80211_monitor.c
+++ b/src/drivers/driver_nl80211_monitor.c
@@ -381,7 +381,7 @@ int nl80211_create_monitor_interface(str
 
 	drv->monitor_ifidx =
 		nl80211_create_iface(drv, buf, NL80211_IFTYPE_MONITOR, NULL,
-				     0, NULL, NULL, 0);
+				     0, NULL, NULL, 0, 0);
 
 	if (drv->monitor_ifidx == -EOPNOTSUPP) {
 		/*
--- a/wpa_supplicant/config.c
+++ b/wpa_supplicant/config.c
@@ -5722,6 +5722,8 @@ static const struct global_parse_data gl
 	{ FUNC(mld_connect_bssid_pref), 0 },
 #endif /* CONFIG_TESTING_OPTIONS */
 	{ INT_RANGE(ft_prepend_pmkid, 0, 1), CFG_CHANGED_FT_PREPEND_PMKID },
+	{ INT_RANGE(ppe_vp, 0, 3), 1 },
+
 	/* NOTE: When adding new parameters here, add_interface() in
 	 * wpa_supplicant/dbus_new_introspect.c may need to be modified to
 	 * increase the size of the iface->xml buffer. */
--- a/wpa_supplicant/config.h
+++ b/wpa_supplicant/config.h
@@ -1814,6 +1814,17 @@ struct wpa_config {
 
 	int disable_csa_dfs;
 
+	/**
+	 * ppe_vp_type - Type of PPE mode per interface
+	 *
+	 * 0 - NONE
+	 * 1 - PASSIVE aka RFS
+	 * 2 - ACTIVE aka active PPE assist
+	 * 3 - Direct Switching
+	 * others - invalid
+	 */
+	int ppe_vp;
+
 #ifdef CONFIG_TESTING_OPTIONS
 	enum {
 		MLD_CONNECT_BAND_PREF_AUTO = 0,
--- a/wpa_supplicant/driver_i.h
+++ b/wpa_supplicant/driver_i.h
@@ -11,14 +11,15 @@
 
 #include "common/nan_de.h"
 #include "drivers/driver.h"
+#include "common/qca-vendor.h"
 
 /* driver_ops */
 static inline void * wpa_drv_init(struct wpa_supplicant *wpa_s,
-				  const char *ifname)
+				  const char *ifname, int ppe_vp_type)
 {
 	if (wpa_s->driver->init2)
 		return wpa_s->driver->init2(wpa_s, ifname,
-					    wpa_s->global_drv_priv);
+					    wpa_s->global_drv_priv, ppe_vp_type);
 	if (wpa_s->driver->init) {
 		return wpa_s->driver->init(wpa_s, ifname);
 	}
@@ -434,10 +435,11 @@ static inline int wpa_drv_if_add(struct
 				 void *bss_ctx, char *force_ifname,
 				 u8 *if_addr, const char *bridge)
 {
+	/* TODO: Fix PPE_VP_TYPE hardcoding */
 	if (wpa_s->driver->if_add)
 		return wpa_s->driver->if_add(wpa_s->drv_priv, type, ifname,
 					     addr, bss_ctx, NULL, force_ifname,
-					     if_addr, bridge, 0, 0);
+					     if_addr, bridge, 0, 0, 5);
 	return -1;
 }
 
@@ -1268,4 +1270,18 @@ hostapd_multi_hw_info *wpa_get_multi_hw_
 						num_multi_hws);
 }
 
+static inline int wpa_drv_mark_ppe_vp_type(struct wpa_supplicant *wpa_s,
+					   int ppe_vp_type)
+{
+	if (!wpa_s->driver->mark_ppe_vp_type)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "sta ppe type ifname %s ppe_vp_type %d\n",
+		   wpa_s->ifname, ppe_vp_type);
+	return wpa_s->driver->mark_ppe_vp_type(wpa_s->drv_priv,
+			OUI_QCA, QCA_NL80211_VENDOR_SUBCMD_SET_WIFI_CONFIGURATION,
+			NULL, 0, 0, NULL,  wpa_s->ifname, ppe_vp_type, true);
+
+}
+
 #endif /* DRIVER_I_H */
--- a/wpa_supplicant/wpa_priv.c
+++ b/wpa_supplicant/wpa_priv.c
@@ -54,7 +54,7 @@ struct wpa_priv_global {
 
 
 static void wpa_priv_cmd_register(struct wpa_priv_interface *iface,
-				  struct sockaddr_un *from, socklen_t fromlen)
+				  struct sockaddr_un *from, socklen_t fromlen, int ppe_vp_type)
 {
 	int i;
 
@@ -642,6 +642,7 @@ static void wpa_priv_receive(int sock, v
 	size_t cmd_len;
 	int res, cmd;
 	struct sockaddr_un from;
+	int ppe_vp_type = 5;
 	socklen_t fromlen = sizeof(from);
 
 	res = recvfrom(sock, buf, sizeof(buf), 0, (struct sockaddr *) &from,
@@ -664,7 +665,7 @@ static void wpa_priv_receive(int sock, v
 
 	switch (cmd) {
 	case PRIVSEP_CMD_REGISTER:
-		wpa_priv_cmd_register(iface, &from, fromlen);
+		wpa_priv_cmd_register(iface, &from, fromlen, ppe_vp_type);
 		break;
 	case PRIVSEP_CMD_UNREGISTER:
 		wpa_priv_cmd_unregister(iface, &from);
--- a/wpa_supplicant/wpa_supplicant.c
+++ b/wpa_supplicant/wpa_supplicant.c
@@ -6150,6 +6150,7 @@ int wpa_supplicant_driver_init(struct wp
 	} else
 		wpa_supplicant_set_state(wpa_s, WPA_INACTIVE);
 
+	wpa_drv_mark_ppe_vp_type(wpa_s, wpa_s->conf->ppe_vp);
 	return 0;
 }
 
@@ -7282,7 +7283,8 @@ next_driver:
 	if (wpa_supplicant_set_driver(wpa_s, driver) < 0)
 		return -1;
 
-	wpa_s->drv_priv = wpa_drv_init(wpa_s, wpa_s->ifname);
+	/* TODO: Fix PPE_VP_TYPE hardcoding */
+	wpa_s->drv_priv = wpa_drv_init(wpa_s, wpa_s->ifname, 5);
 	if (wpa_s->drv_priv == NULL) {
 		const char *pos;
 		int level = MSG_ERROR;
