From 1ebdc4a406901f8e15f76a74518222abb5060fde Mon Sep 17 00:00:00 2001
From: Aaradhana Sahu <quic_aarasahu@quicinc.com>
Date: Fri, 8 Sep 2023 16:17:07 +0530
Subject: [PATCH] ath11k: fix compilation issue

Since it is new kernel version and there is mismatch in the functional
APIs and there is difference in the datapath HAL ring macro with
respective to mainline. Added new board configuration in the ath11k
driver module along with addition of interface details from mainline
code.

Signed-off-by: Aaradhana Sahu <quic_aarasahu@quicinc.com>
---
 drivers/net/wireless/ath/ath11k/Kconfig    |   8 --
 drivers/net/wireless/ath/ath11k/Makefile   |   2 +-
 drivers/net/wireless/ath/ath11k/ahb.c      |   4 +-
 drivers/net/wireless/ath/ath11k/ce.c       |   2 -
 drivers/net/wireless/ath/ath11k/core.c     |  11 +-
 drivers/net/wireless/ath/ath11k/core.h     |   6 +-
 drivers/net/wireless/ath/ath11k/debug.h    |  10 ++
 drivers/net/wireless/ath/ath11k/debugfs.c  |   5 +-
 drivers/net/wireless/ath/ath11k/dp.c       |  82 ++++++------
 drivers/net/wireless/ath/ath11k/dp_tx.c    |  11 +-
 drivers/net/wireless/ath/ath11k/hal.c      |   8 ++
 drivers/net/wireless/ath/ath11k/hal.h      |   3 +
 drivers/net/wireless/ath/ath11k/hal_rx.h   |   5 +-
 drivers/net/wireless/ath/ath11k/hal_tx.c   |   2 +-
 drivers/net/wireless/ath/ath11k/hal_tx.h   |   1 -
 drivers/net/wireless/ath/ath11k/hw.c       | 144 ++++++++++++++++++---
 drivers/net/wireless/ath/ath11k/hw.h       |   5 +
 drivers/net/wireless/ath/ath11k/mac.c      | 138 +++++---------------
 drivers/net/wireless/ath/ath11k/pci.c      |   9 +-
 drivers/net/wireless/ath/ath11k/peer.c     |   3 +-
 drivers/net/wireless/ath/ath11k/peer.h     |   1 -
 drivers/net/wireless/ath/ath11k/pktlog.h   |   2 +-
 drivers/net/wireless/ath/ath11k/qmi.c      |  50 ++-----
 drivers/net/wireless/ath/ath11k/qmi.h      |   9 +-
 drivers/net/wireless/ath/ath11k/reg.c      |  37 ++++--
 drivers/net/wireless/ath/ath11k/reg.h      |   2 +
 drivers/net/wireless/ath/ath11k/testmode.h |   2 +
 drivers/net/wireless/ath/ath11k/thermal.h  |   2 +-
 drivers/net/wireless/ath/ath11k/wmi.c      |  50 ++-----
 drivers/net/wireless/ath/ath11k/wmi.h      |   9 +-
 local-symbols                              |   3 +
 31 files changed, 330 insertions(+), 296 deletions(-)

--- a/drivers/net/wireless/ath/ath11k/Kconfig
+++ b/drivers/net/wireless/ath/ath11k/Kconfig
@@ -6,7 +6,6 @@ config ATH11K
 	depends on MAC80211 && HAS_DMA
 	depends on CRYPTO_MICHAEL_MIC
 	select ATH_COMMON
-	select QCOM_QMI_HELPERS
 	help
 	  This module adds support for Qualcomm Technologies 802.11ax family of
 	  chipsets.
@@ -72,13 +71,6 @@ config ATH11K_SPECTRAL
 
 	  Say Y to enable access to the FFT/spectral data via debugfs.
 
-config ATH11K_THERMAL
-	bool "ath11k thermal sensors and throttling support"
-	depends on ATH11K
-	depends on THERMAL
-	help
-	  Enable ath11k thermal sensors and throttling support.
-
 config ATH11K_PKTLOG
 	bool "ath11k packet logging support"
 	depends on ATH11K_DEBUGFS
--- a/drivers/net/wireless/ath/ath11k/Makefile
+++ b/drivers/net/wireless/ath/ath11k/Makefile
@@ -23,7 +23,7 @@ ath11k-y += core.o \
 ath11k-$(CPTCFG_ATH11K_DEBUGFS) += debugfs.o debugfs_htt_stats.o debugfs_sta.o debug_nss.o debug_smart_ant.o
 ath11k-$(CPTCFG_NL80211_TESTMODE) += testmode.o
 ath11k-$(CPTCFG_ATH11K_TRACING) += trace.o
-ath11k-$(CPTCFG_ATH11K_THERMAL) += thermal.o
+ath11k-$(CONFIG_THERMAL) += thermal.o
 ath11k-$(CONFIG_WANT_DEV_COREDUMP) += coredump.o
 ath11k-$(CPTCFG_ATH11K_SPECTRAL) += spectral.o
 ath11k-$(CONFIG_PM) += wow.o
--- a/drivers/net/wireless/ath/ath11k/ahb.c
+++ b/drivers/net/wireless/ath/ath11k/ahb.c
@@ -1128,7 +1128,7 @@ static int ath11k_ahb_fw_resources_init(
 
 	ret = iommu_map(iommu_dom, ab_ahb->fw.msa_paddr,
 			ab_ahb->fw.msa_paddr, ab_ahb->fw.msa_size,
-			IOMMU_READ | IOMMU_WRITE, GFP_KERNEL);
+			IOMMU_READ | IOMMU_WRITE);
 	if (ret) {
 		ath11k_err(ab, "failed to map firmware region: %d\n", ret);
 		goto err_iommu_detach;
@@ -1136,7 +1136,7 @@ static int ath11k_ahb_fw_resources_init(
 
 	ret = iommu_map(iommu_dom, ab_ahb->fw.ce_paddr,
 			ab_ahb->fw.ce_paddr, ab_ahb->fw.ce_size,
-			IOMMU_READ | IOMMU_WRITE, GFP_KERNEL);
+			IOMMU_READ | IOMMU_WRITE);
 	if (ret) {
 		ath11k_err(ab, "failed to map firmware CE region: %d\n", ret);
 		goto err_iommu_unmap;
--- a/drivers/net/wireless/ath/ath11k/ce.c
+++ b/drivers/net/wireless/ath/ath11k/ce.c
@@ -1039,8 +1039,6 @@ void ath11k_ce_rx_post_buf(struct ath11k
 			if (ret == -ENOSPC)
 				continue;
 
-			ath11k_warn(ab, "failed to post rx buf to pipe: %d err: %d\n",
-				    i, ret);
 			mod_timer(&ab->rx_replenish_retry,
 				  jiffies + ATH11K_CE_RX_POST_RETRY_JIFFIES);
 
--- a/drivers/net/wireless/ath/ath11k/core.c
+++ b/drivers/net/wireless/ath/ath11k/core.c
@@ -131,6 +131,7 @@ static struct ath11k_hw_params ath11k_hw
 			.max_fft_bins = 512,
 			.fragment_160mhz = true,
 		},
+		.num_dscp_tid_map_tbl = HAL_DSCP_TID_MAP_TBL_NUM_ENTRIES_MAX,
 
 		.interface_modes = BIT(NL80211_IFTYPE_STATION) |
 					BIT(NL80211_IFTYPE_AP) |
@@ -332,6 +333,7 @@ static struct ath11k_hw_params ath11k_hw
 		.num_peers = 512,
 		.supports_suspend = true,
 		.hal_desc_sz = sizeof(struct hal_rx_desc_ipq8074),
+		.reo_dest_ring_map_shift = HAL_REO_DEST_RING_CTRL_HASH_RING_SHIFT,
 		.supports_regdb = false,
 		.fix_l1ss = true,
 		.credit_flow = true,
@@ -395,6 +397,7 @@ static struct ath11k_hw_params ath11k_hw
 		.rx_mac_buf_ring = false,
 		.vdev_start_delay = false,
 		.htt_peer_map_v2 = true,
+		.num_dscp_tid_map_tbl = HAL_DSCP_TID_MAP_TBL_NUM_ENTRIES_MAX,
 
 		.spectral = {
 			.fft_sz = 2,
@@ -497,6 +500,7 @@ static struct ath11k_hw_params ath11k_hw
 		.rx_mac_buf_ring = true,
 		.vdev_start_delay = true,
 		.htt_peer_map_v2 = false,
+		.num_dscp_tid_map_tbl = HAL_DSCP_TID_MAP_TBL_NUM_ENTRIES_MAX,
 
 		.spectral = {
 			.fft_sz = 0,
@@ -673,6 +677,7 @@ static struct ath11k_hw_params ath11k_hw
 		.rx_mac_buf_ring = true,
 		.vdev_start_delay = true,
 		.htt_peer_map_v2 = false,
+		.num_dscp_tid_map_tbl = HAL_DSCP_TID_MAP_TBL_NUM_ENTRIES_MAX,
 
 		.spectral = {
 			.fft_sz = 0,
@@ -933,6 +938,7 @@ static struct ath11k_hw_params ath11k_hw
 		.ring_mask = &ath11k_hw_ring_mask_ipq8074,
 		.internal_sleep_clock = false,
 		.regs = &ipq8074_regs,
+		.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,
 		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_IPQ8074,
 		.host_ce_config = ath11k_host_ce_config_ipq9574,
 		.supports_regdb = true,
--- a/drivers/net/wireless/ath/ath11k/core.h
+++ b/drivers/net/wireless/ath/ath11k/core.h
@@ -93,6 +93,7 @@ extern bool ath11k_ftm_mode;
 #define MAX_SOCS	3
 
 #define ATH11K_AHB_PROBE_SEQ_TIMEOUT   (2 * HZ)
+#define HAL_REO_DEST_RING_CTRL_HASH_RING_SHIFT                  8
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
 #define ATH11K_SSR_POWERUP SUBSYS_AFTER_POWERUP
@@ -433,7 +434,7 @@ struct chan_power_info {
 struct ath11k_reg_tpc_power_info {
 	bool is_psd_power;
 	u8 eirp_power;
-	enum wmi_reg_6g_ap_type power_type_6g;
+	enum wmi_reg_6ghz_ap_type power_type_6g;
 	u8 num_pwr_levels;
 	u8 reg_max[IEEE80211_MAX_NUM_PWR_LEVEL];
 	u8 ap_constraint_power;
@@ -1082,6 +1083,8 @@ struct ath11k {
 	u32 chan_bw_interference_bitmap;
 	bool awgn_intf_handling_in_prog;
 	s8 max_allowed_tx_power;
+	struct cfg80211_chan_def agile_chandef;
+	struct list_head fw_stats_pdevs;
 };
 
 struct ath11k_band_cap {
@@ -1418,6 +1421,7 @@ struct ath11k_base {
 	struct list_head wmi_ast_list;
 	struct completion pm_restart;
 	bool pm_suspend;
+	bool ce_latency_stats_enable;
 
 	/* must be last */
 	u8 drv_priv[] __aligned(sizeof(void *));
--- a/drivers/net/wireless/ath/ath11k/debug.h
+++ b/drivers/net/wireless/ath/ath11k/debug.h
@@ -70,6 +70,16 @@ static inline const char *ath11k_dbg_str
 		return "dp_rx";
 	case ATH11K_DBG_CE:
 		return "ce";
+	case ATH11K_DBG_CFR:
+		return "cfr";
+	case ATH11K_DBG_CFR_DUMP:
+		return "cfr_dump";
+	case ATH11K_DBG_PEER:
+		return "peer";
+	case ATH11K_DBG_TEST:
+		return "test";
+	case ATH11K_DBG_SMART_ANT:
+		return "antenna";
 
 	/* no default handler to allow compiler to check that the
 	 * enum is fully handled
--- a/drivers/net/wireless/ath/ath11k/debugfs.c
+++ b/drivers/net/wireless/ath/ath11k/debugfs.c
@@ -2044,6 +2044,8 @@ int ath11k_debugfs_soc_create(struct ath
 		ret = PTR_ERR(ab->debugfs_soc);
 		goto out;
 	}
+	debugfs_create_file("stats_disable", 0600, ab->debugfs_soc, ab,
+			    &fops_soc_stats_disable);
 
 	ret = 0;
 
@@ -2076,9 +2078,6 @@ int ath11k_debugfs_create()
 		return -ENOMEM;
 	}
 
-	debugfs_create_file("stats_disable", 0600, ab->debugfs_soc, ab,
-			    &fops_soc_stats_disable);
-
 	return 0;
 }
 
--- a/drivers/net/wireless/ath/ath11k/dp.c
+++ b/drivers/net/wireless/ath/ath11k/dp.c
@@ -464,7 +464,6 @@ static int ath11k_dp_srng_common_setup(s
 	struct ath11k_dp *dp = &ab->dp;
 	struct hal_srng *srng;
 	int i, ret, j;
-	u8 tcl_num, wbm_num;
 
 	ath11k_dp_init_reo_status_timer(ab);
 
@@ -497,45 +496,41 @@ static int ath11k_dp_srng_common_setup(s
 	}
 
 	for (i = 0; i < DP_TCL_NUM_RING_MAX; i++) {
-		tcl_num = ab->hw_params.hal_params->tcl2wbm_rbm_map[i].tcl_ring_num;
-		wbm_num = ab->hw_params.hal_params->tcl2wbm_rbm_map[i].wbm_ring_num;
-
 		ret = ath11k_dp_srng_setup(ab, &dp->tx_ring[i].tcl_data_ring,
-					   HAL_TCL_DATA, tcl_num, 0,
-					   ab->hw_params.tx_ring_size);
-		if (ret) {
-			ath11k_warn(ab, "failed to set up tcl_data ring (%d) :%d\n",
-				    i, ret);
-			goto err;
-		}
-
-		ret = ath11k_dp_srng_setup(ab, &dp->tx_ring[i].tcl_comp_ring,
-					   HAL_WBM2SW_RELEASE, wbm_num, 0,
-					   DP_TX_COMP_RING_SIZE);
-		if (ret) {
-			ath11k_warn(ab, "failed to set up tcl_comp ring (%d) :%d\n",
-				    i, ret);
-			goto err;
-		}
-
-		srng = &ab->hal.srng_list[dp->tx_ring[i].tcl_data_ring.ring_id];
-		ath11k_hal_tx_init_data_ring(ab, srng, HAL_TCL_DATA);
+					   HAL_TCL_DATA, i, 0,
+					   DP_TCL_DATA_RING_SIZE);
+                if (ret) {
+                        ath11k_warn(ab, "failed to set up tcl_data ring (%d) :%d\n",
+                                    i, ret);
+                        goto err;
+                }
+
+                ret = ath11k_dp_srng_setup(ab, &dp->tx_ring[i].tcl_comp_ring,
+                                           HAL_WBM2SW_RELEASE, i, 0,
+                                           DP_TX_COMP_RING_SIZE);
+                if (ret) {
+                        ath11k_warn(ab, "failed to set up tcl_comp ring (%d) :%d\n",
+                                    i, ret);
+                        goto err;
+                }
+
+                srng = &ab->hal.srng_list[dp->tx_ring[i].tcl_data_ring.ring_id];
+                ath11k_hal_tx_init_data_ring(ab, srng, HAL_TCL_DATA);
+
+                ath11k_dp_shadow_init_timer(ab, &dp->tx_ring_timer[i],
+                                            ATH11K_SHADOW_DP_TIMER_INTERVAL,
+                                            dp->tx_ring[i].tcl_data_ring.ring_id);
+
+                dp->tx_ring[i].idr_pool = kcalloc(DP_TX_IDR_SIZE,
+                                                  sizeof(struct idr_entry), GFP_KERNEL);
+                if (!dp->tx_ring[i].idr_pool) {
+                        ath11k_warn(ab, "failed to allocate memory for idr pool ring(%d)\n", i);
+                        ret = -ENOMEM;
+                        goto err;
+                }
 
-		ath11k_dp_shadow_init_timer(ab, &dp->tx_ring_timer[i],
-					    ATH11K_SHADOW_DP_TIMER_INTERVAL,
-					    dp->tx_ring[i].tcl_data_ring.ring_id);
-
-		dp->tx_ring[i].idr_pool = kcalloc(DP_TX_IDR_SIZE,
-						  sizeof(struct idr_entry), GFP_KERNEL);
-		if (!dp->tx_ring[i].idr_pool) {
-			ath11k_warn(ab, "failed to allocate memory for idr pool ring(%d)\n", i);
-			ret = -ENOMEM;
-			goto err;
-		}
-
-		/* Reset id to default */
 		for (j = 0; j < DP_TX_IDR_SIZE; j++)
-			dp->tx_ring[i].idr_pool[j].id = -1;
+                        dp->tx_ring[i].idr_pool[j].id = -1;
 	}
 
 	ret = ath11k_dp_srng_setup(ab, &dp->reo_reinject_ring, HAL_REO_REINJECT,
@@ -895,10 +890,11 @@ int ath11k_dp_service_srng(struct ath11k
 	int tot_work_done = 0;
 	bool nss_offload;
 
-	for (i = 0; i < ab->hw_params.max_tx_ring; i++) {
-		if (!nss_offload && (BIT(ab->hw_params.hal_params->tcl2wbm_rbm_map[i].wbm_ring_num) &
-		    ab->hw_params.ring_mask->tx[grp_id]))
-			ath11k_dp_tx_completion_handler(ab, i);
+	nss_offload = ab->nss.enabled;
+
+	if (!nss_offload && ab->hw_params.ring_mask->tx[grp_id]) {
+		i = __fls(ab->hw_params.ring_mask->tx[grp_id]);
+		ath11k_dp_tx_completion_handler(ab, i);
 	}
 
 	if (!nss_offload && ab->hw_params.ring_mask->rx_err[grp_id]) {
@@ -1228,7 +1224,7 @@ int ath11k_dp_alloc(struct ath11k_base *
 		ATH11K_MEMORY_STATS_INC(ab, malloc_size, size);
 	}
 
-	for (i = 0; i < HAL_DSCP_TID_MAP_TBL_NUM_ENTRIES_MAX; i++)
+	for (i = 0; i < ab->hw_params.num_dscp_tid_map_tbl; i++)
 		ath11k_hal_tx_set_dscp_tid_map(ab, i);
 
 	/* Init any SOC level resource for DP */
--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
+++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
@@ -258,7 +258,7 @@ int ath11k_dp_tx(struct ath11k *ar, stru
 		return -ENOSPC;
 	}
 #endif
-	ring_selector = ab->hw_params.hw_ops->get_ring_selector(skb);
+	ring_selector = smp_processor_id();;
 	pool_id = ring_selector;
 
 tcl_ring_sel:
@@ -268,7 +268,6 @@ tcl_ring_sel:
 	tcl_ring_id = (ring_id == DP_TCL_NUM_RING_MAX) ?
 				  DP_TCL_NUM_RING_MAX - 1 : ring_id;
 
-	ti.rbm_id = ab->hw_params.hal_params->tcl2wbm_rbm_map[ti.ring_id].rbm_id;
 
 	ring_map |= BIT(ring_id);
 
@@ -469,11 +468,10 @@ fail_unmap_dma:
 	dma_unmap_single(ab->dev, ti.paddr, ti.data_len, DMA_TO_DEVICE);
 
 fail_remove_idr:
-	if (ti.pkt_offset)
-		skb_pull(skb, ti.pkt_offset);
-
-	tx_ring->idr_pool[idr].id = -1;
-	clear_bit(idr, tx_ring->idrs);
+	spin_lock_bh(&tx_ring->tx_idr_lock);
+        idr_remove(&tx_ring->txbuf_idr,
+                   FIELD_GET(DP_TX_DESC_ID_MSDU_ID, ti.desc_id));
+        spin_unlock_bh(&tx_ring->tx_idr_lock);
 
 	if (tcl_ring_retry)
 		goto tcl_ring_sel;
--- a/drivers/net/wireless/ath/ath11k/hal.c
+++ b/drivers/net/wireless/ath/ath11k/hal.c
@@ -1037,6 +1037,7 @@ int ath11k_hal_srng_setup(struct ath11k_
 	u32 lmac_idx;
 	int i;
 	u32 reg_base;
+	unsigned long *mem;
 
 	ring_id = ath11k_hal_srng_get_ring_id(ab, type, ring_num, mac_id);
 	if (ring_id < 0)
@@ -1066,6 +1067,8 @@ int ath11k_hal_srng_setup(struct ath11k_
 				      (ring_num * srng_config->reg_size[i]);
 	}
 
+	mem = ab->mem;
+
 	memset(srng->ring_base_vaddr, 0,
 	       (srng->entry_size * srng->num_entries) << 2);
 
--- a/drivers/net/wireless/ath/ath11k/hal.h
+++ b/drivers/net/wireless/ath/ath11k/hal.h
@@ -28,6 +28,7 @@ struct ath11k_base;
 #define HAL_WBM_IDLE_SCATTER_BUF_SIZE (HAL_WBM_IDLE_SCATTER_BUF_SIZE_MAX - \
 				       HAL_WBM_IDLE_SCATTER_NEXT_PTR_SIZE)
 
+#define HAL_IPQ5018_DSCP_TID_MAP_TBL_NUM_ENTRIES_MAX	32
 #define HAL_DSCP_TID_MAP_TBL_NUM_ENTRIES_MAX	48
 #define HAL_DSCP_TID_TBL_SIZE			24
 
@@ -121,6 +122,7 @@ struct ath11k_base;
 #define HAL_REO1_DEST_RING_CTRL_IX_1		0x00000008
 #define HAL_REO1_DEST_RING_CTRL_IX_2		0x0000000c
 #define HAL_REO1_DEST_RING_CTRL_IX_3		0x00000010
+#define HAL_REO1_R0_MISC_CTL                   0x000005d8
 #define HAL_REO1_MISC_CTL(ab)			ab->hw_params.regs->hal_reo1_misc_ctl
 #define HAL_REO1_RING_BASE_LSB(ab)		ab->hw_params.regs->hal_reo1_ring_base_lsb
 #define HAL_REO1_RING_BASE_MSB(ab)		ab->hw_params.regs->hal_reo1_ring_base_msb
@@ -285,6 +287,7 @@ struct ath11k_base;
 #define HAL_REO1_GEN_ENABLE_AGING_LIST_ENABLE		BIT(2)
 #define HAL_REO1_GEN_ENABLE_AGING_FLUSH_ENABLE		BIT(3)
 #define HAL_REO1_MISC_CTL_FRAGMENT_DST_RING		GENMASK(20, 17)
+#define HAL_IPQ5018_REO1_MISC_CTL_FRAGMENT_DEST_RING		GENMASK(19, 17)
 
 /* CE ring bit field mask and shift */
 #define HAL_CE_DST_R0_DEST_CTRL_MAX_LEN			GENMASK(15, 0)
--- a/drivers/net/wireless/ath/ath11k/hal_rx.h
+++ b/drivers/net/wireless/ath/ath11k/hal_rx.h
@@ -464,12 +464,13 @@ struct hal_rx_phyrx_rssi_legacy_info {
 #define HAL_RX_MPDU_INFO_INFO0_PEERID	GENMASK(31, 16)
 #define HAL_RX_MPDU_INFO_INFO0_PEERID_WCN6855	GENMASK(15, 0)
 #define HAL_RX_MPDU_INFO_INFO1_MPDU_LEN		GENMASK(13, 0)
+#define HAL_RX_MPDU_INFO_INFO0_PPDU_ID          GENMASK(31, 16)
 
 struct hal_rx_mpdu_info_ipq8074 {
-	__le32 rsvd0;
 	__le32 info0;
-	__le32 rsvd1[11];
 	__le32 info1;
+	__le32 rsvd1[11];
+	__le32 info2;
 	__le32 rsvd2[9];
 } __packed;
 
--- a/drivers/net/wireless/ath/ath11k/hal_tx.c
+++ b/drivers/net/wireless/ath/ath11k/hal_tx.c
@@ -45,7 +45,7 @@ void ath11k_hal_tx_cmd_desc_setup(struct
 		FIELD_PREP(BUFFER_ADDR_INFO1_ADDR,
 			   ((uint64_t)ti->paddr >> HAL_ADDR_MSB_REG_SHIFT));
 	tcl_cmd.buf_addr_info.info1 |=
-		FIELD_PREP(BUFFER_ADDR_INFO1_RET_BUF_MGR, ti->rbm_id) |
+		FIELD_PREP(BUFFER_ADDR_INFO1_RET_BUF_MGR, ti->buf_id) |
 		FIELD_PREP(BUFFER_ADDR_INFO1_SW_COOKIE, ti->desc_id);
 
 	tcl_cmd.info0 =
--- a/drivers/net/wireless/ath/ath11k/hal_tx.h
+++ b/drivers/net/wireless/ath/ath11k/hal_tx.h
@@ -36,7 +36,6 @@ struct hal_tx_info {
 	u8 lmac_id;
 	u8 dscp_tid_tbl_idx;
 	bool enable_mesh;
-	u8 rbm_id;
 };
 
 /* TODO: Check if the actual desc macros can be used instead */
--- a/drivers/net/wireless/ath/ath11k/hw.c
+++ b/drivers/net/wireless/ath/ath11k/hw.c
@@ -439,6 +439,50 @@ struct rx_attention *ath11k_hw_ipq8074_r
 	return &desc->u.ipq8074.attention;
 }
 
+static void ath11k_hw_ipq8074_set_rx_fragmentation_dst_ring(struct ath11k_base *ab)
+{
+	u8 frag_dst_ring = HAL_SRNG_RING_ID_REO2SW1;
+	u32 reo_base = HAL_SEQ_WCSS_UMAC_REO_REG;
+	u32 val;
+
+	if (ab->nss.enabled)
+		frag_dst_ring = HAL_SRNG_REO_ALTERNATE_SELECT;
+
+	val = ath11k_hif_read32(ab, reo_base + HAL_REO1_GEN_ENABLE);
+
+	val &= ~HAL_REO1_GEN_ENABLE_FRAG_DST_RING;
+	val |= FIELD_PREP(HAL_REO1_GEN_ENABLE_FRAG_DST_RING,
+			  frag_dst_ring) |
+	       FIELD_PREP(HAL_REO1_GEN_ENABLE_AGING_LIST_ENABLE, 1) |
+	       FIELD_PREP(HAL_REO1_GEN_ENABLE_AGING_FLUSH_ENABLE, 1);
+	ath11k_hif_write32(ab, reo_base + HAL_REO1_GEN_ENABLE, val);
+}
+
+static void ath11k_hw_wcn6855_set_rx_fragmentation_dst_ring(struct ath11k_base *ab)
+{
+	u8 frag_dst_ring = HAL_SRNG_RING_ID_REO2SW1;
+	u32 reo_base = HAL_SEQ_WCSS_UMAC_REO_REG;
+	u32 val;
+
+	if (ab->nss.enabled)
+		frag_dst_ring = HAL_SRNG_REO_ALTERNATE_SELECT;
+
+	val = ath11k_hif_read32(ab, reo_base + HAL_REO1_GEN_ENABLE);
+
+	val &= ~HAL_REO1_GEN_ENABLE_FRAG_DST_RING;
+	val |= FIELD_PREP(HAL_REO1_GEN_ENABLE_FRAG_DST_RING,
+			  frag_dst_ring) |
+	       FIELD_PREP(HAL_REO1_GEN_ENABLE_AGING_LIST_ENABLE, 1) |
+	       FIELD_PREP(HAL_REO1_GEN_ENABLE_AGING_FLUSH_ENABLE, 1);
+	ath11k_hif_write32(ab, reo_base + HAL_REO1_GEN_ENABLE, val);
+
+	val = ath11k_hif_read32(ab, reo_base + HAL_REO1_MISC_CTL(ab));
+	val &= ~HAL_REO1_MISC_CTL_FRAGMENT_DST_RING;
+	val |= FIELD_PREP(HAL_REO1_MISC_CTL_FRAGMENT_DST_RING, frag_dst_ring);
+	ath11k_hif_write32(ab, reo_base + HAL_REO1_MISC_CTL(ab), val);
+
+}
+
 static u8 *ath11k_hw_ipq8074_rx_desc_get_msdu_payload(struct hal_rx_desc *desc)
 {
 	return &desc->u.ipq8074.msdu_payload[0];
@@ -929,9 +973,7 @@ static u8 *ath11k_hw_wcn6855_rx_desc_mpd
 
 static void ath11k_hw_wcn6855_reo_setup(struct ath11k_base *ab)
 {
-	u8 frag_dest_ring = HAL_SRNG_RING_ID_REO2SW1;
 	u32 reo_base = HAL_SEQ_WCSS_UMAC_REO_REG;
-	u32 val;
 
 	/* Each hash entry uses four bits to map to a particular ring. */
 	u32 ring_hash_map = HAL_HASH_ROUTING_RING_SW1 << 0 |
@@ -943,18 +985,8 @@ static void ath11k_hw_wcn6855_reo_setup(
 		HAL_HASH_ROUTING_RING_SW3 << 24 |
 		HAL_HASH_ROUTING_RING_SW4 << 28;
 
-	if (ab->nss.enabled)
-		frag_dest_ring = HAL_SRNG_REO_ALTERNATE_SELECT;
-
-	val = ath11k_hif_read32(ab, reo_base + HAL_REO1_GEN_ENABLE);
-	val |= FIELD_PREP(HAL_REO1_GEN_ENABLE_AGING_LIST_ENABLE, 1) |
-		FIELD_PREP(HAL_REO1_GEN_ENABLE_AGING_FLUSH_ENABLE, 1);
-	ath11k_hif_write32(ab, reo_base + HAL_REO1_GEN_ENABLE, val);
-
-	val = ath11k_hif_read32(ab, reo_base + HAL_REO1_MISC_CTL(ab));
-	val &= ~HAL_REO1_MISC_CTL_FRAGMENT_DST_RING;
-	val |= FIELD_PREP(HAL_REO1_MISC_CTL_FRAGMENT_DST_RING, frag_dest_ring);
-	ath11k_hif_write32(ab, reo_base + HAL_REO1_MISC_CTL(ab), val);
+	u8 reo_dest_hash_shift = ab->hw_params.reo_dest_ring_map_shift;
+	ab->hw_params.hw_ops->set_rx_fragmentation_dst_ring(ab);
 
 	ath11k_hif_write32(ab, reo_base + HAL_REO1_AGING_THRESH_IX_0(ab),
 			   HAL_DEFAULT_REO_TIMEOUT_USEC);
@@ -969,7 +1001,10 @@ static void ath11k_hw_wcn6855_reo_setup(
 	if (ab->nss.enabled)
 		return;
 
-	ath11k_hal_reo_hash_setup(ab, ring_hash_map);
+	ath11k_hif_write32(ab, reo_base + HAL_REO1_DEST_RING_CTRL_IX_2,
+			   ring_hash_map << reo_dest_hash_shift);
+	ath11k_hif_write32(ab, reo_base + HAL_REO1_DEST_RING_CTRL_IX_3,
+			   ring_hash_map << reo_dest_hash_shift);
 }
 
 static void ath11k_hw_ipq5018_reo_setup(struct ath11k_base *ab)
@@ -1014,7 +1049,7 @@ ath11k_hw_ipq8074_rx_desc_get_hal_mpdu_p
 		(struct hal_rx_mpdu_info *)tlv_data;
 
 	return FIELD_GET(HAL_RX_MPDU_INFO_INFO0_PPDU_ID,
-			 __le32_to_cpu(u.ipq8074.info0));
+			 __le32_to_cpu(mpdu_info->u.ipq8074.info0));
 }
 
 static
@@ -1091,13 +1126,13 @@ static u32 ath11k_hw_wcn6750_get_tcl_rin
 static u32 ath11k_hw_ipq8074_rx_desc_get_hal_mpdu_len(struct hal_rx_mpdu_info *mpdu_info)
 {
 	return FIELD_GET(HAL_RX_MPDU_INFO_INFO1_MPDU_LEN,
-			 __le32_to_cpu(mpdu_info->u.ipq8074.info1));
+			 __le32_to_cpu(mpdu_info->u.ipq8074.info2));
 }
 
 static u32 ath11k_hw_qcn9074_rx_desc_get_hal_mpdu_len(struct hal_rx_mpdu_info *mpdu_info)
 {
 	return FIELD_GET(HAL_RX_MPDU_INFO_INFO1_MPDU_LEN,
-			 __le32_to_cpu(mpdu_info->u.qcn9074.info1));
+			 __le32_to_cpu(mpdu_info->u.qcn9074.info0));
 }
 
 #ifdef CPTCFG_ATH11K_MEM_PROFILE_512M
@@ -1333,6 +1368,70 @@ void ath11k_hw_qcn6122_fill_cfr_hdr_info
 	       sizeof(params->chain_phase));
 }
 
+static void ath11k_hw_ipq5018_set_rx_fragmentation_dst_ring(struct ath11k_base *ab)
+{
+	u8 frag_dst_ring = HAL_SRNG_RING_ID_REO2SW1;
+	u32 reo_base = HAL_SEQ_WCSS_UMAC_REO_REG;
+	u32 val;
+
+	if (ab->nss.enabled)
+		frag_dst_ring = HAL_SRNG_REO_ALTERNATE_SELECT;
+
+	val = ath11k_hif_read32(ab, reo_base + HAL_REO1_GEN_ENABLE);
+
+	val &= ~HAL_REO1_GEN_ENABLE_FRAG_DST_RING;
+	val |= FIELD_PREP(HAL_REO1_GEN_ENABLE_AGING_LIST_ENABLE, 1) |
+	       FIELD_PREP(HAL_REO1_GEN_ENABLE_AGING_FLUSH_ENABLE, 1);
+	ath11k_hif_write32(ab, reo_base + HAL_REO1_GEN_ENABLE, val);
+
+	val = ath11k_hif_read32(ab, reo_base + HAL_REO1_R0_MISC_CTL);
+	val &= ~HAL_IPQ5018_REO1_MISC_CTL_FRAGMENT_DEST_RING;
+	val |= FIELD_PREP(HAL_IPQ5018_REO1_MISC_CTL_FRAGMENT_DEST_RING,
+			  frag_dst_ring);
+	ath11k_hif_write32(ab, reo_base + HAL_REO1_R0_MISC_CTL, val);
+}
+
+static u32 ath11k_get_reo_dest_remap_config_default(void)
+{
+	u32 ring_hash_map;
+
+	/* For IPQ8074, IPQ6018, QCN9074, the first 8 bits are
+	 * are reserved/not used and the remainig 24 bits are
+	 * mapped for 8 hash values with 3 bits representing the
+	 * destination ring
+	 */
+	ring_hash_map = HAL_HASH_ROUTING_RING_SW1 << 0 |
+			HAL_HASH_ROUTING_RING_SW2 << 3 |
+			HAL_HASH_ROUTING_RING_SW3 << 6 |
+			HAL_HASH_ROUTING_RING_SW4 << 9 |
+			HAL_HASH_ROUTING_RING_SW1 << 12 |
+			HAL_HASH_ROUTING_RING_SW2 << 15 |
+			HAL_HASH_ROUTING_RING_SW3 << 18 |
+			HAL_HASH_ROUTING_RING_SW4 << 21;
+
+	return ring_hash_map;
+}
+
+static u32 ath11k_get_reo_dest_remap_config_5018(void)
+{
+	u32 ring_hash_map;
+
+	/* For IPQ5018 4 bits x 8 hash values represent the corresponding
+	 * destination rings. The 4th bit for each ring representation is
+	 * currently reserved/not used.
+	 */
+	ring_hash_map = HAL_HASH_ROUTING_RING_SW1 << 0 |
+			HAL_HASH_ROUTING_RING_SW2 << 4 |
+			HAL_HASH_ROUTING_RING_SW3 << 8 |
+			HAL_HASH_ROUTING_RING_SW4 << 12 |
+			HAL_HASH_ROUTING_RING_SW1 << 16 |
+			HAL_HASH_ROUTING_RING_SW2 << 20 |
+			HAL_HASH_ROUTING_RING_SW3 << 24 |
+			HAL_HASH_ROUTING_RING_SW4 << 28;
+
+	return ring_hash_map;
+}
+
 const struct ath11k_hw_ops ipq8074_ops = {
 	.get_hw_mac_from_pdev_id = ath11k_hw_ipq8074_mac_from_pdev_id,
 	.wmi_init_config = ath11k_init_wmi_config_ipq8074,
@@ -1566,6 +1665,7 @@ const struct ath11k_hw_ops wcn6855_ops =
 	.rx_desc_get_crypto_header = ath11k_hw_ipq8074_rx_desc_get_crypto_hdr,
 	.fill_cfr_hdr_info = ath11k_hw_ipq8074_fill_cfr_hdr_info,
 	.rx_desc_get_hal_ppdu_id = ath11k_hw_ipq8074_rx_desc_get_hal_mpdu_ppdu_id,
+	.set_rx_fragmentation_dst_ring = ath11k_hw_wcn6855_set_rx_fragmentation_dst_ring,
 };
 
 const struct ath11k_hw_ops wcn6750_ops = {
@@ -3327,6 +3427,10 @@ const struct ath11k_hw_regs qcn9074_regs
 	.hal_reo_cmd_ring_base_lsb = 0x00000194,
 	.hal_reo_cmd_ring_hp = 0x00003020,
 
+	/* SW2REO ring address */
+	.hal_sw2reo_ring_base_lsb = 0x000001ec,
+	.hal_sw2reo_ring_hp = 0x00003028,
+
 	/* REO status address */
 	.hal_reo_status_ring_base_lsb = 0x00000504,
 	.hal_reo_status_hp = 0x00003070,
--- a/drivers/net/wireless/ath/ath11k/hw.h
+++ b/drivers/net/wireless/ath/ath11k/hw.h
@@ -205,6 +205,7 @@ struct ath11k_hw_params {
 	bool rx_mac_buf_ring;
 	bool vdev_start_delay;
 	bool htt_peer_map_v2;
+	u8 num_dscp_tid_map_tbl;
 
 	struct {
 		u8 fft_sz;
@@ -238,6 +239,7 @@ struct ath11k_hw_params {
 	bool supports_dynamic_smps_6ghz;
 	bool alloc_cacheable_memory;
 	u32 m3_addr;
+	u8 reo_dest_ring_map_shift;
 	bool supports_rssi_stats;
 	bool fw_wmi_diag_event;
 	bool current_cc_support;
@@ -326,6 +328,9 @@ struct ath11k_hw_ops {
 	bool (*rx_desc_mac_addr2_valid)(struct hal_rx_desc *desc);
 	u8* (*rx_desc_mpdu_start_addr2)(struct hal_rx_desc *desc);
 	u32 (*get_ring_selector)(struct sk_buff *skb);
+	u32 (*rx_desc_get_hal_mpdu_len) (struct hal_rx_mpdu_info *mpdu_info);
+	void (*set_rx_fragmentation_dst_ring)(struct ath11k_base *ab);
+	u32 (*get_reo_dest_remap_config)(void);
 #ifdef CPTCFG_ATH11K_MEM_PROFILE_512M
 	void (*rx_desc_get_offset)(struct htt_rx_ring_tlv_filter *tlv_filter);
 #endif
--- a/drivers/net/wireless/ath/ath11k/mac.c
+++ b/drivers/net/wireless/ath/ath11k/mac.c
@@ -1485,7 +1485,6 @@ static int ath11k_mac_op_config(struct i
 	struct ath11k *ar = hw->priv;
 	struct ieee80211_conf *conf = &hw->conf;
 	int ret = 0;
-	struct vdev_up_params params = { 0 };
 
 	mutex_lock(&ar->conf_mutex);
 
@@ -1621,80 +1620,6 @@ static bool ath11k_mac_set_nontx_vif_par
 	return false;
 }
 
-static bool ath11k_mac_setup_bcn_tmpl_nontx_vif_params(struct ath11k_vif *tx_arvif,
-						       struct ath11k_vif *arvif,
-						       struct sk_buff *bcn)
-{
-	struct ieee80211_mgmt *mgmt;
-	const u8 *ies, *profile, *next_profile;
-	int ies_len;
-
-	if (arvif == tx_arvif)
-		return true;
-
-	arvif->rsnie_present = tx_arvif->rsnie_present;
-
-	ies = bcn->data + ieee80211_get_hdrlen_from_skb(bcn);
-	ies += sizeof(mgmt->u.beacon);
-	ies_len = skb_tail_pointer(bcn) - ies;
-
-	ies = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ies, ies_len);
-
-	while (ies) {
-		u8 mbssid_len;
-
-		ies_len -= (2 + ies[1]);
-		mbssid_len = ies[1] - 1;
-		profile = &ies[3];
-
-		while (mbssid_len) {
-			u8 profile_len, nie_len, *nie;
-
-			profile_len = profile[1];
-			next_profile = profile + (2 + profile_len);
-			mbssid_len -= (2 + profile_len);
-
-			profile += 2;
-			profile_len -= (2 + profile[1]);
-			profile += (2 + profile[1]); /* nontx capabilities */
-			profile_len -= (2 + profile[1]);
-			profile += (2 + profile[1]); /* SSID */
-			if (profile[2] == arvif->vif->bss_conf.bssid_index) {
-				profile_len -= 5;
-				profile = profile + 5;
-
-				if (cfg80211_find_ie(WLAN_EID_RSN, profile,
-						     profile_len))
-					arvif->rsnie_present = true;
-				else if (tx_arvif->rsnie_present) {
-					nie = cfg80211_find_ext_ie(WLAN_EID_EXT_NON_INHERITANCE,
-								   profile,
-								   profile_len);
-					if (nie) {
-						int i;
-
-						nie_len = nie[1];
-						nie += 2;
-						for (i = 0; i < nie_len; i++) {
-							if (nie[i] ==
-								WLAN_EID_RSN) {
-								arvif->rsnie_present = false;
-								break;
-							}
-						}
-					}
-				}
-				return true;
-			}
-			profile = next_profile;
-		}
-		ies = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, profile,
-				       ies_len);
-	}
-
-	return false;
-}
-
 static int __ath11k_mac_setup_bcn_tmpl(struct ath11k_vif *arvif,
 				       struct sk_buff *bcn,
 				       struct ieee80211_mutable_offsets offs,
@@ -1762,6 +1687,7 @@ static int ath11k_mac_setup_bcn_tmpl_ema
 	struct ieee80211_ema_beacons *beacons;
 	int ret = 0;
 	u8 i = 0;
+	bool found_vdev = false;
 
 	if (!arvif->vif->bss_conf.mbssid_tx_vif)
 		return -1;
@@ -1782,13 +1708,14 @@ static int ath11k_mac_setup_bcn_tmpl_ema
 	} else {
 		arvif->vht_cap = tx_arvif->vht_cap;
 		arvif->wpaie_present = tx_arvif->wpaie_present;
+	}
 
 	for (i = 0; i < beacons->cnt; i++) {
 		if (found_vdev == false)
 			found_vdev =
-				ath11k_mac_setup_bcn_tmpl_nontx_vif_params(tx_arvif,
-									   arvif,
-									   beacons->bcn[i].skb);
+				ath11k_mac_set_nontx_vif_params(tx_arvif,
+								arvif,
+								beacons->bcn[i].skb);
 
 		ret = __ath11k_mac_setup_bcn_tmpl(tx_arvif, beacons->bcn[i].skb,
 						  beacons->bcn[i].offs,
@@ -1837,9 +1764,9 @@ static int ath11k_mac_setup_bcn_tmpl_mbs
 	if (tx_arvif == arvif)
 		ath11k_mac_set_vif_params(tx_arvif, bcn);
 	else
-		(void) ath11k_mac_setup_bcn_tmpl_nontx_vif_params(tx_arvif,
-								  arvif,
-								  bcn);
+		(void) ath11k_mac_set_nontx_vif_params(tx_arvif,
+							arvif,
+							bcn);
 	ret = __ath11k_mac_setup_bcn_tmpl(tx_arvif, bcn, offs, 0, 0);
 	kfree_skb(bcn);
 
@@ -1875,8 +1802,8 @@ static void ath11k_control_beaconing(str
 {
 	struct ath11k *ar = arvif->ar;
 	struct ath11k_vif *tx_arvif = NULL;
+	struct vdev_up_params params = { 0 };
 	int ret = 0;
-	bool found_vdev = false;
 
 	if (arvif->vif->bss_conf.mbssid_tx_vif)
 		tx_arvif = (void *)arvif->vif->bss_conf.mbssid_tx_vif->drv_priv;
@@ -3570,7 +3497,7 @@ static int ath11k_mac_fils_discovery(str
 	if (info->fils_discovery.max_interval) {
 		interval = info->fils_discovery.max_interval;
 
-		tmpl = ieee80211_get_fils_discovery_tmpl(ar->hw, arvif->vif);
+		tmpl = ieee80211_get_fils_discovery_tmpl(ar->hw, arvif->vif, 0);
 		if (tmpl)
 			ret = ath11k_wmi_fils_discovery_tmpl(ar, arvif->vdev_id,
 							     tmpl);
@@ -3579,7 +3506,7 @@ static int ath11k_mac_fils_discovery(str
 		interval = info->unsol_bcast_probe_resp_interval;
 
 		tmpl = ieee80211_get_unsol_bcast_probe_resp_tmpl(ar->hw,
-								 arvif->vif);
+								 arvif->vif, 0);
 		if (tmpl)
 			ret = ath11k_wmi_probe_resp_tmpl(ar, arvif->vdev_id,
 							 tmpl);
@@ -4960,7 +4887,6 @@ ath11k_mac_bitrate_mask_num_ht_rates(str
 {
 	int num_rates = 0;
 	int i;
-	u32 scan_timeout;
 
 	for (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++)
 		num_rates += hweight8(mask->control[band].ht_mcs[i]);
@@ -7713,6 +7639,11 @@ static void ath11k_mac_op_tx(struct ieee
 	int ret;
 	u64 adjusted_tsf;
 
+#ifdef CPTCFG_MAC80211_SFE_SUPPORT
+	 if (skb->fast_xmit)
+                info_flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;
+#endif
+
 	if (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
 		ieee80211_free_txskb(ar->hw, skb);
 		return;
@@ -7772,8 +7703,7 @@ static void ath11k_mac_op_tx(struct ieee
 		}
 		return;
 	}
-
-	if (control->sta)
+	if ( control && control->sta)
 		arsta = ath11k_sta_to_arsta(control->sta);
 
 	/* Must call mac80211 tx status handler, else when stats is disabled we free
@@ -8058,9 +7988,6 @@ static int ath11k_mac_op_start(struct ie
 		}
 	}
 
-	ath11k_debug_aggr_size_config_init(arvif);
-	ath11k_debugfs_wmi_ctrl_stats(arvif);
-
 	mutex_unlock(&ar->conf_mutex);
 
 	rcu_assign_pointer(ab->pdevs_active[ar->pdev_idx],
@@ -8742,6 +8669,9 @@ static int ath11k_mac_op_add_interface(s
 	if (ret)
 		ath11k_warn(ar->ab, "failed to set ap ps ret %d\n", ret);
 
+	ath11k_debug_aggr_size_config_init(arvif);
+        ath11k_debugfs_wmi_ctrl_stats(arvif);
+
 	/* Remove A-MPDU, A-MSDU aggr size files */
 	debugfs_remove(arvif->ampdu_aggr_size);
 	arvif->ampdu_aggr_size = NULL;
@@ -8756,6 +8686,14 @@ static int ath11k_mac_op_add_interface(s
 	if (arvif->vif->debugfs_dir)
 		ath11k_debugfs_per_arvif(arvif);
 
+	/* Remove the mac filter file */
+        debugfs_remove(arvif->mac_filter);
+        arvif->mac_filter = NULL;
+
+        /* Remove the wbm tx compl stats file */
+        debugfs_remove(arvif->wbm_tx_completion_stats);
+        arvif->wbm_tx_completion_stats = NULL;
+
 	mutex_unlock(&ar->conf_mutex);
 
 	return 0;
@@ -8932,7 +8870,7 @@ err_vdev_del:
 	/* TODO: recal traffic pause state based on the available vdevs */
 	if (arvif->vif->debugfs_dir)
 		ath11k_mac_debugfs_remove_stats_file(arvif);
-
+unlock:
 	mutex_unlock(&ar->conf_mutex);
 }
 
@@ -8958,15 +8896,6 @@ static void ath11k_mac_op_configure_filt
 	*total_flags &= SUPPORTED_FILTERS;
 	ar->filter_flags = *total_flags;
 
-	/* Remove the mac filter file */
-	debugfs_remove(arvif->mac_filter);
-	arvif->mac_filter = NULL;
-
-	/* Remove the wbm tx compl stats file */
-	debugfs_remove(arvif->wbm_tx_completion_stats);
-	arvif->wbm_tx_completion_stats = NULL;
-
-unlock:
 	mutex_unlock(&ar->conf_mutex);
 }
 
@@ -9485,7 +9414,7 @@ ath11k_mac_update_vif_chan(struct ath11k
 			ath11k_warn(ab, "failed to update bcn tmpl during csa: %d\n",
 				    ret);
 
-		mbssid_tx_vif = arvif->vif->mbssid_tx_vif;
+		mbssid_tx_vif = arvif->vif->bss_conf.mbssid_tx_vif;
 		if (mbssid_tx_vif)
 			tx_arvif = ath11k_vif_to_arvif(mbssid_tx_vif);
 
@@ -10061,7 +9990,7 @@ static void ath11k_mac_parse_tx_pwr_env(
 	struct ath11k_vif *arvif = (void *)vif->drv_priv;
 	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
 	struct ieee80211_tx_pwr_env *single_tpe;
-	enum wmi_reg_6g_client_type client_type;
+	enum wmi_reg_6ghz_client_type client_type;
 	int i;
 	u8 pwr_count, pwr_interpret, pwr_category;
 	u8 psd_index = 0, non_psd_index = 0, local_tpe_count = 0, reg_tpe_count = 0;
--- a/drivers/net/wireless/ath/ath11k/pci.c
+++ b/drivers/net/wireless/ath/ath11k/pci.c
@@ -362,13 +362,8 @@ static void ath11k_pci_init_qmi_ce_confi
 	cfg->svc_to_ce_map = ab->hw_params.svc_to_ce_map;
 	cfg->svc_to_ce_map_len = ab->hw_params.svc_to_ce_map_len;
 
-	if (ab->hw_rev == ATH11K_HW_QCN9074_HW10) {
-		ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id +
-		(((pci_domain_nr(bus) & 0xF) << 4) | (bus->number & 0xF));
-	} else {
-		ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
-		ab->qmi.service_ins_id += ab->userpd_id;
-	}
+	ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id +
+	(((pci_domain_nr(bus) & 0xF) << 4) | (bus->number & 0xF));
 
 	ret = of_property_read_u32(ab->dev->of_node, "qrtr_instance_id", &node_id);
 	if (!ret)
--- a/drivers/net/wireless/ath/ath11k/peer.c
+++ b/drivers/net/wireless/ath/ath11k/peer.c
@@ -458,8 +458,7 @@ void ath11k_peer_unmap_event(struct ath1
 	}
 
 	if (peer->peer_logging_enabled)
-		ath11k_dbg(ab, ATH11K_DBG_PEER, "peer unmap vdev %d peer %pM
-id %d\n",
+		ath11k_dbg(ab, ATH11K_DBG_PEER, "peer unmap vdev %d peer %pM id %d\n",
 			   peer->vdev_id, peer->addr, peer_id);
 
 	list_del(&peer->list);
--- a/drivers/net/wireless/ath/ath11k/peer.h
+++ b/drivers/net/wireless/ath/ath11k/peer.h
@@ -93,7 +93,6 @@ struct ath11k_peer {
 	u16 sec_type;
 	u16 sec_type_grp;
 	bool is_authorized;
-	bool dp_setup_done;
 	struct ppdu_user_delayba ppdu_stats_delayba;
 	bool delayba_flag;
 	bool peer_logging_enabled;
--- a/drivers/net/wireless/ath/ath11k/pktlog.h
+++ b/drivers/net/wireless/ath/ath11k/pktlog.h
@@ -51,6 +51,6 @@ struct ath_pktlog {
 	u8 hdr_size_field_offset;
 };
 
-#endif /* CONFIG_ATH10K_PKTLOG */
+#endif /* CONFIG_ATH11K_PKTLOG */
 
 #endif /* _PKTLOG_H_ */
--- a/drivers/net/wireless/ath/ath11k/qmi.c
+++ b/drivers/net/wireless/ath/ath11k/qmi.c
@@ -4476,24 +4476,6 @@ static void ath11k_qmi_msg_mem_ready_cb(
 	ath11k_qmi_driver_event_post(qmi, ATH11K_QMI_EVENT_FW_MEM_READY, NULL);
 }
 
-static void ath11k_qmi_msg_fw_ready_cb(struct qmi_handle *qmi_hdl,
-				       struct sockaddr_qrtr *sq,
-				       struct qmi_txn *txn,
-				       const void *decoded)
-{
-	struct ath11k_qmi *qmi = container_of(qmi_hdl, struct ath11k_qmi, handle);
-	struct ath11k_base *ab = qmi->ab;
-
-	ath11k_dbg(ab, ATH11K_DBG_QMI, "firmware ready\n");
-
-	if (!ab->qmi.cal_done) {
-		ab->qmi.cal_done = 1;
-		wake_up(&ab->qmi.cold_boot_waitq);
-	}
-
-	ath11k_qmi_driver_event_post(qmi, ATH11K_QMI_EVENT_FW_READY, NULL);
-}
-
 static void ath11k_qmi_msg_cold_boot_cal_done_cb(struct qmi_handle *qmi_hdl,
 						 struct sockaddr_qrtr *sq,
 						 struct qmi_txn *txn,
@@ -4754,19 +4736,19 @@ static const struct qmi_msg_handler ath1
 		.decoded_size = sizeof(struct qmi_wlanfw_request_mem_ind_msg_v01),
 		.fn = ath11k_qmi_msg_mem_request_cb,
 	},
+	 {
+                .type = QMI_INDICATION,
+                .msg_id = QMI_WLFW_FW_MEM_READY_IND_V01,
+                .ei = qmi_wlanfw_mem_ready_ind_msg_v01_ei,
+                .decoded_size = sizeof(struct qmi_wlanfw_fw_mem_ready_ind_msg_v01),
+                .fn = ath11k_qmi_msg_mem_ready_cb,
+        },
 	{
 		.type = QMI_INDICATION,
-		.msg_id = QMI_WLFW_FW_MEM_READY_IND_V01,
-		.ei = qmi_wlanfw_mem_ready_ind_msg_v01_ei,
-		.decoded_size = sizeof(struct qmi_wlanfw_fw_mem_ready_ind_msg_v01),
-		.fn = ath11k_qmi_msg_mem_ready_cb,
-	},
-	{
-		.type = QMI_INDICATION,
-		.msg_id = QMI_WLFW_FW_READY_IND_V01,
-		.ei = qmi_wlanfw_fw_ready_ind_msg_v01_ei,
-		.decoded_size = sizeof(struct qmi_wlanfw_fw_ready_ind_msg_v01),
-		.fn = ath11k_qmi_msg_fw_ready_cb,
+		.msg_id = QMI_WLFW_FW_INIT_DONE_IND_V01,
+		.ei = qmi_wlfw_fw_init_done_ind_msg_v01_ei,
+		.decoded_size = sizeof(struct qmi_wlfw_fw_init_done_ind_msg_v01),
+		.fn = ath11k_qmi_msg_fw_init_done_cb,
 	},
 	{
 		.type = QMI_INDICATION,
@@ -4800,14 +4782,6 @@ static const struct qmi_msg_handler ath1
 			sizeof(struct qmi_wlanfw_qdss_trace_save_ind_msg_v01),
 		.fn = ath11k_wlfw_qdss_trace_save_ind_cb,
 	},
-	{
-		.type = QMI_INDICATION,
-		.msg_id = QMI_WLFW_FW_INIT_DONE_IND_V01,
-		.ei = qmi_wlfw_fw_init_done_ind_msg_v01_ei,
-		.decoded_size =
-			sizeof(struct qmi_wlfw_fw_init_done_ind_msg_v01),
-		.fn = ath11k_qmi_msg_fw_init_done_cb,
-	},
 	/* end of list */
 	{},
 };
@@ -4957,22 +4931,6 @@ static void ath11k_qmi_driver_event_work
 			}
 
 			break;
-		case ATH11K_QMI_EVENT_FW_READY:
-			/* For targets requiring a FW restart upon cold
-			 * boot completion, there is no need to process
-			 * FW ready; such targets will receive FW init
-			 * done message after FW restart.
-			 */
-			if (ab->hw_params.cbcal_restart_fw)
-				break;
-
-			clear_bit(ATH11K_FLAG_CRASH_FLUSH,
-				  &ab->dev_flags);
-			clear_bit(ATH11K_FLAG_RECOVERY, &ab->dev_flags);
-			ath11k_core_qmi_firmware_ready(ab);
-			set_bit(ATH11K_FLAG_REGISTERED, &ab->dev_flags);
-
-			break;
 		case ATH11K_QMI_EVENT_COLD_BOOT_CAL_DONE:
 			break;
 		case ATH11K_QMI_EVENT_M3_DUMP_UPLOAD_REQ:
--- a/drivers/net/wireless/ath/ath11k/qmi.h
+++ b/drivers/net/wireless/ath/ath11k/qmi.h
@@ -70,10 +70,16 @@
 #define ATH11K_QMI_IPQ9574_BDF_OFFSET		0xC0000
 #define ATH11K_QMI_IPQ9574_M3_OFFSET		0xD00000
 
+#define ATH11K_QMI_QCN6122_M3_OFFSET            0xD00000
+#define ATH11K_QMI_QCN6122_QDSS_OFFSET          0xE00000
+#define ATH11K_QMI_QCN6122_CALDB_OFFSET         0xF00000
+#define ATH11K_QMI_IPQ9574_CALDB_OFFSET         0xA00000
+#define ATH11K_QMI_IPQ9574_BDF_OFFSET           0xC0000
+#define ATH11K_QMI_IPQ9574_M3_OFFSET            0xD00000
 #define QMI_WLFW_REQUEST_MEM_IND_V01		0x0035
 #define QMI_WLFW_FW_MEM_READY_IND_V01		0x0037
 #define QMI_WLFW_COLD_BOOT_CAL_DONE_IND_V01	0x003E
-#define QMI_WLFW_FW_READY_IND_V01		0x0021
+#define QMI_WLFW_FW_READY_IND_V01		0x0038
 #define QMI_WLFW_FW_INIT_DONE_IND_V01		0x0038
 #define QMI_WLFW_M3_DUMP_UPLOAD_DONE_REQ_V01    0x004E
 #define QMI_WLFW_M3_DUMP_UPLOAD_REQ_IND_V01     0x004D
@@ -119,7 +125,6 @@ enum ath11k_qmi_event_type {
 	ATH11K_QMI_EVENT_SERVER_EXIT,
 	ATH11K_QMI_EVENT_REQUEST_MEM,
 	ATH11K_QMI_EVENT_FW_MEM_READY,
-	ATH11K_QMI_EVENT_FW_READY,
 	ATH11K_QMI_EVENT_COLD_BOOT_CAL_START,
 	ATH11K_QMI_EVENT_COLD_BOOT_CAL_DONE,
 	ATH11K_QMI_EVENT_REGISTER_DRIVER,
--- a/drivers/net/wireless/ath/ath11k/reg.c
+++ b/drivers/net/wireless/ath/ath11k/reg.c
@@ -463,6 +463,21 @@ static void ath11k_copy_reg_rule(struct
 		ath11k_reg_rule->end_freq = reg_rule->end_freq;
 }
 
+enum wmi_reg_6ghz_ap_type
+ath11k_ieee80211_ap_pwr_type_convert(enum ieee80211_ap_reg_power power_type)
+{
+        switch (power_type) {
+        case IEEE80211_REG_LPI_AP:
+                return WMI_REG_INDOOR_AP;
+        case IEEE80211_REG_SP_AP:
+                return WMI_REG_STANDARD_POWER_AP;
+        case IEEE80211_REG_VLP_AP:
+                return WMI_REG_VERY_LOW_POWER_AP;
+        default:
+                return WMI_REG_MAX_AP_TYPE;
+        }
+}
+
 static struct cur_reg_rule
 *ath11k_get_active_6g_reg_rule(struct cur_regulatory_info *reg_info,
 			       u32 *max_bw_6g, int *max_elements,
@@ -472,11 +487,11 @@ static struct cur_reg_rule
 	u8 i = 0, j = 0;
 
 	for (i = 0; i < WMI_REG_CURRENT_MAX_AP_TYPE; i++) {
-		if (reg_info->num_6g_reg_rules_ap[i]) {
-			*max_elements = reg_info->num_6g_reg_rules_ap[i];
-			reg_rule = reg_info->reg_rules_6g_ap_ptr[i];
-			*max_bw_6g = reg_info->max_bw_6g_ap[i];
-			reg_info->num_6g_reg_rules_ap[i] = 0;
+		if (reg_info->num_6ghz_rules_ap[i]) {
+			*max_elements = reg_info->num_6ghz_rules_ap[i];
+			reg_rule = reg_info->reg_rules_6ghz_ap_ptr[i];
+			*max_bw_6g = reg_info->max_bw_6ghz_ap[i];
+			reg_info->num_6ghz_rules_ap[i] = 0;
 			*pwr_mode = i;
 			return reg_rule;
 		}
@@ -484,13 +499,13 @@ static struct cur_reg_rule
 
 	for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {
 		for (j = 0; j < WMI_REG_CURRENT_MAX_AP_TYPE; j++) {
-			if (reg_info->num_6g_reg_rules_client[j][i]) {
-				*max_elements = reg_info->num_6g_reg_rules_client
+			if (reg_info->num_6ghz_rules_client[j][i]) {
+				*max_elements = reg_info->num_6ghz_rules_client
 									   [j][i];
-				reg_rule = reg_info->reg_rules_6g_client_ptr
+				reg_rule = reg_info->reg_rules_6ghz_client_ptr
 								      [j][i];
-				*max_bw_6g = reg_info->max_bw_6g_client[j][i];
-				reg_info->num_6g_reg_rules_client[j][i] = 0;
+				*max_bw_6g = reg_info->max_bw_6ghz_client[j][i];
+				reg_info->num_6ghz_rules_client[j][i] = 0;
 				*pwr_mode = WMI_REG_CURRENT_MAX_AP_TYPE * (i + 1)  + j;
 				return reg_rule;
 			}
@@ -506,7 +521,7 @@ ath11k_reg_build_regd(struct ath11k_base
 		      enum ieee80211_ap_reg_power power_type)
 {
 	struct ieee80211_regdomain *new_regd = NULL;
-	struct cur_reg_rule *reg_rule;
+	struct cur_reg_rule *reg_rule, *reg_rule_6g;
 	u8 i = 0, j = 0, k = 0, max_elements = 0;
 	u8 num_rules;
 	u16 max_bw;
--- a/drivers/net/wireless/ath/ath11k/reg.h
+++ b/drivers/net/wireless/ath/ath11k/reg.h
@@ -37,4 +37,6 @@ ath11k_reg_build_regd(struct ath11k_base
 		      enum ieee80211_ap_reg_power power_type);
 int ath11k_regd_update(struct ath11k *ar);
 int ath11k_reg_update_chan_list(struct ath11k *ar, bool wait);
+enum wmi_reg_6ghz_ap_type
+ath11k_ieee80211_ap_pwr_type_convert(enum ieee80211_ap_reg_power power_type);
 #endif
--- a/drivers/net/wireless/ath/ath11k/testmode.h
+++ b/drivers/net/wireless/ath/ath11k/testmode.h
@@ -5,7 +5,9 @@
  */
 
 #include "core.h"
+#include "hif.h"
 
+#define WMI_TLV_HDR_SIZE 4
 #ifdef CPTCFG_NL80211_TESTMODE
 
 void ath11k_tm_wmi_event(struct ath11k_base *ab, u32 cmd_id, struct sk_buff *skb);
--- a/drivers/net/wireless/ath/ath11k/thermal.h
+++ b/drivers/net/wireless/ath/ath11k/thermal.h
@@ -26,7 +26,7 @@ struct ath11k_thermal {
 	int temperature;
 };
 
-#if IS_REACHABLE(CPTCFG_ATH11K_THERMAL)
+#if IS_REACHABLE(CONFIG_THERMAL)
 int ath11k_thermal_register(struct ath11k_base *sc);
 void ath11k_thermal_unregister(struct ath11k_base *sc);
 int ath11k_thermal_set_throttling(struct ath11k *ar, u32 throttle_state);
--- a/drivers/net/wireless/ath/ath11k/wmi.c
+++ b/drivers/net/wireless/ath/ath11k/wmi.c
@@ -1168,7 +1168,7 @@ int ath11k_wmi_vdev_up(struct ath11k *ar
 	struct sk_buff *skb;
 	int ret;
 
-	arvif = ath11k_mac_get_arvif(ar, vdev_id);
+	arvif = ath11k_mac_get_arvif(ar, params->vdev_id);
 
 	skb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));
 	if (!skb)
@@ -1181,15 +1181,13 @@ int ath11k_wmi_vdev_up(struct ath11k *ar
 	cmd->vdev_id = params->vdev_id;
 	cmd->vdev_assoc_id = params->aid;
 	ether_addr_copy(cmd->vdev_bssid.addr, params->bssid);
-	cmd->profile_idx = params->profile_idx;
-	cmd->profile_count = params->profile_count;
+	cmd->nontx_profile_idx = params->profile_idx;
+	cmd->nontx_profile_cnt = params->profile_count;
 	if (params->tx_bssid)
 		ether_addr_copy(cmd->tx_vdev_bssid.addr, params->tx_bssid);
 
-	cmd->nontx_profile_idx = nontx_profile_idx;
-	cmd->nontx_profile_cnt = nontx_profile_cnt;
-	if (tx_bssid)
-		ether_addr_copy(cmd->tx_vdev_bssid.addr, tx_bssid);
+	if (params->tx_bssid)
+		ether_addr_copy(cmd->tx_vdev_bssid.addr, params->tx_bssid);
 
 	if (arvif && arvif->vif->type == NL80211_IFTYPE_STATION) {
 		bss_conf = &arvif->vif->bss_conf;
@@ -2214,7 +2212,7 @@ ath11k_wmi_dcs_awgn_interference_event(s
 	}
 	ar->awgn_chandef = *chandef;
 
-	ieee80211_awgn_detected(ar->hw, awgn_info.chan_bw_interference_bitmap);
+	ieee80211_awgn_detected(ar->hw, awgn_info.chan_bw_interference_bitmap,NULL);
 
 	spin_lock_bh(&ar->data_lock);
 	/* Incase of mesh intf presence, dont set in prog as there will be no
@@ -4943,7 +4941,7 @@ ath11k_wmi_obss_color_collision_event(st
 	switch (ev->evt_type) {
 	case WMI_BSS_COLOR_COLLISION_DETECTION:
 		ieee80211_obss_color_collision_notify(arvif->vif, ev->obss_color_bitmap,
-						      GFP_KERNEL);
+						      GFP_KERNEL, 0);
 		ath11k_dbg(ab, ATH11K_DBG_WMI,
 			   "OBSS color collision detected vdev:%d, event:%d, bitmap:%08llx\n",
 			   ev->vdev_id, ev->evt_type, ev->obss_color_bitmap);
@@ -6362,27 +6360,6 @@ ath11k_invalid_5ghz_reg_ext_rules_from_w
 	return num_invalid_5ghz_rules;
 }
 
-static u8
-ath11k_invalid_5g_reg_ext_rules_from_wmi(u32 num_reg_rules,
-					 struct wmi_regulatory_ext_rule_struct *wmi_reg_rule)
-{
-	u8 num_invalid_5g_rules = 0;
-	u32 count, start_freq, end_freq;
-
-	for (count = 0; count < num_reg_rules; count++) {
-		start_freq = FIELD_GET(REG_RULE_START_FREQ,
-				       wmi_reg_rule[count].freq_info);
-		end_freq = FIELD_GET(REG_RULE_END_FREQ,
-				     wmi_reg_rule[count].freq_info);
-
-		if (start_freq >= ATH11K_MIN_6G_FREQ &&
-		    end_freq <= ATH11K_MAX_6G_FREQ)
-			num_invalid_5g_rules++;
-	}
-
-	return num_invalid_5g_rules;
-}
-
 static int ath11k_pull_reg_chan_list_ext_update_ev(struct ath11k_base *ab,
 						   struct sk_buff *skb,
 						   struct cur_regulatory_info *reg_info)
@@ -6938,7 +6915,7 @@ static int ath11k_pull_mgmt_rx_params_tl
 }
 
 static int wmi_process_tx_comp(struct ath11k *ar,
-				    struct wmi_mgmt_tx_compl_event *tx_compl_param)
+				    struct wmi_tx_compl_event *tx_compl_param)
 {
 	struct sk_buff *msdu;
 	struct ieee80211_tx_info *info;
@@ -8265,8 +8242,6 @@ static int ath11k_reg_handle_chan_list(s
 	struct ath11k *ar;
 	int pdev_idx;
 
-	ath11k_dbg(ab, ATH11K_DBG_WMI, "event reg chan list id %d", id);
-
 	if (reg_info->status_code != REG_SET_CC_STATUS_PASS) {
 		/* In case of failure to set the requested ctry,
 		 * fw retains the current regd. We print a failure info
@@ -8382,14 +8357,14 @@ static int ath11k_reg_chan_list_event(st
 
 mem_free:
 	if (reg_info) {
-		kfree(reg_info->reg_rules_2g_ptr);
-		kfree(reg_info->reg_rules_5g_ptr);
+		kfree(reg_info->reg_rules_2ghz_ptr);
+		kfree(reg_info->reg_rules_5ghz_ptr);
 		if (reg_info->is_ext_reg_event) {
 			for (i = 0; i < WMI_REG_CURRENT_MAX_AP_TYPE; i++) {
-				kfree(reg_info->reg_rules_6g_ap_ptr[i]);
+				kfree(reg_info->reg_rules_6ghz_ap_ptr[i]);
 
 				for (j = 0; j < WMI_REG_MAX_CLIENT_TYPE; j++)
-					kfree(reg_info->reg_rules_6g_client_ptr[i][j]);
+					kfree(reg_info->reg_rules_6ghz_client_ptr[i][j]);
 			}
 		}
 		kfree(reg_info);
--- a/drivers/net/wireless/ath/ath11k/wmi.h
+++ b/drivers/net/wireless/ath/ath11k/wmi.h
@@ -2185,12 +2185,12 @@ enum wmi_tlv_service {
 	WMI_TLV_SERVICE_FREQINFO_IN_METADATA = 219,
 	WMI_TLV_SERVICE_EXT2_MSG = 220,
 	WMI_TLV_SERVICE_PEER_POWER_SAVE_DURATION_SUPPORT = 246,
+	WMI_TLV_SERVICE_5_DOT_9GHZ_SUPPORT = 247,
 	WMI_TLV_SERVICE_SRG_SRP_SPATIAL_REUSE_SUPPORT = 249,
 	WMI_TLV_REQUEST_CTRL_PATH_STATS_REQUEST = 250,
 	WMI_TLV_SERVICE_TPC_STATS_EVENT = 251,
 	WMI_TLV_SERVICE_NO_INTERBAND_MCC_SUPPORT = 252,
 	WMI_TLV_SERVICE_MBSS_PARAM_IN_VDEV_START_SUPPORT = 253,
-	WMI_TLV_SERVICE_MBSS_PARAM_IN_VDEV_START_SUPPORT = 253,
 	WMI_TLV_SERVICE_CONFIGURE_ROAM_TRIGGER_PARAM_SUPPORT = 254,
 	WMI_TLV_SERVICE_CFR_TA_RA_AS_FP_SUPPORT = 255,
 	WMI_TLV_SERVICE_CFR_CAPTURE_COUNT_SUPPORT = 256,
@@ -3083,6 +3083,13 @@ struct rx_reorder_queue_remove_params {
 #define WMI_VDEV_PARAM_TXBF_SU_TX_BFER BIT(2)
 #define WMI_VDEV_PARAM_TXBF_MU_TX_BFER BIT(3)
 
+#define HECAP_PHYDWORD_0        0
+#define HECAP_PHYDWORD_1        1
+#define HECAP_PHYDWORD_2        2
+#define HECAP_PHYDWORD_3        3
+#define HECAP_PHYDWORD_4        4
+
+
 #define HE_PHYCAP_BYTE_0	0
 #define HE_PHYCAP_BYTE_1	1
 #define HE_PHYCAP_BYTE_2	2
--- a/local-symbols
+++ b/local-symbols
@@ -172,7 +172,10 @@ ATH11K_DEBUG=
 ATH11K_DEBUGFS=
 ATH11K_TRACING=
 ATH11K_SPECTRAL=
+ATH11K_PKTLOG=
+ATH11K_CFR=
 ATH11K_THERMAL=
+ATH11K_SMART_ANT_ALG=
 ATH12K=
 ATH12K_DEBUG=
 ATH12K_TRACING=
