From ac0d3754703e11e054269e05650a2fd59bec0070 Mon Sep 17 00:00:00 2001
From: Ramanathan Choodamani <quic_rchoodam@quicinc.com>
Date: Wed, 26 Apr 2023 16:37:13 -0700
Subject: [PATCH] ath12k: Add support for Bond interface

Add support for bonded interface to represent each wifi link with a separate
netdevice. With the new code changes, there will be new interfaces in the system.
Add support to collect statistics for the bonded devices.

wlan0 - Original netdevice that gets created as per ath12k control path
        This netdevice will continue to exist and will be used for all
        control path communications. All NL messages from userspace applications
        are processed on the context of this device. This device will not be
        exposed to the bridge anymore
wlan0_b - This represents the bonded interface. No NL messages will be processed
        on the context of this device. This device is purely meant for only
        datapath. This device will be exposed to the bridge layer
link0 - wlan_l0 (link netdevice)
        Will be used for registering with PPE module during MLO DS operation
link1 - wlan_l1 (link netdevice)
        Will be used for registering with PPE module during MLO DS operation

Signed-off-by: Ramanathan Choodamani <quic_rchoodam@quicinc.com>
Signed-off-by: Balamurugan Mahalingam <quic_bmahalin@quicinc.com>
Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
Signed-off-by: Aloka Dixit <quic_alokad@quicinc.com>
Signed-off-by: Shivani Tambatkar <quic_stambatk@quicinc.com>
Signed-off-by: Sidhanta Sahu <quic_sidhanta@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/Kconfig    |   9 +
 drivers/net/wireless/ath/ath12k/Makefile   |   1 +
 drivers/net/wireless/ath/ath12k/bondif.c   | 783 +++++++++++++++++++++
 drivers/net/wireless/ath/ath12k/bondif.h   |  43 ++
 drivers/net/wireless/ath/ath12k/core.h     |  18 +
 drivers/net/wireless/ath/ath12k/dp.c       |   7 +
 drivers/net/wireless/ath/ath12k/dp_rx.c    |  15 +-
 drivers/net/wireless/ath/ath12k/dp_tx.c    |   5 +-
 drivers/net/wireless/ath/ath12k/mac.c      |  80 ++-
 drivers/net/wireless/ath/ath12k/pci.c      |  23 +
 drivers/net/wireless/ath/ath12k/ppe.c      |  82 ++-
 drivers/net/wireless/ath/ath12k/ppe.h      |  15 +-
 drivers/net/wireless/ath/ath6kl/cfg80211.c |   2 +-
 drivers/net/wireless/ath/wil6210/netdev.c  |   2 +-
 include/net/cfg80211.h                     |   3 +-
 include/net/mac80211.h                     |   6 +-
 include/uapi/linux/nl80211.h               |   3 +
 local-symbols                              |   2 +
 net/mac80211/Kconfig                       |  18 +
 net/mac80211/cfg.c                         |  30 +-
 net/mac80211/chan.c                        |   8 +
 net/mac80211/ieee80211_i.h                 |   5 +-
 net/mac80211/iface.c                       |  24 +-
 net/mac80211/main.c                        |   8 +-
 net/mac80211/mlme.c                        |   3 +-
 net/mac80211/rx.c                          |  18 +-
 net/mac80211/util.c                        |   4 +
 net/wireless/chan.c                        |   8 +
 net/wireless/core.c                        |  50 +-
 net/wireless/nl80211.c                     |  29 +-
 net/wireless/util.c                        |   4 +
 32 files changed, 1268 insertions(+), 89 deletions(-)
 create mode 100644 drivers/net/wireless/ath/ath12k/bondif.c
 create mode 100644 drivers/net/wireless/ath/ath12k/bondif.h

--- a/drivers/net/wireless/ath/ath12k/Kconfig
+++ b/drivers/net/wireless/ath/ath12k/Kconfig
@@ -75,3 +75,12 @@ config ATH12K_PPE_DS_SUPPORT
 		Enable ath12k PPE-DS support
 
 		Say Y to enable PPE DS Support. If unsure, say N.
+
+config ATH12K_BONDED_DS_SUPPORT
+	bool "QTI ath12k bonded-ds support"
+	depends on ATH12K_DEBUGFS
+	depends on RELAY
+	help
+		Enable ath12k Bonded-DS support
+
+		Say Y to enable Bonded DS Support. If unsure, say N.
--- a/drivers/net/wireless/ath/ath12k/Makefile
+++ b/drivers/net/wireless/ath/ath12k/Makefile
@@ -31,6 +31,7 @@ ath12k-$(CPTCFG_WANT_DEV_COREDUMP) += co
 ath12k-$(CPTCFG_ATH12K_PKTLOG) += pktlog.o
 ath12k-$(CPTCFG_ATH12K_AHB) += ahb.o
 ath12k-$(CPTCFG_ATH12K_PPE_DS_SUPPORT) += ppe.o
+ath12k-$(CPTCFG_ATH12K_BONDED_DS_SUPPORT) += bondif.o
 
 # for tracing framework to find trace.h
 CFLAGS_trace.o := -I$(src)
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/bondif.c
@@ -0,0 +1,914 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#include <net/mac80211.h>
+#include <linux/module.h>
+#include <net/bonding.h>
+#include <linux/ieee80211.h>
+#include "core.h"
+#include "ppe.h"
+#include "bondif.h"
+#include "debug.h"
+#include "dp_tx.h"
+
+static const struct net_device_ops ieee80211_link_dataif_8023_ops;
+extern struct ath12k_link_vif *ath12k_mac_assign_link_vif( struct ath12k_hw *ah,
+					struct ieee80211_vif *vif, u8 link_id);
+extern int g_bonded_interface_model;
+extern bool ath12k_mac_tx_check_max_limit(struct ath12k *ar, struct sk_buff *skb);
+
+static void ath12k_ieee80211_if_free(struct net_device *dev)
+{
+	free_percpu(dev->tstats);
+}
+
+static void ath12k_ieee80211_if_setup(struct net_device *dev)
+{
+	ether_setup(dev);
+	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+	dev->netdev_ops = &ieee80211_link_dataif_8023_ops;
+	netdev_set_priv_destructor(dev, ath12k_ieee80211_if_free);
+}
+
+static bool ath12k_dst_ppe_vp(struct net_device *dev,
+                                         struct sk_buff *skb, void *cb_data)
+{
+	if (unlikely(dev == NULL)) {
+		dev_kfree_skb_any(skb);
+		return false;
+	}
+
+	skb->dev = dev;
+	dev_queue_xmit(skb);
+
+	return true;
+}
+
+int ath12k_bond_link_add(struct ath12k_link_vif *arvif, struct net_device *link_dev)
+{
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+	int ret;
+
+	if (!g_bonded_interface_model)
+		return 0;
+
+	link_ndev_pvt = netdev_priv(link_dev);
+
+	ath12k_info(NULL, "Enslave bond_dev %px link_ndev %px\n", link_ndev_pvt->bond_dev, link_dev);
+	ret = bond_enslave(link_ndev_pvt->bond_dev, link_dev, NULL);
+	if (ret) {
+		ath12k_err(NULL, "Error bond enslave error\n");
+		return -EINVAL;
+	}
+	else {
+		ath12k_info(NULL, "Successfully enslaved link_ndev %s %px\n",
+			    link_dev->name, link_dev);
+	}
+
+	return 0;
+}
+
+void ath12k_bond_link_delete(struct ath12k_link_vif *arvif)
+{
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+
+	if (!g_bonded_interface_model)
+		return;
+
+	if (!arvif->ndev_pvt || !arvif->ndev_pvt->link_ndev) {
+		ath12k_err(NULL, "ERR no link dev for this vif to release from bond\n");
+		return;
+	}
+
+	link_ndev_pvt = netdev_priv(arvif->ndev_pvt->link_ndev);
+	if (link_ndev_pvt && link_ndev_pvt->bond_dev) {
+		ath12k_info(NULL, "Bond_release link netdevice %s link ndev %px \n",
+			    arvif->ndev_pvt->link_ndev->name, arvif->ndev_pvt->link_ndev);
+
+		/* bond_release expects slave netdevices to be in down state */
+		link_ndev_pvt->link_ndev->flags &= ~IFF_UP;
+		bond_release(link_ndev_pvt->bond_dev, link_ndev_pvt->link_ndev);
+	} else {
+		ath12k_err(NULL, "ERR unable to release Bond %s link ndev %px \n",
+			   arvif->ndev_pvt->link_ndev->name, arvif->ndev_pvt->link_ndev);
+	}
+}
+
+static bool ath12k_stats_update_ppe_vp(struct net_device *dev, ppe_vp_hw_stats_t *vp_stats)
+{
+        struct pcpu_sw_netstats *tstats = this_cpu_ptr(netdev_tstats(dev));
+
+        u64_stats_update_begin(&tstats->syncp);
+        tstats->tx_packets += vp_stats->tx_pkt_cnt;
+        tstats->tx_bytes += vp_stats->tx_byte_cnt;
+        tstats->rx_packets += vp_stats->rx_pkt_cnt;
+        tstats->rx_bytes += vp_stats->rx_byte_cnt;
+        u64_stats_update_end(&tstats->syncp);
+
+        return true;
+}
+
+void ath12k_enable_ppe_for_link_netdev(struct ath12k_link_vif *arvif,
+				       struct net_device *link_dev)
+{
+	struct ppe_vp_ai vpai;
+	struct ieee80211_ppe_vp_ds_params vp_params = {0};
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+	int ret;
+	int ppe_vp_num = -1;
+
+	arvif->ppe_vp_num = -1;
+	arvif->ppe_vp_type = -1;
+	if (!g_bonded_interface_model)
+		return;
+
+	memset(&vpai, 0, sizeof(struct ppe_vp_ai));
+
+	vpai.type = PPE_VP_TYPE_SW_L2;
+	vpai.dst_cb = ath12k_dst_ppe_vp;
+	vpai.dst_cb_data = arvif;
+	vpai.src_cb = NULL;
+	vpai.src_cb_data = NULL;
+	vpai.stats_cb = ath12k_stats_update_ppe_vp;
+	vpai.queue_num = 0;
+	vpai.usr_type = PPE_VP_USER_TYPE_DS;
+	vpai.usr_type = PPE_VP_USER_TYPE_DS;
+	vpai.net_dev_type = PPE_VP_NET_DEV_TYPE_WIFI;
+	link_ndev_pvt = netdev_priv(link_dev);
+
+	vpai.core_mask = ATH12K_PPE_DS_DEFAULT_CORE_MASK;
+	vp_params.dev = link_dev;
+
+	if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &arvif->ar->ab->dev_flags)) {
+		vpai.usr_type = PPE_VP_USER_TYPE_DS;
+
+		ret = ath12k_mac_op_ppeds_attach_vdev(arvif, &vpai,
+						      &ppe_vp_num, &vp_params);
+		if (ret) {
+			ath12k_err(NULL, "Error in enabling DS for arvif %pM\n", arvif->addr);
+			return;
+		}
+		arvif->ppe_vp_type = PPE_VP_USER_TYPE_DS;
+		link_ndev_pvt->ppe_vp_profile_idx = vp_params.ppe_vp_profile_idx;
+		link_ndev_pvt->vp_num = ppe_vp_num;
+		arvif->ppe_vp_num = ppe_vp_num;
+		ath12k_dbg(arvif->ar->ab, ATH12K_DBG_PPE,
+			   "Enabling DS index %d vp %d link_id %d %pM core_mask 0x%x\n",
+			   vp_params.ppe_vp_profile_idx, ppe_vp_num,
+			   arvif->link_id, arvif->addr, vpai.core_mask);
+	} else {
+		vpai.usr_type = PPE_VP_USER_TYPE_ACTIVE;
+
+		ppe_vp_num = ppe_vp_alloc(vp_params.dev, &vpai);
+		if (ppe_vp_num <= 0) {
+			ath12k_err(NULL, "Error in enabling Active VP for arvif %pM\n", arvif->addr);
+			return;
+		}
+		link_ndev_pvt->vp_num = ppe_vp_num;
+		arvif->ppe_vp_num = ppe_vp_num;
+		arvif->ppe_vp_type = vpai.usr_type;
+		ath12k_dbg(ab, ATH12K_DBG_PPE,
+			   "Enabling Active VP for arvif %pM dev %s vp_num %d core_mask 0x%x\n",
+			   arvif->addr, vp_params.dev->name,
+			   arvif->ppe_vp_num, vpai.core_mask);
+	}
+
+	return;
+}
+
+void ath12k_disable_ppe_for_link_netdev(struct ath12k_link_vif *arvif, struct net_device *link_dev)
+{
+	struct ieee80211_ppe_vp_ds_params vp_params = {0};
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+
+	if (!g_bonded_interface_model)
+		return;
+
+	link_ndev_pvt = netdev_priv(link_dev);
+	vp_params.ppe_vp_profile_idx = link_ndev_pvt->ppe_vp_profile_idx;
+	if (arvif->ppe_vp_num == -1)
+		return;
+
+	if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags)) {
+		ath12k_mac_op_ppeds_detach_vdev (arvif, &vp_params);
+		if (arvif->ppe_vp_type != PPE_VP_USER_TYPE_DS)
+			ppe_vp_free(arvif->ppe_vp_num);
+
+	} else {
+		ppe_vp_free(arvif->ppe_vp_num);
+	}
+
+	ath12k_dbg(arvif->ar->ab, ATH12K_DBG_PPE,
+		   "Destroyed PPE VP port type %d no:%d for dev:%s\n",
+		   arvif->ppe_vp_type, arvif->ppe_vp_num, link_dev->name);
+	arvif->ppe_vp_num = -1;
+	arvif->ppe_vp_type = -1;
+}
+
+int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif,
+					  u16 old_links, u16 new_links,
+					  struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
+{
+	u16  new_link_id;
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
+	struct net_device *cp_netdev = wdev->netdev;
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+	struct net_device *link_ndev;
+	struct ath12k_mld_dev *mldev = NULL;
+	u16 link_num;
+	struct net_device *bond_dev = NULL;
+	char name[20] = {0};
+	int ret = 0, chip_id = 0, pdev_id = 0;
+
+	if (!g_bonded_interface_model)
+		return 0;
+
+	bond_dev = wdev->bond_netdev;
+	if (!bond_dev)
+		return 0;
+	mldev = bond_get_mlo_ctx(bond_dev);
+
+	new_link_id = new_links ^ old_links;
+	link_num =  ffs(new_link_id) - 1;
+	/* TODO: Do this assignment only for the Add link case */
+
+	if (new_links > old_links)  {
+		/* Add Link operation */
+		snprintf(name, sizeof(name), "%s_l%d", cp_netdev->name, link_num);
+		link_ndev = alloc_netdev_mqs(sizeof (struct ath12k_link_vif_pvt), name, NET_NAME_ENUM, ath12k_ieee80211_if_setup, 1, 1);
+		if (!link_ndev) {
+			ath12k_err(NULL, "ERR: link netdev allocation failed\n");
+			//TODO: Graceful cleanup
+			return -EINVAL;
+		}
+
+		memcpy(&link_ndev->perm_addr, wdev->links[link_num].addr, ETH_ALEN);
+		link_ndev->dev_addr = &link_ndev->perm_addr;
+		link_ndev_pvt = netdev_priv(link_ndev);
+		memset(link_ndev_pvt, 0, sizeof(*link_ndev_pvt));
+		link_ndev->netdev_ops = &ieee80211_link_dataif_8023_ops;
+		link_ndev_pvt->hw = hw;
+		link_ndev_pvt->link_ndev = link_ndev;
+		link_ndev_pvt->bond_dev = bond_dev;
+		link_ndev_pvt->is_started = false;
+		mldev->vif = vif;
+		mutex_lock(&vif->bond_mutex);
+		vif->link_ndev[link_num] = link_ndev;
+		mutex_unlock(&vif->bond_mutex);
+		link_ndev->max_mtu = IEEE80211_MAX_DATA_LEN;
+		link_ndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
+		ret = register_netdevice(link_ndev);
+		if (ret) {
+			ath12k_err(NULL, "Error register link netdevice\n");
+			//TODO: Graceful cleanup
+			return -EINVAL;
+		}
+
+		memcpy(&bond_dev->perm_addr, vif->addr, ETH_ALEN);
+		bond_dev->dev_addr = &bond_dev->perm_addr;
+
+		if (mldev && !mldev->mcast_dev_set) {
+			mldev->mcast_dev_set = true;
+			mldev->primary_chipid = chip_id;
+			mldev->primary_pdevid = pdev_id;
+		}
+		if (mldev)
+			mldev->link_dev[chip_id][pdev_id] =  link_ndev;
+
+		} else {
+			/* Delete Link operation */
+			mutex_lock(&vif->bond_mutex);
+			link_ndev = vif->link_ndev[link_num];
+			if (link_ndev) {
+				ath12k_info(NULL, "Unregister link netdevice %s link ndev %px link_num %d\n", link_ndev->name, link_ndev, link_num);
+				unregister_netdevice(link_ndev);
+				vif->link_ndev[link_num] = NULL;
+			} else {
+				ath12k_err(NULL, "ERR Unregister link netdevice %s link ndev %px link_num %d\n", link_ndev->name, link_ndev, link_num);
+			}
+			mutex_unlock(&vif->bond_mutex);
+		}
+	ath12k_info(NULL, "%s:%d link changed for MLD %pM old 0x%x new 0x%x\n", __func__, __LINE__, vif->addr, old_links, new_links);
+	return 0;
+}
+
+
+static struct net_device *ath12k_mac_get_tx_link_netdev(struct ath12k_mld_dev *mldev, u8 *dst_mac_addr)
+{
+	struct net_device *ndev = NULL;
+	struct ieee80211_sta *sta= NULL;
+	struct ath12k_sta *ahsta;
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(mldev->vif);
+
+	rcu_read_lock();
+	sta = ieee80211_find_sta(mldev->vif, dst_mac_addr);
+
+	if (!sta) {
+		rcu_read_unlock();
+		ndev = mldev->vif->link_ndev[ahvif->deflink.link_id];
+		ath12k_dbg(NULL, ATH12K_DBG_DP_TX, "(%s,%d) PPE %s:%d ahvif->deflink.link_id %d dev %s\n",
+				current->comm, current->pid, __func__, __LINE__,
+				ahvif->deflink.link_id, ndev->name);
+		return ndev;
+	}
+
+	ahsta = (struct ath12k_sta *)sta->drv_priv;
+
+	if (!sta->mlo) {
+		ndev = mldev->vif->link_ndev[ahsta->deflink.link_id];
+		//todo: check changing addr3 needed as in ath12k_mac_get_tx_link
+
+		ath12k_dbg(NULL, ATH12K_DBG_DP_TX, "(%s,%d) PPE %s:%d pkt delivered to sta.deflink.link_id %d dev %s\n",
+				current->comm, current->pid, __func__, __LINE__,
+				ahsta->deflink.link_id, ndev->name);
+		rcu_read_unlock();
+		return ndev;
+	}
+
+	if (sta) {
+		/* TODO: Use Primary Link */
+		ndev = mldev->vif->link_ndev[ahsta->assoc_link_id];
+		ath12k_dbg(NULL, ATH12K_DBG_DP_TX, "[%s] %s:%d deliver packets for sta %pM ahsta->assoc_link_id %d ndev %s\n",
+				 current->comm, __func__, __LINE__,
+				 sta, ahsta->assoc_link_id, ndev->name);
+	}
+
+	rcu_read_unlock();
+
+	/* TODO: Verify what happens with NULL. Understand what is the fall back*/
+	return ndev;
+}
+
+static void ath12k_dp_tx_release_txbuf(struct ath12k_dp *dp,
+				       struct ath12k_tx_desc_info *tx_desc,
+				       u8 ring_id)
+{
+	tx_desc->skb = NULL;
+	tx_desc->skb_ext_desc = NULL;
+	spin_lock_bh(&dp->tx_desc_lock[ring_id]);
+	list_move_tail(&tx_desc->list, &dp->tx_desc_free_list[ring_id]);
+	spin_unlock_bh(&dp->tx_desc_lock[ring_id]);
+}
+
+static inline
+struct ath12k_tx_desc_info *ath12k_dp_tx_assign_buffer(struct ath12k_dp *dp,
+							      u8 pool_id)
+{
+	struct ath12k_tx_desc_info *desc = NULL;
+
+	spin_lock_bh(&dp->tx_desc_lock[pool_id]);
+	desc = list_first_entry_or_null(&dp->tx_desc_free_list[pool_id],
+					struct ath12k_tx_desc_info,
+					list);
+	if (!desc) {
+		ath12k_dbg(dp->ab, ATH12K_DBG_DP_TX, "failed to allocate data Tx desc\n");
+		spin_unlock_bh(&dp->tx_desc_lock[pool_id]);
+		return NULL;
+	}
+
+	prefetch(desc);
+	list_move_tail(&desc->list, &dp->tx_desc_used_list[pool_id]);
+	spin_unlock_bh(&dp->tx_desc_lock[pool_id]);
+
+	return desc;
+}
+
+int ath12k_mcast_dp_tx(struct ath12k *ar, struct ath12k_link_vif *arvif,
+		       struct sk_buff *skb, bool gsn_valid, int mcbc_gsn)
+{
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ath12k_base *ab = ar->ab;
+	struct ath12k_dp *dp = &ab->dp;
+	struct hal_tx_info ti = {0};
+	struct ath12k_tx_desc_info *tx_desc = NULL;
+	struct ath12k_skb_cb *skb_cb = ATH12K_SKB_CB(skb);
+	struct hal_srng *tcl_ring;
+	struct dp_tx_ring *tx_ring;
+	void *hal_tcl_desc;
+	struct hal_tcl_data_cmd *tcl_cmd;
+	u8 hal_ring_id;
+	int ret;
+
+	if (unlikely(test_bit(ATH12K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags))) {
+		return -ESHUTDOWN;
+	}
+
+	ti.ring_id =
+		ab->hw_params->hw_ops->get_ring_selector(skb);
+
+	tx_ring = &dp->tx_ring[ti.ring_id];
+
+	tx_desc = ath12k_dp_tx_assign_buffer(dp, ti.ring_id);
+	if (unlikely(!tx_desc)) {
+		ab->soc_stats.tx_err.txbuf_na[ti.ring_id]++;
+		return -ENOMEM;
+	}
+
+	ATH12K_SKB_CB(skb)->link_id = arvif->link_id;
+	ti.bank_id = arvif->bank_id;
+	ti.meta_data_flags = arvif->tcl_metadata;
+
+	if (gsn_valid) {
+		ti.meta_data_flags = u32_encode_bits(HTT_TCL_META_DATA_TYPE_GLOBAL_SEQ_NUM,
+						     HTT_TCL_META_DATA_TYPE_MISSION) |
+				     u32_encode_bits(mcbc_gsn, HTT_TCL_META_DATA_GLOBAL_SEQ_NUM);
+		ti.vdev_id = arvif->vdev_id +
+			     HTT_TX_MLO_MCAST_HOST_REINJECT_BASE_VDEV_ID;
+	} else {
+		ti.vdev_id = arvif->vdev_id;
+	}
+
+	ti.encap_type = HAL_TCL_ENCAP_TYPE_ETHERNET;
+	ti.addr_search_flags = arvif->hal_addr_search_flags;
+	ti.search_type = arvif->search_type;
+	ti.type = HAL_TCL_DESC_TYPE_BUFFER;
+
+	if (likely(skb->ip_summed == CHECKSUM_PARTIAL &&
+		   ti.encap_type != HAL_TCL_ENCAP_TYPE_RAW)) {
+		ti.flags0 |= TX_IP_CHECKSUM;
+	}
+
+	ti.paddr = dma_map_single(ab->dev, skb->data, skb->len, DMA_TO_DEVICE);
+	if (unlikely(dma_mapping_error(ab->dev, ti.paddr))) {
+		atomic_inc(&ab->soc_stats.tx_err.misc_fail);
+		ath12k_warn(ab, "failed to DMA map data Tx buffer\n");
+		ret = -ENOMEM;
+		goto fail_remove_tx_buf;
+	}
+
+
+	/* Add metadata for sw encrypted vlan group traffic */
+
+	tx_desc->skb = skb;
+	tx_desc->mac_id = ar->pdev_idx;
+	tx_desc->recycler_fast_xmit = 0;
+	ti.desc_id = tx_desc->desc_id;
+	ti.data_len = skb->len - ti.pkt_offset;
+	skb_cb->paddr = ti.paddr;
+	skb_cb->vif = ahvif->vif;
+	skb_cb->ar = ar;
+
+	hal_ring_id = tx_ring->tcl_data_ring.ring_id;
+	tcl_ring = &ab->hal.srng_list[hal_ring_id];
+
+	spin_lock_bh(&tcl_ring->lock);
+	ath12k_hal_srng_access_src_ring_begin_nolock(tcl_ring);
+	hal_tcl_desc = ath12k_hal_srng_src_get_next_entry(ab, tcl_ring);
+	if (unlikely(!hal_tcl_desc)) {
+		/* NOTE: It is highly unlikely we'll be running out of tcl_ring
+		 * desc because the desc is directly enqueued onto hw queue.
+		 */
+		ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+		spin_unlock_bh(&tcl_ring->lock);
+		ab->soc_stats.tx_err.desc_na[ti.ring_id]++;
+		ret = -ENOMEM;
+
+		goto fail_unmap_dma;
+	}
+
+	ab->soc_stats.tx_enqueued[ti.ring_id]++;
+	arvif->link_stats.tx_encap_type[ti.encap_type]++;
+	arvif->link_stats.tx_encrypt_type[ti.encrypt_type]++;
+	arvif->link_stats.tx_desc_type[ti.type]++;
+	tcl_cmd = (struct hal_tcl_data_cmd *)hal_tcl_desc;
+
+	tcl_cmd->buf_addr_info.info0 = (u32)ti.paddr;
+	/* TODO: Copy the upper 8 bits here */
+	tcl_cmd->buf_addr_info.info1 = (ti.desc_id << 12);
+	tcl_cmd->info0 = (ti.type << 1) | arvif->desc.info0;
+	tcl_cmd->info1 = ti.meta_data_flags << 16;
+	tcl_cmd->info2 = ti.flags0 | ti.data_len;
+
+	/* In tcl_cmd->info3, Bit 24 to 31 represents vdev_id
+	 * LSH 24 times to add updated vdev_id to info3
+	 */
+	tcl_cmd->info3 = (ti.vdev_id << 24) | arvif->desc.info3;
+	tcl_cmd->info4 = arvif->desc.info4;
+	tcl_cmd->info5 = 0;
+
+	dsb(st);
+	ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+	spin_unlock_bh(&tcl_ring->lock);
+
+	ath12k_dbg_dump(ab, ATH12K_DBG_DP_TX, NULL, "dp tx msdu: ", skb->data, skb->len);
+	arvif->link_stats.tx_enqueued++;
+	atomic_inc(&ar->dp.num_tx_pending);
+
+	return 0;
+
+fail_unmap_dma:
+	dma_unmap_single(ab->dev, skb_cb->paddr, skb->len, DMA_TO_DEVICE);
+
+fail_remove_tx_buf:
+	ath12k_dp_tx_release_txbuf(dp, tx_desc, ti.ring_id);
+	if (ti.pkt_offset)
+		skb_pull(skb, ti.pkt_offset);
+
+	arvif->link_stats.tx_dropped++;
+
+	return ret;
+}
+
+int ath12k_dp_mlo_xmit_netdev(struct sk_buff *skb, struct net_device *bond_dev)
+{
+	struct net_device *link_dev = NULL;
+	struct ethhdr *eh = NULL;
+	struct ath12k_mld_dev *mldev = bond_get_mlo_ctx(bond_dev);
+	struct ath12k_link_vif_pvt *arvif_pvt = NULL;
+	struct ath12k_link_vif *arvif, *tmp_arvif;
+	struct ath12k_vif *ahvif = NULL;
+	struct sk_buff *msdu_copied;
+	struct ath12k *tmp_ar;
+	int is_mcast;
+	u16 mcbc_gsn;
+	int ret;
+	int link_id, ring_id = 0;
+	struct ath12k_skb_cb *skb_cb;
+	struct ieee80211_tx_info *info;
+
+	if (!(bond_dev->flags & IFF_UP)) {
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	eh = (struct ethhdr *)skb->data;
+	is_mcast = is_multicast_ether_addr(eh->h_dest);
+	skb_cb = ATH12K_SKB_CB(skb);
+	skb_cb->flags |= ATH12K_SKB_HW_80211_ENCAP;
+	info = IEEE80211_SKB_CB(skb);
+	info->flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;
+
+	if (is_mcast) {
+		uint8_t chip_id = mldev->primary_chipid;
+		uint8_t pdev_id = mldev->primary_pdevid;
+
+		link_dev = mldev->link_dev[chip_id][pdev_id];
+		arvif_pvt = netdev_priv(link_dev);
+		arvif = arvif_pvt->arvif;
+		if (!arvif) {
+			dev_kfree_skb_any(skb);
+			return NETDEV_TX_OK;
+		}
+
+		ahvif = arvif->ahvif;
+		if (!ahvif) {
+			dev_kfree_skb_any(skb);
+			return NETDEV_TX_OK;
+		}
+
+		spin_lock(&ahvif->mcbc_gsn_lock);
+		mcbc_gsn = ahvif->mcbc_gsn++;
+		if (ahvif->mcbc_gsn > 0xFFF)
+			ahvif->mcbc_gsn = 0;
+		spin_unlock(&ahvif->mcbc_gsn_lock);
+
+		for_each_set_bit(link_id, &ahvif->links_map,
+				IEEE80211_MLD_MAX_NUM_LINKS) {
+			tmp_arvif = ahvif->link[link_id];
+			if (tmp_arvif && tmp_arvif->ar)
+				tmp_ar = tmp_arvif->ar;
+			else
+				break;
+
+			ret = ath12k_mac_tx_check_max_limit(tmp_ar, skb);
+			if (ret) {
+				ath12k_dbg(tmp_ar->ab, ATH12K_DBG_MAC,
+						"failed fast tx due to limit check pdev idx %d\n",
+						tmp_ar->pdev_idx);
+				continue;
+			}
+
+			ring_id = tmp_arvif->ar->ab->hw_params->hw_ops->get_ring_selector(skb);
+
+			if (test_bit(ATH12K_FLAG_RECOVERY, &tmp_ar->ab->dev_flags)) {
+				tmp_ar->ab->soc_stats.bond_tx_mcast_dropped[ring_id]++;
+				break;
+			}
+
+			tmp_ar->ab->soc_stats.bond_tx_mcast_enqueued[ring_id]++;
+			msdu_copied = skb_copy(skb, GFP_ATOMIC);
+			if (!msdu_copied) {
+				tmp_ar->ab->soc_stats.bond_tx_mcast_dropped[ring_id]++;
+				continue;
+			}
+
+			ret = ath12k_mcast_dp_tx(tmp_ar, tmp_arvif, msdu_copied, true, mcbc_gsn);
+			if (ret) {
+				tmp_ar->ab->soc_stats.bond_tx_mcast_dropped[ring_id]++;
+				dev_kfree_skb_any(msdu_copied);
+				continue;
+			}
+		}
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	} else {
+		link_dev = ath12k_mac_get_tx_link_netdev( mldev, eh->h_dest);
+	}
+
+	if (!link_dev) {
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+
+	skb->fast_xmit = 0;
+	return link_dev->netdev_ops->ndo_start_xmit(skb, link_dev);
+}
+
+struct net_device *ath12k_dp_get_mlo_tx_netdev(void *bondctx, u8 *dst_mac_addr)
+{
+	struct ath12k_mld_dev *mldev = (struct ath12k_mld_dev *)bondctx;
+
+	return ath12k_mac_get_tx_link_netdev(mldev, dst_mac_addr);
+}
+
+int ieee80211_link_open(struct net_device *dev)
+{
+	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
+	arvif_pvt->is_started = true;
+	return 0;
+}
+
+int ieee80211_link_stop(struct net_device *dev)
+{
+	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
+	arvif_pvt->is_started = false;
+	return 0;
+}
+
+void ieee80211_link_uninit(struct net_device *dev)
+{
+	return;
+}
+
+static inline void ieee80211_tx_stats_bonded_if(struct net_device *dev, u32 len)
+{
+    struct pcpu_sw_netstats *tstats = this_cpu_ptr(netdev_tstats(dev));
+
+    u64_stats_update_begin(&tstats->syncp);
+    tstats->tx_packets++;
+    tstats->tx_bytes += len;
+    u64_stats_update_end(&tstats->syncp);
+}
+
+netdev_tx_t ieee80211_link_subif_start_xmit_8023(struct sk_buff *skb,
+					    struct net_device *dev)
+{
+	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
+	struct ath12k_link_vif *arvif = arvif_pvt->arvif;
+	struct ath12k_base *ab;
+	int ret;
+	int is_mcast, ring_id = 0;
+	struct ethhdr *eh = NULL;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+
+	ieee80211_tx_stats_bonded_if(dev, skb->len);
+
+	if (!(dev->flags & IFF_UP)) {
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	eh = (struct ethhdr *)skb->data;
+	is_mcast = is_multicast_ether_addr(eh->h_dest);
+	ATH12K_SKB_CB(skb)->link_id = arvif->link_id;
+
+	if (!arvif_pvt->is_started) {
+		ath12k_dbg(NULL, ATH12K_DBG_PPE, "Dropping frames as arvif is not started\n");
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+	if (!arvif || !arvif->is_started) {
+		ath12k_dbg(NULL, ATH12K_DBG_PPE, "Dropping frames as arvif is not started\n");
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+
+	ab = arvif->ar->ab;
+	ring_id = ab->hw_params->hw_ops->get_ring_selector(skb);
+
+	if (test_bit(ATH12K_FLAG_RECOVERY, &ab->dev_flags)) {
+		ath12k_dbg(NULL, ATH12K_DBG_PPE, "Dropping frames as radio is in recovery\n");
+		ab->soc_stats.bond_tx_ucast_dropped[ring_id]++;
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+
+
+	ab->soc_stats.bond_tx_ucast_enqueued[ring_id]++;
+	/* TODO: debug why queue is always 15 */
+	info->hw_queue = 0;
+
+	ret = ath12k_mac_tx_check_max_limit(arvif->ar, skb);
+	if (ret) {
+		ath12k_dbg(arvif->ar->ab, ATH12K_DBG_MAC,
+				"failed fast tx due to limit check pdev idx %d\n",
+				arvif->ar->pdev_idx);
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+
+	ret = ath12k_dp_tx_direct(arvif, skb);
+	if (unlikely(ret)) {
+		ath12k_dbg(ab, ATH12K_DBG_PPE,
+			   "failed to transmit frame %d\n", ret);
+		dev_kfree_skb_any(skb);
+		ab->soc_stats.bond_tx_ucast_dropped[ring_id]++;
+		return NETDEV_TX_OK;
+	}
+	return NETDEV_TX_OK;
+}
+
+void ieee80211_link_set_multicast_list(struct net_device *dev)
+{
+	return;
+}
+
+int ieee80211_link_change_mac(struct net_device *dev, void *addr)
+{
+	return 0;
+}
+
+#if LINUX_VERSION_IS_GEQ(5,2,0)
+u16 ieee80211_link_netdev_select_queue(struct net_device *dev,
+					 struct sk_buff *skb,
+					 struct net_device *sb_dev)
+#elif LINUX_VERSION_IS_GEQ(4,19,0)
+u16 ieee80211_link_netdev_select_queue(struct net_device *dev,
+					 struct sk_buff *skb,
+					 struct net_device *sb_dev,
+					 select_queue_fallback_t fallback)
+#else
+u16 ieee80211_link_netdev_select_queue(struct net_device *dev,
+					 struct sk_buff *skb,
+					 void *accel_priv,
+					 select_queue_fallback_t fallback)
+#endif
+{
+	return smp_processor_id();
+}
+
+void
+ieee80211_link_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
+{
+	dev_fetch_sw_netstats(stats, dev->tstats);
+}
+static const struct net_device_ops ieee80211_link_dataif_8023_ops = {
+	.ndo_open		= ieee80211_link_open,
+	.ndo_stop		= ieee80211_link_stop,
+	.ndo_uninit		= ieee80211_link_uninit,
+	.ndo_start_xmit		= ieee80211_link_subif_start_xmit_8023,
+	.ndo_set_rx_mode	= ieee80211_link_set_multicast_list,
+	.ndo_set_mac_address	= ieee80211_link_change_mac,
+	.ndo_select_queue	= ieee80211_link_netdev_select_queue,
+	.ndo_get_stats64	= ieee80211_link_get_stats64,
+};
+
+int ath12k_free_bonddev_for_sfe(struct wireless_dev *wdev, struct ieee80211_vif *vif, int link_num)
+{
+	struct ath12k_mld_dev *mldev = NULL;
+	struct wireless_dev *dummywdev = NULL;
+	struct wiphy *dummywiphy = NULL;
+	struct net_device *link_ndev = NULL;
+	int ret;
+
+	mutex_lock(&vif->bond_mutex);
+	link_ndev = vif->link_ndev[link_num];
+	if (link_ndev) {
+		ath12k_info(NULL, "Bond_release and Unregister link netdevice %s link ndev %px link_num %d\n", link_ndev->name, link_ndev, link_num);
+		bond_release(wdev->bond_netdev, link_ndev);
+		unregister_netdevice(link_ndev);
+		vif->link_ndev[link_num] = NULL;
+	} else {
+		ath12k_err(NULL, "ERR Free Bond dev for SFE. Unregister link netdevice %s link ndev %px link_num %d\n", link_ndev->name, link_ndev, link_num);
+	}
+	mutex_unlock(&vif->bond_mutex);
+	if (!wdev->bond_netdev) {
+		ath12k_info(NULL, "No bond device exists in the ath12k driver for device. SFE\n");
+		return 0;
+	}
+	mldev = bond_get_mlo_ctx(wdev->bond_netdev);
+	if (!test_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state)) {
+		ath12k_err(NULL, "Bond interface destroyed already. Called for the second time.\n");
+		return 0;
+	}
+
+	dummywiphy = mldev->wdev->wiphy;
+	dummywdev = mldev->wdev;
+
+	/* Returns true on success */
+	ret  = bond_destroy_mlo(wdev->bond_netdev);
+	if (ret) {
+		wdev->bond_netdev = NULL;
+		ath12k_info(NULL,"Successfully destroyed bond device\n");
+	} else {
+		ath12k_err(NULL, "Not able destroy bond device %s ret %d\n", wdev->bond_netdev->name, ret);
+		return -EINVAL;
+	}
+	kfree(dummywdev);
+	wiphy_free(dummywiphy);
+	clear_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state);
+	kfree(mldev);
+	return 0;
+}
+
+extern const struct cfg80211_ops mac80211_dummy_config_ops;
+int ath12k_bond_dev_cb(struct wireless_dev *wdev, struct net_device *dev, bool is_register)
+{
+	struct mlo_bond_info *mlo_info = NULL;
+	struct ath12k_mld_dev *mldev = NULL;
+	struct wireless_dev *dummywdev = NULL;
+	int priv_size = 100;
+	char name[20] = {0};
+	struct wiphy *dummywiphy = NULL;
+	bool ret;
+
+	if (!g_bonded_interface_model)
+		return 0;
+
+	if (is_register) {
+		if (wdev->bond_netdev && test_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state)) {
+			ath12k_info(NULL, "Bond device already registered\n");
+			return 0;
+		}
+		mlo_info = kmalloc(sizeof(struct mlo_bond_info), GFP_KERNEL); //TODO: Free
+		if (!mlo_info) {
+			ath12k_err(NULL, "ERR: Couldn't allocate mlo_info\n");
+			return -ENOMEM;
+		}
+		memset(mlo_info, 0, sizeof(struct mlo_bond_info));
+		mldev = kmalloc(sizeof(struct ath12k_mld_dev), GFP_KERNEL);
+		if (!mldev) {
+			ath12k_err(NULL, "ERR: Couldn't allocate mld_dev\n");
+			kfree(mlo_info);
+			return -ENOMEM;
+		}
+		memset(mldev, 0, sizeof(struct ath12k_mld_dev));
+		dummywdev = kmalloc(sizeof(struct wireless_dev), GFP_KERNEL);
+		if (!mldev) {
+			ath12k_err(NULL, "ERR: Couldn't allocate mld_dev\n");
+			kfree(mlo_info);
+			kfree(mldev);
+			return -ENOMEM;
+		}
+		memset(dummywdev, 0, sizeof(struct wireless_dev));
+		dummywiphy = wiphy_new_nm(&mac80211_dummy_config_ops, priv_size, NULL);
+		if (!dummywiphy) {
+			kfree(mlo_info);
+			kfree(mldev);
+			kfree(dummywdev);
+			return -EINVAL;
+		}
+		dummywiphy->interface_modes = BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_DUMMY);
+		mlo_info->wdev = dummywdev;
+		mldev->wdev = dummywdev;
+		mlo_info->wdev->wiphy = dummywiphy;
+		mlo_info->wdev->iftype = NL80211_IFTYPE_DUMMY;
+		mlo_info->bond_mlo_ctx = (void *)mldev;
+		mlo_info->bond_mlo_xmit_netdev = ath12k_dp_mlo_xmit_netdev;
+		mlo_info->bond_get_mlo_tx_netdev = ath12k_dp_get_mlo_tx_netdev ;
+		snprintf(name, sizeof(name), "%s_b", dev->name);
+		wdev->bond_netdev = bond_create_mlo(&init_net, name, mlo_info);
+
+		if (wdev->bond_netdev) {
+			wdev->bond_netdev->max_mtu = IEEE80211_MAX_DATA_LEN;
+			set_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state);
+			ath12k_info(NULL, "Successfully registered bond_netdev %s for netdevice %s\n", wdev->bond_netdev->name, dev->name);
+		} else {
+			ath12k_err(NULL, "ERR: Unnable to register Bonded interface\n");
+		}
+		kfree(mlo_info);
+	} else {
+		//TODO: Cleanup all objects in the allocation path. dummy wdev, wiphy, mldev
+		if (!wdev->bond_netdev) {
+			ath12k_info(NULL, "No bond device exists in the ath12k driver for device %s\n", dev->name);
+			return 0;
+		}
+		mldev = bond_get_mlo_ctx(wdev->bond_netdev);
+		if (!test_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state)) {
+			ath12k_err(NULL, "bond interface destroyed already. Called for the second time.\n");
+			return 0;
+		}
+
+		dummywiphy = mldev->wdev->wiphy;
+		dummywdev = mldev->wdev;
+
+		/* Returns true on success */
+		ret  = bond_destroy_mlo(wdev->bond_netdev);
+		if (ret) {
+			wdev->bond_netdev = NULL;
+			ath12k_info(NULL,"Successfully destroyed bond device\n");
+		} else {
+			ath12k_err(NULL, "Not able destroy bond device %s ret %d\n", wdev->bond_netdev->name, ret);
+			return -EINVAL;
+		}
+		//TODO: Free mlo_info
+		kfree(dummywdev);
+		wiphy_free(dummywiphy);
+		clear_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state);
+		kfree(mldev);
+	}
+	return 0;
+}
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/bondif.h
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __BONDIF_H
+#define __BONDIF_H
+
+#define MAX_MLO_CHIPS 3
+#define MAX_PDEV_PER_SOC 3
+
+#define ATH12K_PPE_DS_2G_CORE_MASK		0x1
+#define ATH12K_PPE_DS_5G_CORE_MASK		0x2
+#define ATH12K_PPE_DS_6G_CORE_MASK		0x4
+#define ATH12K_PPE_DS_DEFAULT_CORE_MASK		0x7
+
+void ath12k_disable_ppe_for_link_netdev(struct ath12k_link_vif *arvif,
+				       struct net_device *link_dev);
+void ath12k_enable_ppe_for_link_netdev(struct ath12k_link_vif *arvif,
+				     struct net_device *link_dev);
+int ath12k_free_bonddev_for_sfe(struct wireless_dev *wdev,
+				struct ieee80211_vif *vif,
+				int link_num);
+int ath12k_bond_link_add(struct ath12k_link_vif *arvif, struct net_device *link_dev);
+void ath12k_bond_link_delete(struct ath12k_link_vif *arvif);
+enum ath12k_bond_state {
+	ATH12K_BOND_SETUP_INPROGRESS,
+	ATH12K_BOND_REGISTERED,
+	ATH12K_BOND_LINK0_REGISTERED,
+	ATH12K_BOND_LINK1_REGISTERED,
+	ATH12K_BOND_LINK2_REGISTERED,
+
+};
+struct ath12k_mld_dev {
+	struct net_device *netdev;
+	struct ieee80211_vif *vif;
+	struct wireless_dev *wdev; //dummy one for bond registration. Optimize Bond MLO API.
+	struct net_device *link_dev[MAX_MLO_CHIPS][MAX_PDEV_PER_SOC];
+	u8 primary_chipid, primary_pdevid;
+	bool mcast_dev_set;
+	unsigned long bond_state;
+};
+
+#endif //__BONDIF_H
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -291,6 +291,18 @@ struct ath12k_vif_tcl_desc_template {
 	u32 info4;
 };
 
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+struct ath12k_link_vif_pvt {
+        struct ath12k_link_vif *arvif;
+	struct net_device *link_ndev;
+	struct net_device *bond_dev;
+	struct ieee80211_hw *hw;
+	bool is_started;
+	int ppe_vp_profile_idx;
+	int vp_num;
+};
+#endif
+
 struct ath12k_link_vif {
 	struct ath12k_base *ab;
 	struct ath12k_dp *dp;
@@ -345,6 +357,12 @@ struct ath12k_link_vif {
 	u32 tx_vdev_id;
     u8 link_id;
     struct ath12k_vif *ahvif;
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	struct ath12k_link_vif_pvt *ndev_pvt;
+	struct net_device *link_ndev;
+	int ppe_vp_type;
+	int ppe_vp_num;
+#endif
 
 	bool mvr_processing;
 	bool pending_csa_up;
@@ -1094,6 +1112,10 @@ struct ath12k_soc_dp_stats {
 	u32 fw_tx_status[MAX_FW_TX_STATUS];
 	u32 tx_enqueued[MAX_TCL_RING];
 	u32 tx_completed[MAX_TCL_RING];
+	u32 bond_tx_ucast_enqueued[MAX_TCL_RING];
+	u32 bond_tx_mcast_enqueued[MAX_TCL_RING];
+	u32 bond_tx_ucast_dropped[MAX_TCL_RING];
+	u32 bond_tx_mcast_dropped[MAX_TCL_RING];
 	u32 reo_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
 	u32 fast_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
 	u32 non_fast_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
--- a/drivers/net/wireless/ath/ath12k/dp.c
+++ b/drivers/net/wireless/ath/ath12k/dp.c
@@ -21,6 +21,10 @@
 #define ATH12K_DP_LMAC_PEER_ID_MLO	3
 #define ATH12K_DP_PEER_ROUTING_LMAC_ID_MASK	GENMASK(7,6)
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+extern int g_bonded_interface_model;
+#endif
+
 static void ath12k_dp_htt_htc_tx_complete(struct ath12k_base *ab,
 					  struct sk_buff *skb)
 {
@@ -62,6 +66,9 @@ int ath12k_dp_peer_default_route_setup(s
 	u32 reo_dest, param_value;
 	u32 lmac_peer_routing_id = ATH12K_DP_LMAC_PEER_ID_LEGACY;
 	int ret;
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	struct ath12k_vif *ahvif = arvif->ahvif;
+#endif
 
 	sta = container_of((void *)arsta->ahsta, struct ieee80211_sta, drv_priv);
 
@@ -89,7 +96,7 @@ int ath12k_dp_peer_default_route_setup(s
 		   hweight16(sta->valid_links));
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 	/* keep last - override any PPE DS specific routing config */
-	ath12k_dp_peer_ppeds_route_setup(ar, arvif, arsta);
+	if ((ahvif->vdev_type == WMI_VDEV_TYPE_AP) && !((ahvif->vdev_type == WMI_VDEV_TYPE_AP) && (ahvif->vdev_subtype == WMI_VDEV_SUBTYPE_MESH_11S)))
 #endif
 
 	return 0;
@@ -540,6 +547,9 @@ void ath12k_dp_tx_update_bank_profile(st
 	arvif->bank_id = ath12k_dp_tx_get_bank_profile(ab, arvif, dp);
 	arvif->desc.info0 = FIELD_PREP(HAL_TCL_DATA_CMD_INFO0_BANK_ID,
 				       arvif->bank_id);
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	ath12k_dp_ppeds_update_vp_entry(arvif->ar, arvif);
+#endif
 }
 
 static void ath12k_dp_deinit_bank_profiles(struct ath12k_base *ab)
@@ -1198,11 +1208,15 @@ static void ath12k_dp_mon_reap_timer_ini
 	timer_setup(&ab->mon_reap_timer, ath12k_dp_service_mon_ring, 0);
 }
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
 static int ath12k_dp_ppe_rxole_rxdma_cfg(struct ath12k_base *ab)
 {
 	struct ath12k_dp_htt_rxdma_ppe_cfg_param param = {0};
 	int ret;
 
+	if (!g_bonded_interface_model)
+		return 0;
+
 	param.override = 1;
 	param.reo_dst_ind = HAL_REO2PPE_DST_IND;
 	param.multi_buffer_msdu_override_en = 0;
@@ -1219,6 +1233,7 @@ static int ath12k_dp_ppe_rxole_rxdma_cfg
 
 	return ret;
 }
+#endif
 
 int ath12k_dp_pdev_alloc(struct ath12k_base *ab)
 {
@@ -1226,12 +1241,14 @@ int ath12k_dp_pdev_alloc(struct ath12k_b
 	int ret;
 	int i;
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
 	ret = ath12k_dp_ppe_rxole_rxdma_cfg(ab);
 	if (ret) {
 		ath12k_err(ab, "Failed to send htt RxOLE and RxDMA messages to target :%d\n",
 			   ret);
 		goto out;
 	}
+#endif
 
 	ret = ath12k_dp_rx_htt_setup(ab);
 	if (ret)
@@ -1340,6 +1357,10 @@ void ath12k_dp_vdev_tx_attach(struct ath
 		ath12k_err(ar->ab, "Failed to initialize DP TX Banks");
 		return;
 	}
+
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	ath12k_dp_ppeds_update_vp_entry(ar, arvif);
+#endif
 }
 
 static void ath12k_dp_cc_cleanup(struct ath12k_base *ab)
--- a/drivers/net/wireless/ath/ath12k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.c
@@ -2757,6 +2757,10 @@ static bool ath12k_dp_rx_check_fast_rx(s
 	if (is_multicast_ether_addr(ehdr->h_dest))
 	        return false;
 
+	/* TODO: make use of hw assisted intra-bss bit in msdu_end
+	 * to skip peer lookup and forward frames directly.
+	 */
+
 	/* check if the msdu needs to be bridged to our connected peer */
 	f_peer = ath12k_peer_find_by_addr(ar->ab, ehdr->h_dest);
 
@@ -2784,10 +2788,14 @@ static void ath12k_dp_rx_h_mpdu(struct a
 	struct ath12k_dp_rx_tid *rx_tid;
 	u32 err_bitmap;
 	u8 tid;
-#ifdef CPTCFG_MAC80211_PPE_SUPPORT
+#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_BONDED_DS_SUPPORT)
 	int vp;
 #endif
 	struct wireless_dev *wdev = NULL;
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	struct ath12k_vif *ahvif;
+	struct ath12k_link_vif *arvif;
+#endif
 
 	tid = ath12k_dp_rx_h_tid(ab, rx_desc);
 	/* PN for multicast packets will be checked in mac80211 */
@@ -2818,8 +2826,16 @@ static void ath12k_dp_rx_h_mpdu(struct a
 #endif
 				spin_unlock_bh(&ar->ab->base_lock);
 				ath12k_dp_rx_h_csum_offload(ar, msdu);
-				msdu->dev = wdev->netdev;
-#ifdef CPTCFG_MAC80211_PPE_SUPPORT
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+				ahvif = ath12k_vif_to_ahvif(peer->vif)
+				arvif = ahvif->link[peer->link_id];
+				vp = arvif->ppe_vp_num;
+				if (wdev->bond_netdev)
+					msdu->dev = wdev->bond_netdev;
+				else
+#endif
+					msdu->dev = wdev->netdev;
+#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_BONDED_DS_SUPPORT)
 				if (vp > 0) {
 					if (likely(ppe_vp_tx_to_ppe(vp, msdu)))
 						return;
@@ -2839,6 +2855,14 @@ static void ath12k_dp_rx_h_mpdu(struct a
 	}
 	spin_unlock_bh(&ar->ab->base_lock);
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	if (peer) {
+		wdev = ieee80211_vif_to_wdev(peer->vif);
+		if (wdev && wdev->bond_netdev)
+			msdu->dev = wdev->bond_netdev;
+	}
+#endif
+
 	*fast_rx = false;
 
 	err_bitmap = ath12k_dp_rx_h_mpdu_err(ab, rx_desc);
--- a/drivers/net/wireless/ath/ath12k/dp_tx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_tx.c
@@ -272,6 +272,7 @@ int ath12k_dp_tx_direct(struct ath12k_li
 	u8 hal_ring_id, ring_id;
 	dma_addr_t paddr;
 	int ret;
+	int len = skb->fast_xmit ? 256 : skb->len;
 
 	ring_id = smp_processor_id();
 
@@ -283,8 +284,8 @@ int ath12k_dp_tx_direct(struct ath12k_li
 		return -ENOSPC;
 	}
 
-	dmac_clean_range_no_dsb(skb->data, skb->data + 256);
-	paddr = dma_map_single_attrs(dev, skb->data, 256,
+	dmac_clean_range_no_dsb(skb->data, skb->data + len);
+	paddr = dma_map_single_attrs(dev, skb->data, len,
 				     DMA_TO_DEVICE, DMA_ATTR_SKIP_CPU_SYNC);
 	if (unlikely(dma_mapping_error(dev, paddr))) {
 		atomic_inc(&ab->soc_stats.tx_err.misc_fail);
@@ -307,7 +308,7 @@ int ath12k_dp_tx_direct(struct ath12k_li
 
 	hal_ring_id = ring_id + HAL_SRNG_RING_ID_SW2TCL1;
 	tcl_ring = &ab->hal.srng_list[hal_ring_id];
-
+	spin_lock_bh(&tcl_ring->lock);
 	ath12k_hal_srng_access_src_ring_begin_nolock(tcl_ring);
 
 	hal_tcl_desc = (void *)ath12k_hal_srng_src_get_next_entry_nolock(ab, tcl_ring);
@@ -316,6 +317,7 @@ int ath12k_dp_tx_direct(struct ath12k_li
 		 * desc because the desc is directly enqueued onto hw queue.
 		 */
 		ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+		spin_unlock_bh(&tcl_ring->lock);
 		ab->soc_stats.tx_err.desc_na[ring_id]++;
 		ret = -ENOMEM;
 		goto fail_unmap_dma;
@@ -351,6 +353,7 @@ int ath12k_dp_tx_direct(struct ath12k_li
 	memcpy(hal_tcl_desc, &tcl_desc, sizeof(tcl_desc));
 	dsb(st);
 	ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+	spin_unlock_bh(&tcl_ring->lock);
 
 	atomic_inc(&ar->dp.num_tx_pending);
 
@@ -592,7 +595,7 @@ int ath12k_dp_tx(struct ath12k *ar, stru
 
 	hal_ring_id = tx_ring->tcl_data_ring.ring_id;
 	tcl_ring = &ab->hal.srng_list[hal_ring_id];
-
+	spin_lock_bh(&tcl_ring->lock);
 	ath12k_hal_srng_access_src_ring_begin_nolock(tcl_ring);
 	hal_tcl_desc = ath12k_hal_srng_src_get_next_entry(ab, tcl_ring);
 	if (unlikely(!hal_tcl_desc)) {
@@ -600,6 +603,7 @@ int ath12k_dp_tx(struct ath12k *ar, stru
 		 * desc because the desc is directly enqueued onto hw queue.
 		 */
 		ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+		spin_unlock_bh(&tcl_ring->lock);
 		ab->soc_stats.tx_err.desc_na[ti.ring_id]++;
 		ret = -ENOMEM;
 
@@ -638,6 +642,7 @@ int ath12k_dp_tx(struct ath12k *ar, stru
 
 	dsb(st);
 	ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+	spin_unlock_bh(&tcl_ring->lock);
 
 	ath12k_dbg_dump(ab, ATH12K_DBG_DP_TX, NULL, "dp tx msdu: ",
 			skb->data, skb->len);
@@ -1169,6 +1174,70 @@ static inline bool ath12k_dp_tx_completi
 }
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+static void ath12k_ppeds_tx_update_stats(struct ath12k *ar, struct sk_buff *msdu,
+					 struct hal_wbm_release_ring *tx_status)
+{
+	struct ath12k_base *ab = ar->ab;
+	struct ieee80211_tx_info *info;
+	struct ath12k_peer *peer;
+	struct ath12k_link_sta *arsta;
+	struct hal_tx_status ts = { 0 };
+
+	info = IEEE80211_SKB_CB(msdu);
+	memset(&info->status, 0, sizeof(info->status));
+	info->status.rates[0].idx = -1;
+
+	ath12k_dp_tx_status_parse(ab, tx_status, &ts);
+	if (ts.status == HAL_WBM_TQM_REL_REASON_FRAME_ACKED &&
+	    !(info->flags & IEEE80211_TX_CTL_NO_ACK)) {
+		info->flags |= IEEE80211_TX_STAT_ACK;
+		info->status.ack_signal = ATH12K_DEFAULT_NOISE_FLOOR +
+					  ts.ack_rssi;
+		info->status.flags = IEEE80211_TX_STATUS_ACK_SIGNAL_VALID;
+	}
+
+	if (ts.status == HAL_WBM_TQM_REL_REASON_CMD_REMOVE_TX &&
+	    (info->flags & IEEE80211_TX_CTL_NO_ACK))
+		info->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;
+
+	if (ts.status != HAL_WBM_TQM_REL_REASON_FRAME_ACKED) {
+		switch (ts.status) {
+		case HAL_WBM_TQM_REL_REASON_CMD_REMOVE_MPDU:
+		case HAL_WBM_TQM_REL_REASON_DROP_THRESHOLD:
+		case HAL_WBM_TQM_REL_REASON_CMD_REMOVE_AGED_FRAMES:
+		case HAL_WBM_TQM_REL_REASON_CMD_REMOVE_TX:
+			return;
+		default:
+			//TODO: Remove this print and add as a stats
+			ath12k_dbg(ab, ATH12K_DBG_DP_TX, "tx frame is not acked status %d\n", ts.status);
+		}
+	}
+
+	spin_lock_bh(&ab->base_lock);
+
+	peer = ath12k_peer_find_by_id(ab, ts.peer_id);
+	if (unlikely(!peer || !peer->sta)) {
+		ath12k_dbg(ab, ATH12K_DBG_DATA,
+			   "dp_tx: failed to find the peer with peer_id %d\n",
+			   ts.peer_id);
+		spin_unlock_bh(&ab->base_lock);
+		return;
+	}
+
+	arsta = ath12k_peer_get_link_sta(ab, peer);
+	if (!arsta) {
+		ath12k_warn(ab, "link sta not found on peer %pM id %d\n",
+			    peer->addr, peer->peer_id);
+		spin_unlock_bh(&ab->base_lock);
+		return;
+	}
+
+	ieee80211_ppeds_tx_update_stats(ar->ah->hw, peer->sta, info, arsta->txrate,
+					peer->link_id, msdu->len);
+
+	spin_unlock_bh(&ab->base_lock);
+}
+
 static inline
 void ath12k_dp_ppeds_tx_comp_get_desc(struct ath12k_base *ab,
 				      struct hal_wbm_completion_ring_tx *tx_status,
@@ -1260,6 +1329,10 @@ int ath12k_ppeds_tx_completion_handler(s
 
 		mac_id = tx_desc->mac_id;
 
+		if (unlikely(!ab->stats_disable))
+			ath12k_ppeds_tx_update_stats(ab->pdevs[mac_id].ar, tx_desc->skb,
+						     tx_status);
+
 		/* Release descriptor as soon as extracting necessary info
 		 * to reduce contention
 		 */
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -23,7 +23,9 @@
 #include "testmode.h"
 #include "peer.h"
 #include "debugfs_sta.h"
-#include "ppe.h"
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+#include "bondif.h"
+#endif
 
 #define CHAN2G(_channel, _freq, _flags) { \
 	.band                   = NL80211_BAND_2GHZ, \
@@ -54,6 +56,14 @@
 
 static void ath12k_mac_remove_link_interface(struct ieee80211_hw *hw,
 					     struct ath12k_link_vif *arvif);
+
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif,
+					  u16 old_links, u16 new_links,
+					  struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS]);
+extern int g_bonded_interface_model;
+#endif
 static const struct ieee80211_channel ath12k_2ghz_channels[] = {
 	CHAN2G(1, 2412, 0),
 	CHAN2G(2, 2417, 0),
@@ -4816,8 +4826,14 @@ static int ath12k_mac_vdev_delete(struct
 	arvif->is_created = false;
 
 clean_up:
-	arvif->ar = NULL;
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	if (arvif->link_id != ATH12K_DEFAULT_SCAN_LINK && arvif->ndev_pvt) {
+		ath12k_bond_link_delete(arvif);
+		ath12k_disable_ppe_for_link_netdev(arvif, arvif->ndev_pvt->link_ndev);
+	}
+#endif
 
+	arvif->ar = NULL;
 	spin_lock_bh(&ar->data_lock);
 	list_del(&arvif->list);
 	spin_unlock_bh(&ar->data_lock);
@@ -4865,7 +4881,7 @@ void ath12k_mac_unassign_link_vif(struct
 		kfree(arvif);
 }
 
-static struct ath12k_link_vif *
+struct ath12k_link_vif *
 ath12k_mac_assign_link_vif( struct ath12k_hw *ah, struct ieee80211_vif *vif, u8 link_id)
 {
 	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
@@ -5211,8 +5227,10 @@ static int ath12k_mac_op_hw_scan(struct
 	 * delete-create vdev's for the same ar, in case the request is
 	 * always on the same band for the vif
 	 */
-	if (!arvif)
+	if (!arvif) {
+		mutex_unlock(&ah->conf_mutex);
 		return -ENOMEM;
+	}
 
 	if (arvif->is_created) {
 		if (ar != arvif->ar && arvif->is_started) {
@@ -6173,6 +6191,15 @@ static int ath12k_station_assoc(struct a
 		return ret;
 	}
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	ret = ath12k_wmi_set_peer_intra_bss_cmd(ar, arvif->vdev_id, arsta->addr, 1);
+	if (ret) {
+		ath12k_warn(ar->ab, "failed to set vdev %i intra bss enable: %d\n",
+			    arvif->vdev_id, ret);
+		return ret;
+	}
+#endif
+
 	if (!sta->wme) {
 		arvif->num_legacy_stations++;
 		ret = ath12k_recalc_rtscts_prot(arvif);
@@ -8873,6 +8900,16 @@ static int ath12k_mac_config_mon_status_
 		tlv_filter = ath12k_mac_mon_status_filter_default;
 		if (ath12k_debugfs_rx_filter(ar))
 			tlv_filter.rx_filter = ath12k_debugfs_rx_filter(ar);
+
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+			if (g_bonded_interface_model &&
+			    test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ar->ab->dev_flags))
+				tlv_filter.rx_filter |= (HTT_RX_FILTER_TLV_FLAGS_PPDU_START |
+							 HTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS |
+							 HTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS_EXT |
+							 HTT_RX_FILTER_TLV_FLAGS_PPDU_START_USER_INFO);
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
+
 	}
 
 	tlv_filter.offset_valid = false;
@@ -9498,6 +9535,13 @@ static void ath12k_mac_update_vif_offloa
 		vif->offload_flags &= ~(IEEE80211_OFFLOAD_ENCAP_ENABLED |
 					IEEE80211_OFFLOAD_DECAP_ENABLED);
 
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	if (vif->type == NL80211_IFTYPE_AP && arvif->ndev_pvt
+			&& (hweight16(vif->valid_links) > 1))
+		vif->offload_flags |= (IEEE80211_OFFLOAD_ENCAP_ENABLED |
+					IEEE80211_OFFLOAD_DECAP_ENABLED);
+#endif
+
 	if (vif->offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)
 		ahvif->tx_encap_type = ATH12K_HW_TXRX_ETHERNET;
 	else if (test_bit(ATH12K_FLAG_RAW_MODE, &ag->dev_flags))
@@ -9608,6 +9652,11 @@ static int ath12k_mac_vdev_create(struct
 	struct ath12k_wmi_peer_create_arg peer_param = {0};
 	struct ieee80211_bss_conf *link_conf;
 	u32 param_id, param_value;
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
+	struct net_device *link_ndev = NULL;
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+#endif
 	u16 nss;
 	int i;
 	int ret, fbret, vdev_id;
@@ -9674,6 +9723,16 @@ static int ath12k_mac_vdev_create(struct
 	arvif->dp = &ab->dp;
 	arvif->dev = ab->dev;
 	arvif->pdev_idx = ar->pdev_idx;
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	if (arvif->link_id != ATH12K_DEFAULT_SCAN_LINK) {
+		link_ndev = vif->link_ndev[link_id];
+		if (link_ndev) {
+			link_ndev_pvt = netdev_priv(link_ndev);
+			link_ndev_pvt->arvif = arvif;
+			arvif->ndev_pvt = link_ndev_pvt;
+		}
+	}
+#endif
 
 	switch (vif->type) {
 	case NL80211_IFTYPE_UNSPECIFIED:
@@ -9765,6 +9824,20 @@ static int ath12k_mac_vdev_create(struct
 				    arvif->vdev_id, ret);
 			goto err_peer_del;
 		}
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+		if (arvif->link_id != ATH12K_DEFAULT_SCAN_LINK) {
+			if (hweight16(vif->valid_links) <= 1) {
+				ath12k_free_bonddev_for_sfe(wdev, vif, link_id);
+				arvif->ndev_pvt = NULL;
+				arvif->ppe_vp_num = -1;
+			}
+			else if (link_ndev) {
+				ath12k_enable_ppe_for_link_netdev(arvif,
+								 arvif->ndev_pvt->link_ndev);
+				ath12k_bond_link_add(arvif, arvif->ndev_pvt->link_ndev);
+			}
+		}
+#endif
 		break;
 	case WMI_VDEV_TYPE_STA:
 		param_id = WMI_STA_PS_PARAM_RX_WAKE_POLICY;
@@ -9833,6 +9906,16 @@ static int ath12k_mac_vdev_create(struct
 	    test_bit(MONITOR_CONF_ENABLED, &ar->monitor_flags))
 		ath12k_mac_monitor_vdev_create(ar);
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	ret = ath12k_wmi_send_vdev_set_intra_bss_cmd(ar, arvif->vdev_id,
+						     1);
+	if (ret) {
+		ath12k_warn(ab, "failed to set vdev %d intra bss enable :%d\n",
+			    arvif->vdev_id, ret);
+		goto err_peer_del;
+	}
+#endif
+
 	ret = ath12k_debugfs_add_interface(arvif);
 	if (ret)
 		goto err_peer_del;
@@ -10352,15 +10435,17 @@ static int ath12k_mac_op_ampdu_action(st
 	return ret;
 }
 
-static int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
-					  struct ieee80211_vif *vif,
-					  u16 old_links, u16 new_links,
-					  struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
+#ifndef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   u16 old_links, u16 new_links,
+				   struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
 {
 	ath12k_info(NULL,
 		    "link changed for MLD %pM old %d new %d\n", vif->addr, old_links, new_links);
 	return 0;
 }
+#endif
 
 static int ath12k_mac_op_add_chanctx(struct ieee80211_hw *hw,
 				     struct ieee80211_chanctx_conf *ctx)
@@ -12178,6 +12263,7 @@ ath12k_mac_op_assign_vif_chanctx(struct
 	arvif = ath12k_mac_assign_link_vif(ah, vif, link_id);
 	if (!arvif) {
 		ath12k_err(NULL, "unable to allocate link vif\n");
+		mutex_unlock(&ah->conf_mutex);
 		return -ENOMEM;
 	}
 
@@ -14198,10 +14284,6 @@ static const struct ieee80211_ops ath12k
 #endif
 	.get_txpower			= ath12k_mac_op_get_txpower,
 	.set_radar_background		= ath12k_mac_op_set_radar_background,
-#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	.ppeds_attach_vdev		= ath12k_mac_op_ppeds_attach_vdev,
-	.ppeds_detach_vdev		= ath12k_mac_op_ppeds_detach_vdev,
-#endif
 };
 
 static void ath12k_mac_update_ch_list(struct ath12k *ar,
@@ -15393,6 +15475,9 @@ int ath12k_mac_allocate(struct ath12k_hw
 			goto err_mac_destroy;
 		}
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+		ieee80211_enable_bond_dev(hw);
+#endif
 		ah = hw->priv;
 		ah->hw = hw;
 		ah->ops = ops;
--- a/drivers/net/wireless/ath/ath12k/pci.c
+++ b/drivers/net/wireless/ath/ath12k/pci.c
@@ -65,6 +65,15 @@ EXPORT_SYMBOL(ath12k_napi_poll_budget);
 module_param_named(napi_budget, ath12k_napi_poll_budget, uint, 0644);
 MODULE_PARM_DESC(napi_budget, "Napi budget processing per rx intr");
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+extern int ath12k_mlo_capable;
+extern int g_bonded_interface_model;
+extern unsigned int ath12k_ppe_ds_enabled;
+
+extern int ath12k_bond_dev_cb(struct wireless_dev *wdev, struct net_device *dev, bool is_register);
+extern int (*driver_bond_dev_cb)(struct wireless_dev *wdev, struct net_device *dev, bool is_register);
+#endif
+
 static const struct pci_device_id ath12k_pci_id_table[] = {
 	{ PCI_VDEVICE(QCOM, QCN9274_DEVICE_ID) },
 	{ PCI_VDEVICE(QCOM, WCN7850_DEVICE_ID) },
@@ -1387,7 +1396,25 @@ static int ath12k_pci_probe(struct pci_d
 	u32 soc_hw_version_major, soc_hw_version_minor;
 	u32 addr;
 	int ret;
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	if (ath12k_frame_mode == ATH12K_HW_TXRX_RAW ||
+	    ath12k_frame_mode == ATH12K_HW_TXRX_NATIVE_WIFI) {
+		ath12k_mlo_capable = 1;
+	}
 
+	if (ath12k_mlo_capable == 2) {
+		ath12k_mlo_capable = 1;
+		g_bonded_interface_model = ath12k_mlo_capable;
+		ath12k_ppe_ds_enabled = 1;
+		driver_bond_dev_cb = ath12k_bond_dev_cb;
+	} else if (ath12k_mlo_capable == 1 && g_bonded_interface_model != 1) {
+		g_bonded_interface_model = 0;
+		driver_bond_dev_cb = NULL;
+	}
+
+
+	ath12k_info(NULL, "g_bonded_interface_model %d ath12k_mlo_capable %d \n", g_bonded_interface_model, ath12k_mlo_capable);
+#endif
 	ab = ath12k_core_alloc(&pdev->dev, sizeof(*ab_pci), ATH12K_BUS_PCI,
 			       &ath12k_pci_bus_params);
 	if (!ab) {
@@ -1629,4 +1656,8 @@ int ath12k_pci_init(void)
 void ath12k_pci_exit(void)
 {
 	pci_unregister_driver(&ath12k_pci_driver);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	g_bonded_interface_model = 0;
+	driver_bond_dev_cb = NULL;
+#endif
 }
--- a/drivers/net/wireless/ath/ath12k/ppe.c
+++ b/drivers/net/wireless/ath/ath12k/ppe.c
@@ -13,6 +13,7 @@
 #include <ppe_drv_sc.h>
 #include <linux/dma-mapping.h>
 #include <asm/cacheflush.h>
+#include <net/bonding.h>
 #include "hif.h"
 #include "ppe.h"
 
@@ -430,14 +431,49 @@ void ath12k_dp_peer_ppeds_route_setup(st
 				      struct ath12k_link_sta *arsta)
 {
 	struct ath12k_base *ab = ar->ab;
+	struct ath12k_link_vif *primary_link_arvif;
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	u32 service_code = PPE_DRV_SC_SPF_BYPASS;
 	int ppe_routing_enable = 1;
-	u32 priority_valid = 0, src_info = arvif->vif->ppe_vp_num;
+	u32 priority_valid = 0, src_info = arvif->ppe_vp_num;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
 
-	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags) ||
-	    src_info == -1)
+	if (!g_bonded_interface_model)
 		return;
 
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	/* In SLO AP, DS is not supported */
+	if (hweight16(ahvif->vif->valid_links) <= 1)
+ 		return;
+
+	/* When SLO STA is associated to AP link vif which does not have DS rings,
+ 	 * do not enable DS.
+	 */
+	if (!sta->mlo && !test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
+		return;
+
+	/* If STA is MLO capable but primary link does not support DS,
+	 * disable DS routing on RX.
+	 */
+	if (sta->mlo) {
+		primary_link_arvif = arvif->ahvif->link[ahsta->assoc_link_id];
+
+		if (primary_link_arvif->ppe_vp_num == -1 ||
+		    primary_link_arvif->ppe_vp_type != PPE_VP_USER_TYPE_DS) {
+			ath12k_info(ab,
+				    "Primary link %d does not support DS "
+				    "Disabling DS routing on RX for peer %pM\n",
+				    ahsta->assoc_link_id, arsta->addr);
+			return;
+		}
+
+		if (arvif->ppe_vp_num == -1 ||
+		    arvif->ppe_vp_type != PPE_VP_USER_TYPE_DS)
+			src_info = primary_link_arvif->ppe_vp_num;
+	}
+
 	ath12k_wmi_config_peer_ppeds_routing(ar, arsta->addr, arvif->vdev_id,
 			service_code, priority_valid, src_info,
 			ppe_routing_enable);
@@ -455,8 +491,6 @@ static int ath12k_dp_ppeds_alloc_ppe_vp_
 		return -ENOSR;
 	}
 
-	ab->num_ppe_vp_profiles++;
-
 	for (i = 0; i < PPE_VP_ENTRIES_MAX; i++) {
 		if (!ab->dp.ppe_vp_profile[i].is_configured)
 			break;
@@ -464,8 +498,10 @@ static int ath12k_dp_ppeds_alloc_ppe_vp_
 
 	if (i == PPE_VP_ENTRIES_MAX) {
 		WARN_ONCE(1, "All ppe vp profile entries are in use!");
+		mutex_unlock(&ab->ppe_vp_tbl_lock);
 		return -ENOSR;
 	}
+	ab->num_ppe_vp_profiles++;
 
 	ab->dp.ppe_vp_profile[i].is_configured = true;
 	*vp_profile = &ab->dp.ppe_vp_profile[i];
@@ -507,8 +543,6 @@ static int ath12k_dp_ppeds_alloc_vp_tbl_
 		return -ENOSR;
 	}
 
-	ab->num_ppe_vp_entries++;
-
 	for (i = 0; i < PPE_VP_ENTRIES_MAX; i++) {
 		if (!ab->ppe_vp_tbl_registered[i])
 			break;
@@ -519,7 +553,8 @@ static int ath12k_dp_ppeds_alloc_vp_tbl_
 		return -ENOSR;
 	}
 
-	ab->ppe_vp_tbl_registered[i] = true;
+	ab->num_ppe_vp_entries++;
+	ab->ppe_vp_tbl_registered[i] = 1;
 	mutex_unlock(&ab->ppe_vp_tbl_lock);
 
 	return i;
@@ -544,7 +579,7 @@ static void ath12k_dp_ppeds_dealloc_vp_t
 		return;
 	}
 
-	ab->ppe_vp_tbl_registered[ppe_vp_num_idx] = false;
+	ab->ppe_vp_tbl_registered[ppe_vp_num_idx] = 0;
 	ab->num_ppe_vp_entries--;
 	mutex_unlock(&ab->ppe_vp_tbl_lock);
 }
@@ -560,7 +595,6 @@ static int ath12k_dp_ppeds_alloc_vp_sear
 		return -ENOSR;
 	}
 
-	ab->num_ppe_vp_search_idx_entries++;
 
 	for (i = 0; i < PPE_VP_ENTRIES_MAX; i++) {
 		if (!ab->ppe_vp_search_idx_tbl_set[i])
@@ -572,7 +606,8 @@ static int ath12k_dp_ppeds_alloc_vp_sear
 		return -ENOSR;
 	}
 
-	ab->ppe_vp_search_idx_tbl_set[i] = true;
+	ab->num_ppe_vp_search_idx_entries++;
+	ab->ppe_vp_search_idx_tbl_set[i] = 1;
 	mutex_unlock(&ab->ppe_vp_tbl_lock);
 
 	return i;
@@ -596,7 +631,7 @@ ath12k_dp_ppeds_dealloc_vp_search_idx_tb
 		return;
 	}
 
-	ab->ppe_vp_search_idx_tbl_set[ppe_vp_search_idx] = false;
+	ab->ppe_vp_search_idx_tbl_set[ppe_vp_search_idx] = 0;
 	ab->num_ppe_vp_search_idx_entries--;
 	mutex_unlock(&ab->ppe_vp_tbl_lock);
 
@@ -639,38 +674,65 @@ static void ath12k_dp_ppeds_setup_vp_ent
 	return;
 }
 
-int ath12k_mac_op_ppeds_attach_vdev(struct ieee80211_hw *hw,
-				struct ieee80211_vif *vif,
+void ath12k_dp_ppeds_update_vp_entry(struct ath12k *ar,
+				     struct ath12k_link_vif *arvif)
+{
+	struct ath12k_base *ab = ar->ab;
+	struct ath12k_link_vif_pvt *link_ndev_pvt = arvif->ndev_pvt;
+	struct ath12k_dp_ppe_vp_profile *vp_profile;
+	int ppe_vp_profile_idx;
+
+	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
+		return;
+
+	if (!ab->ppeds_handle) {
+		ath12k_dbg(ab, ATH12K_DBG_PPE, "DS not enabled on this chip\n");
+		return;
+	}
+
+	if (!link_ndev_pvt) {
+		ath12k_dbg(ab, ATH12K_DBG_PPE, "link netdevice not present for arvif\n");
+		return;
+	}
+
+	ppe_vp_profile_idx = link_ndev_pvt->ppe_vp_profile_idx;
+	vp_profile = &ab->dp.ppe_vp_profile[ppe_vp_profile_idx];
+	if (!vp_profile) {
+		ath12k_dbg(ab, ATH12K_DBG_PPE, "vp profile not present for arvif\n");
+		return;
+	}
+
+	ath12k_dp_ppeds_setup_vp_entry(ab, arvif->ar, arvif, vp_profile);
+}
+
+int ath12k_mac_op_ppeds_attach_vdev(struct ath12k_link_vif *arvif,
 				void *vp_arg, int *ppe_vp_num,
 				struct ieee80211_ppe_vp_ds_params *vp_params)
 {
-	struct ath12k_hw *ah = hw->priv;
-	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
 	//TODO: handle MLO
-	struct ath12k_link_vif *arvif = &ahvif->link[0];
-	struct ath12k *ar = ah->radio;
+	struct ath12k *ar = arvif->ar;
 	//TODO: Handle split phy
 	struct ath12k_base *ab = ar->ab;
 	struct ath12k_dp_ppe_vp_profile *vp_profile = NULL;
-	int ppe_vp_profile_idx, ppe_vp_idx, vp_num;
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+	int ppe_vp_profile_idx, ppe_vp_tbl_idx, vp_num;
 	int ppe_vp_search_tbl_idx = -1;
 	int vdev_id = arvif->vdev_id;
 	int ret;
 
-	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags)) {
-		ppe_vp_num = -1;
+	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return -ENOSR;
-	}
 
 	if (!ab->ppeds_handle) {
 		ath12k_err(ab, "DS not enabled on this chip\n");
 		return -EINVAL;
 	}
 
-	if (vif->type != NL80211_IFTYPE_AP) {
+	if (arvif->ahvif->vif->type != NL80211_IFTYPE_AP) {
 		return -EINVAL;
 	}
 
+	link_ndev_pvt = netdev_priv(vp_params->dev);
 	vp_num = ppe_ds_wlan_vp_alloc(ab->ppeds_handle, vp_params->dev, vp_arg);
 	if (vp_num < 0) {
 		ath12k_err(ab," vp alloc failed\n");
@@ -685,14 +747,14 @@ int ath12k_mac_op_ppeds_attach_vdev(stru
 		goto vp_free;
 	}
 
-	ppe_vp_idx = ath12k_dp_ppeds_alloc_vp_tbl_entry(ab);
-	if (ppe_vp_idx < 0) {
+	ppe_vp_tbl_idx = ath12k_dp_ppeds_alloc_vp_tbl_entry(ab);
+	if (ppe_vp_tbl_idx < 0) {
 		ath12k_err(ab, "Failed to allocate PPE VP idx for vdev_id:%d", vdev_id);
 		ret = -ENOSR;
 		goto dealloc_vp_profile;
 	}
 
-	if (vif->type == NL80211_IFTYPE_STATION) {
+	if (arvif->ahvif->vif->type == NL80211_IFTYPE_STATION) {
 		ppe_vp_search_tbl_idx = ath12k_dp_ppeds_alloc_vp_search_idx_tbl_entry(ab);
 		if (ppe_vp_search_tbl_idx < 0) {
 			ath12k_err(ab,
@@ -704,19 +766,23 @@ int ath12k_mac_op_ppeds_attach_vdev(stru
 	}
 
 	vp_profile->vp_num = vp_num;
-	vp_profile->ppe_vp_num_idx = ppe_vp_idx;
+	vp_profile->ppe_vp_num_idx = ppe_vp_tbl_idx;
 	vp_profile->to_fw = 0;
 	vp_profile->use_ppe_int_pri = 0;
 	vp_profile->drop_prec_enable = 0;
+	vp_profile->arvif = arvif;
 
 	/* For the sta mode fill up the index reg number */
 	ath12k_dp_ppeds_setup_vp_entry(ab, ar, arvif, vp_profile);
 
 	vp_params->ppe_vp_profile_idx = ppe_vp_profile_idx;
 	*ppe_vp_num = vp_num;
-	ath12k_dbg(ab, ATH12K_DBG_PPE,
-		   "PPEDS vdev attach success vpnum %d ppe_vp_idx %d ppe_vp_profile_idx %d\n",
-		   vp_num, ppe_vp_idx, ppe_vp_profile_idx);
+	ath12k_info(ab,
+		   "PPEDS vdev attach success chip_id %d vdev_id %d vpnum %d ppe_vp_profile_idx %d"
+		   "ppe_vp_tbl_idx %d to_fw %d int_pri %d prec_en %d search_idx_reg_num %d\n",
+		   ab->chip_id, vdev_id, vp_num, ppe_vp_profile_idx, ppe_vp_tbl_idx, vp_profile->to_fw,
+		   vp_profile->use_ppe_int_pri, vp_profile->drop_prec_enable,
+		   vp_profile->search_idx_reg_num);
 
 	return 0;
 
@@ -730,22 +796,17 @@ vp_free:
 	return ret;
 }
 
-void ath12k_mac_op_ppeds_detach_vdev(struct ieee80211_hw *hw,
-				     struct ieee80211_vif *vif,
+void ath12k_mac_op_ppeds_detach_vdev(struct ath12k_link_vif *arvif,
 				     struct ieee80211_ppe_vp_ds_params *vp_params)
 {
-	struct ath12k_hw *ah = hw->priv;
-	struct ath12k *ar = ah->radio;
+	struct ath12k *ar = arvif->ar;
 	struct ath12k_base *ab = ar->ab;
-	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
-	struct ath12k_link_vif *arvif = &ahvif->link[0];
 	struct ath12k_dp_ppe_vp_profile *vp_profile;
 	int ppe_vp_profile_idx = -1;
 
 	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return;
 
-	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS vdev detach\n");
 	ppe_vp_profile_idx = vp_params->ppe_vp_profile_idx;
 
 	vp_profile = &ab->dp.ppe_vp_profile[ppe_vp_profile_idx];
@@ -759,7 +820,7 @@ void ath12k_mac_op_ppeds_detach_vdev(str
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "ppe_ds_wlan_vp_free\n");
 
 	/* For STA mode ast index table reg also needs to be cleaned */
-	if (vif->type == NL80211_IFTYPE_STATION)
+	if (arvif->ahvif->vif->type == NL80211_IFTYPE_STATION)
 		ath12k_dp_ppeds_dealloc_vp_search_idx_tbl_entry(ab, vp_profile->search_idx_reg_num);
 
 	ath12k_dp_ppeds_dealloc_vp_tbl_entry(ab, vp_profile->ppe_vp_num_idx);
--- a/drivers/net/wireless/ath/ath12k/ppe.h
+++ b/drivers/net/wireless/ath/ath12k/ppe.h
@@ -6,16 +6,6 @@
 #ifndef ATH12K_PPE_H
 #define ATH12K_PPE_H
 
-struct ath12k_dp_ppe_vp_profile {
-        bool is_configured;
-        u8 vp_num;
-        u8 ppe_vp_num_idx;
-        u8 search_idx_reg_num;
-        u8 drop_prec_enable;
-        u8 to_fw;
-        u8 use_ppe_int_pri;
-};
-
 #define ATH12K_PPEDS_DEFAULT_POOL_ID 0
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
@@ -26,18 +16,18 @@ void ath12k_dp_ppeds_stop(struct ath12k_
 int ath12k_dp_ppeds_start(struct ath12k_base *ab);
 int ath12k_ppeds_detach( struct ath12k_base *ab);
 int ath12k_ppeds_attach( struct ath12k_base *ab);
-int ath12k_mac_op_ppeds_attach_vdev(struct ieee80211_hw *hw,
-				       struct ieee80211_vif *vif,
-				       void *vp_arg, int *ppe_vp_num,
-				       struct ieee80211_ppe_vp_ds_params *vp_params);
-void ath12k_mac_op_ppeds_detach_vdev(struct ieee80211_hw *hw,
-				     struct ieee80211_vif *vif,
-				     struct ieee80211_ppe_vp_ds_params *vp_params);
+int ath12k_mac_op_ppeds_attach_vdev(struct ath12k_link_vif *arvif,
+                                void *vp_arg, int *ppe_vp_num,
+                                struct ieee80211_ppe_vp_ds_params *vp_params);
+void ath12k_mac_op_ppeds_detach_vdev(struct ath12k_link_vif *arvif,
+                                     struct ieee80211_ppe_vp_ds_params *vp_params);
 void ath12k_dp_peer_ppeds_route_setup(struct ath12k *ar, struct ath12k_link_vif *arvif,
 				      struct ath12k_link_sta *arsta);
 void *ath12k_dp_get_ppe_ds_ctxt(struct ath12k_base *ab);
 irqreturn_t ath12k_ds_ppe2tcl_irq_handler(int irq, void *ctxt);
 irqreturn_t ath12k_ds_reo2ppe_irq_handler(int irq, void *ctxt);
 irqreturn_t ath12k_dp_ppeds_handle_tx_comp(int irq, void *ctxt);
+void ath12k_dp_ppeds_update_vp_entry(struct ath12k *ar,
+				     struct ath12k_link_vif *arvif);
 #endif
 #endif
--- a/drivers/net/wireless/ath/ath12k/dp.h
+++ b/drivers/net/wireless/ath/ath12k/dp.h
@@ -369,7 +369,7 @@ struct host_link_stats {
 #define PPE_VP_ENTRIES_MAX 32
 #define MAX_PPEDS_IRQ_NAME_LEN 20
 #define MAX_PPEDS_IRQS 3
-struct dp_ppe_vp_profile {
+struct ath12k_dp_ppe_vp_profile {
 	bool is_configured;
 	u8 vp_num;
 	u8 ppe_vp_num_idx;
@@ -377,6 +377,7 @@ struct dp_ppe_vp_profile {
 	u8 drop_prec_enable;
 	u8 to_fw;
 	u8 use_ppe_int_pri;
+	struct ath12k_link_vif *arvif;
 };
 #endif
 
@@ -449,7 +450,7 @@ struct ath12k_dp {
 	/* protects the free and used desc lists */
 	spinlock_t ppeds_tx_desc_lock[ATH12K_HW_MAX_QUEUES_PPEDS];
 
-	struct dp_ppe_vp_profile ppe_vp_profile[PPE_VP_ENTRIES_MAX];
+	struct ath12k_dp_ppe_vp_profile ppe_vp_profile[PPE_VP_ENTRIES_MAX];
 	char ppeds_irq_name[MAX_PPEDS_IRQS][MAX_PPEDS_IRQ_NAME_LEN];
 	int ppeds_irq[MAX_PPEDS_IRQS];
 #endif
--- a/drivers/net/wireless/ath/ath12k/dp_mon.c
+++ b/drivers/net/wireless/ath/ath12k/dp_mon.c
@@ -10,6 +10,10 @@
 #include "dp_tx.h"
 #include "peer.h"
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+extern int g_bonded_interface_model;
+#endif
+
 static void ath12k_dp_mon_rx_handle_ofdma_info(void *rx_tlv,
 					       struct hal_rx_user_status *rx_user_status)
 {
@@ -3326,6 +3330,77 @@ ath12k_dp_mon_rx_update_peer_rate_table_
 		rx_stats->byte_stats.rx_rate[bw_idx][gi_idx][nss_idx][mcs_idx] += ppdu_info->mpdu_len;
 }
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+static void ath12k_dp_mon_rx_update_peer_stats_bonded(struct ath12k *ar,
+						      struct ath12k_link_sta *arsta,
+						      struct hal_rx_mon_ppdu_info *ppdu_info,
+						      struct ieee80211_rx_status *rx_status)
+{
+	struct ieee80211_rx_status status;
+	struct ieee80211_sta *sta;
+	u32 uid;
+
+	if (ar->ab->stats_disable || !g_bonded_interface_model ||
+	    !test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ar->ab->dev_flags))
+		return;
+
+	memset(&status, 0 , sizeof(status));
+
+	lockdep_assert_held(&ar->ab->base_lock);
+	if (arsta) { // SU stats
+		if (arsta->arvif && (arsta->arvif->ppe_vp_num == -1 ||
+		    (arsta->arvif->ahvif &&
+		     hweight16(arsta->arvif->ahvif->links_map) <= 1)))
+			return;
+
+		if (!rx_status) {
+			ath12k_dp_mon_fill_rx_stats(ar, ppdu_info, &status);
+			rx_status = &status;
+		}
+
+		sta = container_of((void *)arsta->ahsta, struct ieee80211_sta, drv_priv);
+		ieee80211_rx_update_stats(ar->ah->hw, sta, arsta->link_id,
+					  ppdu_info->mpdu_len, rx_status);
+		return;
+	}
+
+	for (uid = 0; uid < ppdu_info->num_users; uid++) { // MU stats
+		struct ath12k_peer *peer;
+
+		if (uid == HAL_MAX_UL_MU_USERS)
+			break;
+
+		if (ppdu_info->peer_id == HAL_INVALID_PEERID)
+			return;
+		peer = ath12k_peer_find_by_id(ar->ab, ppdu_info->peer_id);
+
+		if (!peer)
+			continue;
+
+		arsta = ath12k_peer_get_link_sta(ar->ab, peer);
+		if (!arsta) {
+			ath12k_warn(ar->ab, "link sta not found on peer %pM id %d\n",
+				    peer->addr, peer->peer_id);
+			continue;
+		}
+
+		if (arsta->arvif && (arsta->arvif->ppe_vp_num == -1 ||
+		    (arsta->arvif->ahvif &&
+		     hweight16(arsta->arvif->ahvif->links_map) <= 1)))
+			continue;
+
+		if (!rx_status) {
+			ath12k_dp_mon_fill_rx_stats(ar, ppdu_info, &status);
+			rx_status = &status;
+		}
+
+		sta = container_of((void *)arsta->ahsta, struct ieee80211_sta, drv_priv);
+		ieee80211_rx_update_stats(ar->ah->hw, sta, arsta->link_id,
+					  ppdu_info->mpdu_len, rx_status);
+	}
+}
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
+
 static void ath12k_dp_mon_rx_update_peer_su_stats(struct ath12k *ar,
 						  struct ath12k_link_sta *arsta,
 						  struct hal_rx_mon_ppdu_info *ppdu_info)
@@ -3794,10 +3869,18 @@ move_next:
 
 			ath12k_dp_mon_rx_update_peer_su_stats(ar, arsta,
 							      ppdu_info);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, arsta, ppdu_info,
+								  &ar->dp.rx_status);
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
 		} else if ((ppdu_info->fc_valid) &&
 			   (ppdu_info->ast_index != HAL_AST_IDX_INVALID)) {
 			ath12k_dp_mon_rx_process_ulofdma(ppdu_info);
 			ath12k_dp_mon_rx_update_peer_mu_stats(ar, ppdu_info);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, NULL, ppdu_info,
+								  &ar->dp.rx_status);
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
 		}
 
 		if (ath12k_debugfs_is_pktlog_peer_valid(ar, peer->addr)) {
@@ -3962,10 +4045,18 @@ move_next:
 
 			ath12k_dp_mon_rx_update_peer_su_stats(ar, arsta,
 							      ppdu_info);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, arsta, ppdu_info,
+								  NULL);
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
 		} else if ((ppdu_info->fc_valid) &&
 			   (ppdu_info->ast_index != HAL_AST_IDX_INVALID)) {
 			ath12k_dp_mon_rx_process_ulofdma(ppdu_info);
 			ath12k_dp_mon_rx_update_peer_mu_stats(ar, ppdu_info);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, NULL, ppdu_info,
+								  NULL);
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
  		}
 
 next_skb:
--- a/drivers/net/wireless/ath/ath12k/dp_rx.h
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.h
@@ -40,6 +40,7 @@ enum ath12k_routing_pkt_type {
 #define ATH12K_RX_PROTOCOL_TAG_START_OFFSET  128
 #define ATH12K_ROUTE_WBM_RELEASE        3
 #define ATH12K_ROUTE_EAP_METADATA       (ATH12K_RX_PROTOCOL_TAG_START_OFFSET + ATH12K_PKT_TYPE_EAP)
+#define ATH12K_ROUTE_ARP_METADATA       (ATH12K_RX_PROTOCOL_TAG_START_OFFSET + ATH12K_PKT_TYPE_ARP_IPV4)
 
 struct ath12k_dp_rx_tid {
 	u8 tid;
--- a/drivers/net/wireless/ath/ath12k/hal.c
+++ b/drivers/net/wireless/ath/ath12k/hal.c
@@ -403,6 +403,12 @@ static u8 ath12k_hw_qcn9274_rx_desc_get_
 			    RX_MSDU_END_INFO5_TID);
 }
 
+static u8 ath12k_hw_qcn9274_rx_desc_get_msdu_intra_bss_bit(struct hal_rx_desc *desc)
+{
+	/* TODO - msdu_end info9 */
+	return 0;
+}
+
 static u16 ath12k_hw_qcn9274_rx_desc_get_mpdu_peer_id(struct hal_rx_desc *desc)
 {
 	return le16_get_bits(desc->u.qcn9274.mpdu_start.sw_peer_id,
@@ -741,6 +747,7 @@ const struct hal_ops hal_qcn9274_ops = {
 	.rx_desc_get_msdu_payload = ath12k_hw_qcn9274_rx_desc_get_msdu_payload,
 	.rx_desc_get_mpdu_start_offset = ath12k_hw_qcn9274_rx_desc_get_mpdu_start_offset,
 	.rx_desc_get_msdu_end_offset = ath12k_hw_qcn9274_rx_desc_get_msdu_end_offset,
+	.rx_desc_get_msdu_intra_bss_bit = ath12k_hw_qcn9274_rx_desc_get_msdu_intra_bss_bit,
 	.rx_desc_mac_addr2_valid = ath12k_hw_qcn9274_rx_desc_mac_addr2_valid,
 	.rx_desc_mpdu_start_addr2 = ath12k_hw_qcn9274_rx_desc_mpdu_start_addr2,
 	.rx_desc_is_da_mcbc = ath12k_hw_qcn9274_rx_desc_is_da_mcbc,
--- a/drivers/net/wireless/ath/ath12k/hal.h
+++ b/drivers/net/wireless/ath/ath12k/hal.h
@@ -1110,6 +1110,7 @@ struct hal_ops {
 	u8 *(*rx_desc_get_msdu_payload)(struct hal_rx_desc *desc);
 	u32 (*rx_desc_get_mpdu_start_offset)(void);
 	u32 (*rx_desc_get_msdu_end_offset)(void);
+	u8 (*rx_desc_get_msdu_intra_bss_bit)(struct hal_rx_desc *desc);
 	bool (*rx_desc_mac_addr2_valid)(struct hal_rx_desc *desc);
 	u8* (*rx_desc_mpdu_start_addr2)(struct hal_rx_desc *desc);
 	bool (*rx_desc_is_da_mcbc)(struct hal_rx_desc *desc);
--- a/drivers/net/wireless/ath/ath12k/rx_desc.h
+++ b/drivers/net/wireless/ath/ath12k/rx_desc.h
@@ -691,7 +691,7 @@ enum rx_msdu_start_reception_type {
 
 #define RX_MSDU_END_INFO9_SERVICE_CODE		GENMASK(14, 6)
 #define RX_MSDU_END_INFO9_PRIORITY_VALID	BIT(15)
-#define RX_MSDU_END_INFO9_INRA_BSS		BIT(16)
+#define RX_MSDU_END_INFO9_INTRA_BSS		BIT(16)
 #define RX_MSDU_END_INFO9_DEST_CHIP_ID		GENMASK(18, 17)
 #define RX_MSDU_END_INFO9_MCAST_ECHO		BIT(19)
 #define RX_MSDU_END_INFO9_WDS_LEARN_EVENT	BIT(20)
--- a/drivers/net/wireless/ath/ath12k/wmi.c
+++ b/drivers/net/wireless/ath/ath12k/wmi.c
@@ -1704,7 +1704,72 @@ int ath12k_wmi_config_peer_ppeds_routing
 
 	return ret;
 }
-#endif
+
+int
+ath12k_wmi_send_vdev_set_intra_bss_cmd(struct ath12k *ar,
+				       u32 vdev_id, u32 enable)
+{
+	struct ath12k_pdev_wmi *wmi = ar->wmi;
+	struct ath12k_vdev_set_intra_bss_cmd *cmd;
+	struct sk_buff *skb;
+	int ret;
+
+	skb = ath12k_wmi_alloc_skb(wmi->wmi_ab, sizeof(struct ath12k_vdev_set_intra_bss_cmd));
+	if (!skb)
+		return -ENOMEM;
+
+	cmd = (struct ath12k_vdev_set_intra_bss_cmd *)skb->data;
+	cmd->tlv_header = ath12k_wmi_tlv_cmd_hdr(WMI_TAG_VDEV_SET_INTRA_BSS_PARAMS,
+						 sizeof(*cmd));
+	cmd->vdev_id = vdev_id;
+	cmd->enable = enable;
+
+	ret = ath12k_wmi_cmd_send(wmi, skb, WMI_VDEV_SET_INTRA_BSS_CMDID);
+	if (ret) {
+		ath12k_warn(ar->ab,
+			    "failed to send WMI_VDEV_SET_INTRA_BSS_CMDID\n");
+		dev_kfree_skb(skb);
+	}
+
+	ath12k_dbg(ar->ab, ATH12K_DBG_WMI,
+		   "WMI vdev id 0x%x set inra bss %s\n",
+		   vdev_id, enable?"enable":"disable");
+
+	return ret;
+}
+
+int ath12k_wmi_set_peer_intra_bss_cmd(struct ath12k *ar, u32 vdev_id, const u8 *peer_addr,
+				      u32 enable)
+{
+	struct ath12k_pdev_wmi *wmi = ar->wmi;
+	struct wmi_peer_set_intra_bss_cmd *cmd;
+	struct sk_buff *skb;
+	int ret;
+
+	skb = ath12k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));
+	if (!skb)
+		return -ENOMEM;
+
+	cmd = (struct wmi_peer_set_intra_bss_param_cmd *)skb->data;
+	cmd->tlv_header = ath12k_wmi_tlv_cmd_hdr(WMI_TAG_PEER_SET_INTRA_BSS_PARAMS,
+						 sizeof(*cmd));
+	ether_addr_copy(cmd->peer_macaddr.addr, peer_addr);
+	cmd->vdev_id = cpu_to_le32(vdev_id);
+	cmd->enable = cpu_to_le32(enable);
+
+	ret = ath12k_wmi_cmd_send(wmi, skb, WMI_PEER_SET_INTRA_BSS_CMDID);
+	if (ret) {
+		ath12k_warn(ar->ab, "failed to send WMI_PEER_SET_INTRA_BSS_CMD\n");
+		dev_kfree_skb(skb);
+	}
+
+	ath12k_dbg(ar->ab, ATH12K_DBG_WMI,
+		   "WMI vdev %d peer 0x%pM set intra_bss %s\n",
+		   vdev_id, peer_addr, enable ? "enable" : "disable");
+
+	return ret;
+}
+#endif /* CPTCFG_ATH12K_PPE_DS_SUPPORT */
 
 int ath12k_wmi_send_pdev_pkt_route(struct ath12k *ar,
 				   struct ath12k_wmi_pkt_route_param *param)
--- a/drivers/net/wireless/ath/ath12k/wmi.h
+++ b/drivers/net/wireless/ath/ath12k/wmi.h
@@ -530,6 +530,8 @@ enum wmi_tlv_cmd_id {
         WMI_VDEV_GET_BIG_DATA_P2_CMDID,
         /** set TPC PSD/non-PSD power */
         WMI_VDEV_SET_TPC_POWER_CMDID,
+	WMI_VDEV_IGMP_OFFLOAD_CMDID,
+	WMI_VDEV_SET_INTRA_BSS_CMDID,
 	WMI_PEER_CREATE_CMDID = WMI_TLV_CMD(WMI_GRP_PEER),
 	WMI_PEER_DELETE_CMDID,
 	WMI_PEER_FLUSH_TIDS_CMDID,
@@ -561,6 +563,7 @@ enum wmi_tlv_cmd_id {
 	WMI_PEER_UNMAP_RESPONSE_CMDID,
 	WMI_PEER_CONFIG_VLAN_CMDID,
 	WMI_PEER_CONFIG_PPE_DS_CMDID,
+	WMI_PEER_SET_INTRA_BSS_CMDID,
 	WMI_BCN_TX_CMDID = WMI_TLV_CMD(WMI_GRP_MGMT),
 	WMI_PDEV_SEND_BCN_CMDID,
 	WMI_BCN_TMPL_CMDID,
@@ -2178,6 +2181,8 @@ enum wmi_tlv_tag {
 	WMI_TAG_MLO_PEER_CREATE_PARAMS = 0x3D5,
 	WMI_TAG_MLO_VDEV_START_PARAMS = 0x3D6,
 	WMI_TAG_MLO_VDEV_CREATE_PARAMS = 0x3D7,
+	WMI_TAG_VDEV_SET_INTRA_BSS_PARAMS = 0x3EE,
+	WMI_TAG_PEER_SET_INTRA_BSS_PARAMS,
 	WMI_TAG_PDEV_PKTLOG_DECODE_INFO = 0x414,
 	WMI_TAG_TPC_STATS_GET_CMD = 0x38B,
 	WMI_TAG_TPC_STATS_EVENT_FIXED_PARAM,
@@ -3783,6 +3788,21 @@ struct wmi_peer_set_param_cmd {
 	__le32 param_value;
 } __packed;
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+struct wmi_peer_set_intra_bss_cmd {
+	__le32 tlv_header;
+	struct wmi_mac_addr peer_macaddr;
+	__le32 vdev_id;
+	__le32 enable;
+} __packed;
+
+struct ath12k_vdev_set_intra_bss_cmd {
+    u32 tlv_header;
+    u32 vdev_id;
+    u32 enable;
+} __packed;
+#endif
+
 struct wmi_peer_flush_tids_cmd {
 	__le32 tlv_header;
 	__le32 vdev_id;
@@ -8175,6 +8195,13 @@ int
 ath12k_mgmt_rx_reo_init_context(struct ath12k_base *ab);
 int
 ath12k_mgmt_rx_reo_deinit_context(struct ath12k_base *ab);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+int
+ath12k_wmi_send_vdev_set_intra_bss_cmd(struct ath12k *ar,
+				       u32 vdev_id, u32 enable);
+int ath12k_wmi_set_peer_intra_bss_cmd(struct ath12k *ar,  u32 vdev_id, const u8 *peer_addr,
+				      u32 enable);
+#endif
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 int ath12k_wmi_config_peer_ppeds_routing(struct ath12k *ar,
 					 const u8 *peer_addr, u8 vdev_id,
