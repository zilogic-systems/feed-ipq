From 3b871b7778ef35a5f23b524caf128118bb008e4c Mon Sep 17 00:00:00 2001
From: Narendhar Reddy <quic_nare@quicinc.com>
Date: Tue, 29 Aug 2023 10:20:39 +0530
Subject: [PATCH] ath12k: coredump handling for multipd architecture.

IPQ5322, QCN6432 has multipd architecture.In multipd
architecture there will be one userpd per radio and
one rootpd for all the radios.

To register callbacks for all the userpds and rootpd and
to handle notifications for rootpd crash and userpd crash.

Signed-off-by: Narendhar Reddy <quic_nare@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/ahb.h  | 37 +++++++++++++++++++++-----
 drivers/net/wireless/ath/ath12k/core.c | 23 +++++++++++-----
 drivers/net/wireless/ath/ath12k/core.h |  7 ++++-
 3 files changed, 54 insertions(+), 13 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/ahb.h
+++ b/drivers/net/wireless/ath/ath12k/ahb.h
@@ -9,6 +9,7 @@
 #include <linux/remoteproc.h>
 #include <linux/remoteproc/qcom_rproc.h>
 #include "core.h"
+#include "debug.h"
 
 #define ATH12K_AHB_RECOVERY_TIMEOUT (3 * HZ)
 
@@ -52,11 +53,31 @@ static inline int ath12k_rproc_register_
 	struct ath12k_ahb *ab_ahb = ath12k_ahb_priv(ab);
 #ifdef CONFIG_REMOTEPROC
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
-	return rproc_register_subsys_notifier(ab_ahb->tgt_rrproc->name, &ab->ssr_nb, &ab->atomic_ssr_nb);
+	return rproc_register_subsys_notifier(ab_ahb->tgt_rrproc->name,&ab->ssr_nb, &ab->atomic_ssr_nb);
 #else
-	ab->ssr_handle = qcom_register_ssr_notifier(ab_ahb->tgt_rrproc->name, &ab->atomic_ssr_nb);
-	if (!ab->ssr_handle)
+	ab->ssr_atomic_upd_handle = qcom_register_ssr_atomic_notifier(ab_ahb->tgt_rproc->name,
+								      &ab->atomic_ssr_nb);
+	if (!ab->ssr_atomic_upd_handle) {
+		ath12k_err(ab, "failed to register user_pd atomic handle\n");
 		return -EINVAL;
+	}
+
+	ab->ssr_upd_handle = qcom_register_ssr_notifier(ab_ahb->tgt_rproc->name, &ab->ssr_nb);
+	if (!ab->ssr_upd_handle)
+		return -EINVAL;
+
+	if (ab->userpd_id == USERPD_0) {
+		ab->ssr_atomic_rpd_handle = qcom_register_ssr_atomic_notifier(ab_ahb->tgt_rrproc->name,
+									      &ab->atomic_ssr_nb);
+		if (!ab->ssr_atomic_rpd_handle) {
+			ath12k_err(ab, "failed to register root_pd atomic handle\n");
+			return -EINVAL;
+		}
+		ab->ssr_rpd_handle = qcom_register_ssr_notifier(ab_ahb->tgt_rrproc->name,
+								&ab->ssr_nb);
+		if (!ab->ssr_rpd_handle)
+			return -EINVAL;
+	}
 	return 0;
 #endif
 #else
@@ -68,10 +89,19 @@ static inline int ath12k_rproc_unregiste
 #ifdef CONFIG_REMOTEPROC
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
 	struct ath12k_ahb *ab_ahb = ath12k_ahb_priv(ab);
-	return rproc_unregister_subsys_notifier(ab_ahb->tgt_rrproc->name, &ab->ssr_nb, &ab->atomic_ssr_nb);
+	return rproc_unregister_subsys_notifier(ab_ahb->tgt_rrproc->name, &ab->ssr_nb,
+			&ab->atomic_ssr_nb);
 #else
-	if (ab->ssr_handle)
-		qcom_unregister_ssr_notifier(ab->ssr_handle, &ab->atomic_ssr_nb);
+	if (ab->ssr_upd_handle)
+		qcom_unregister_ssr_notifier(ab->ssr_upd_handle, &ab->ssr_nb);
+	if (ab->ssr_atomic_upd_handle)
+		qcom_unregister_ssr_atomic_notifier(ab->ssr_atomic_upd_handle,
+						    &ab->atomic_ssr_nb);
+	if (ab->ssr_atomic_rpd_handle)
+		qcom_unregister_ssr_atomic_notifier(ab->ssr_atomic_rpd_handle,
+						    &ab->atomic_ssr_nb);
+	if (ab->ssr_rpd_handle)
+		qcom_unregister_ssr_notifier(ab->ssr_rpd_handle, &ab->ssr_nb);
 	return 0;
 #endif
 #else
--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -1732,6 +1732,9 @@ static void ath12k_coredump_download_ahb
 {
 	struct ath12k_hw_group *ag = ab->ag;
 	int dump_count;
+	struct ath12k_ahb *ab_ahb = ath12k_ahb_priv(ab);
+	struct ath12k_base *partner_ab;
+	int i;
 
 	/* Crash the system once all the stats are dumped */
 	if (ab->fw_recovery_support)
@@ -1745,8 +1748,15 @@ static void ath12k_coredump_download_ahb
 			return;
 		}
 	}
-
-	atomic_inc(&ath12k_coredump_ram_info.num_chip);
+	if (ab_ahb->tgt_rrproc->state == RPROC_CRASHED && ab->multi_pd_arch) {
+		for (i = 0; i < ag->num_chip; i++) {
+			partner_ab = ag->ab[i];
+			if (partner_ab->multi_pd_arch)
+				atomic_inc(&ath12k_coredump_ram_info.num_chip);
+		}
+	} else {
+		atomic_inc(&ath12k_coredump_ram_info.num_chip);
+	}
 
 	ath12k_core_issue_bug_on(ab);
 }
@@ -1814,7 +1824,11 @@ static int ath12k_core_atomic_ssr_notifi
 	 * remoteproc module to do the recovery process.
 	 * This module will take care of the rrproc recovery process.
 	 */
-	ab_ahb->tgt_rrproc->state = RPROC_CRASHED;
+	if (strcmp(ssr_pdev->name, ab_ahb->tgt_rrproc->name) == 0) {
+		ab_ahb->tgt_rrproc->state = RPROC_CRASHED;
+	} else {
+		ab_ahb->tgt_rproc->state = RPROC_CRASHED;
+	}
 
 	if (!(test_bit(ATH12K_FLAG_UNREGISTERING, &ab->ag->dev_flags))) {
 		set_bit(ATH12K_FLAG_RECOVERY, &ab->dev_flags);
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -1432,7 +1432,10 @@ struct ath12k_base {
 	bool collect_dump;
 	struct notifier_block ssr_nb;
 	struct notifier_block atomic_ssr_nb;
-    void *ssr_handle;
+	void *ssr_upd_handle;
+	void *ssr_rpd_handle;
+	void *ssr_atomic_rpd_handle;
+	void *ssr_atomic_upd_handle;
 	struct completion reconfigure_complete;
 	unsigned long reset_fail_timeout;
         /* continuous recovery fail count */
@@ -1509,6 +1512,8 @@ struct ath12k_base {
 	u32 *recovery_mode_address;
 
 	bool mlo_complete_event;
+	/* to identify multipd_architecture */
+	bool multi_pd_arch;
 	/* Mode1 specific flag to identify recovering pdev */
 	bool recovery_start;
 	/* must be last */
