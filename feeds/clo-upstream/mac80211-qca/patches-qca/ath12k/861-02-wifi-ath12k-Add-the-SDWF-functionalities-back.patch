From e358b36abc95875d8c882f9fc6d541022f5f6f4b Mon Sep 17 00:00:00 2001
From: Nagarajan Maran <quic_nmaran@quicinc.com>
Date: Wed, 27 Dec 2023 17:01:27 +0530
Subject: [PATCH] QSDK: wifi: ath12k: Add the SDWF functionalities back with the
 approved identifiers.

With the new approved subcmd enum values in hostap.git for SDWF,
rewrite the SDWF vendor commands handling.

Patch-dependency:
750-01-ath12k-Add-SAWF-support.patch
750-02-ath12k-Add-vendor-command-support-for-SAWF.patch
754-01-ath12k-sawf-add-uplink-configuration-paraeters-in-se.patch
861-01-wifi-ath12k-Removing-the-unassigned-identifiers.patch

Signed-off-by: Nagarajan Maran <quic_nmaran@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/sawf.c   |   1 -
 drivers/net/wireless/ath/ath12k/sawf.h   |   2 -
 drivers/net/wireless/ath/ath12k/vendor.c | 964 +++++++++++++++++++++++
 drivers/net/wireless/ath/ath12k/vendor.h | 183 +++++
 4 files changed, 1147 insertions(+), 3 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/sawf.c
+++ b/drivers/net/wireless/ath/ath12k/sawf.c
@@ -117,7 +117,6 @@ void ath12k_update_svc_class(struct ath1
 
 	new_param = &sawf_ctx->svc_classes[SVC_INDEX(sawf_params->svc_id)];
 	new_param->svc_id = sawf_params->svc_id;
-	memcpy(new_param->app_name, sawf_params->app_name, ATH12K_MAX_APP_NAME);
 	new_param->min_throughput_rate = sawf_params->min_throughput_rate;
 	new_param->max_throughput_rate = sawf_params->max_throughput_rate;
 	new_param->burst_size = sawf_params->burst_size;
--- a/drivers/net/wireless/ath/ath12k/sawf.h
+++ b/drivers/net/wireless/ath/ath12k/sawf.h
@@ -19,7 +19,6 @@ struct telemetry_sawfdelay_stats;
 
 #define ATH12K_SAWF_SVC_CLASS_MIN 1
 #define ATH12K_SAWF_SVC_CLASS_MAX 128
-#define ATH12K_MAX_APP_NAME 64
 #define ATH12K_SAWF_MAX_TID_SUPPORT 8
 #define MAX_Q_PER_TID 8
 /**
@@ -162,7 +161,6 @@ enum SAWF_SVC_PARAM_DEFAULTS {
 
 struct ath12k_sawf_svc_params {
 	u8 svc_id;
-	char app_name[ATH12K_MAX_APP_NAME];
 	u32 min_throughput_rate;
 	u32 max_throughput_rate;
 	u32 burst_size;
--- a/drivers/net/wireless/ath/ath12k/vendor.c
+++ b/drivers/net/wireless/ath/ath12k/vendor.c
@@ -13,6 +13,91 @@
 
 #ifdef CPTCFG_ATH12K_SAWF
 static const struct nla_policy
+ath12k_vendor_sdwf_phy_policy[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_OPERATION] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SVC_PARAMS] = {.type = NLA_NESTED},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_SAMPLES_PARAMS] = {.type = NLA_NESTED},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_DETECT_PARAMS] = {.type = NLA_NESTED},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_THRESHOLD_PARAMS] = {.type = NLA_NESTED},
+};
+
+static const struct nla_policy
+ath12k_vendor_sdwf_dev_policy[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_OPERATION] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_DEF_Q_PARAMS] = {.type = NLA_NESTED},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_STREAMING_STATS_PARAMS] = {.type = NLA_NESTED},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_RESET_STATS] = {.type = NLA_NESTED},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_SLA_BREACHED_PARAMS] = {.type = NLA_NESTED},
+};
+
+static const struct nla_policy
+ath12k_vendor_sdwf_svc_policy[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_ID] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MIN_TP] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX_TP] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_BURST_SIZE] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_INTERVAL] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_DELAY_BOUND] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MSDU_TTL] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_PRIO] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_TID] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MSDU_RATE_LOSS] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_SVC_INTERVAL] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MIN_TPUT] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MAX_LATENCY ] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_BURST_SIZE] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_OFDMA_DISABLE] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MU_MIMO_DISABLE] = {.type = NLA_U8},
+};
+
+static const struct nla_policy
+ath12k_vendor_sdwf_def_qmap_req_policy[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_SVC_ID] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAC_ADDR] = {.type = NLA_STRING, .len = 18},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_TID] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_STATUS] = {.type = NLA_U8},
+};
+
+static const struct nla_policy
+ath12k_vendor_telemetry_sdwf_sla_thershold_config_policy[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_SVC_ID] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MIN_TP] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MAX_TP] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_BURST_SIZE] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_INTERVAL] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_DELAY_BOUND] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MSDU_TTL] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MSDU_RATE_LOSS] = {.type = NLA_U32},
+};
+
+static const struct nla_policy
+ath12k_vendor_telemetry_sdwf_sla_detect_config_policy[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_PARAM] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MIN_TP] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MAX_TP] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_BURST_SIZE] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_INTERVAL] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_DELAY_BOUND] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MSDU_TTL] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MSDU_RATE_LOSS ] = {.type = NLA_U32},
+};
+
+static const struct nla_policy
+ath12k_vendor_telemetry_sdwf_sla_samples_config_policy[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_MOVING_AVG_PKT] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_MOVING_AVG_WIN] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_SLA_NUM_PKT] = {.type = NLA_U32},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_SLA_TIME_SEC] = {.type = NLA_U32},
+};
+
+static const struct nla_policy
+ath12k_vendor_sawf_streaming[QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_BASIC_STATS] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_EXTND_STATS] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_MLO_LINK_ID] = {.type = NLA_U32},
+};
+
+static const struct nla_policy
 ath12k_telemetric_req_policy[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MAX + 1] = {
 	[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_LEVEL] = {.type = NLA_U8},
 	[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_OBJECT] = {.type = NLA_U8},
@@ -23,6 +108,19 @@ ath12k_telemetric_req_policy[QCA_WLAN_VE
 						     .len = ETH_ALEN},
 	[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_SERVICEID] = {.type = NLA_U8},
 };
+
+static const struct nla_policy
+ath12k_telemetric_sla_policy[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MAC] = {.type = NLA_BINARY,
+								 .len = ETH_ALEN},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_SVC_ID] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_TYPE] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_SET_CLEAR] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MLD_MAC] = {.type = NLA_BINARY,
+								     .len = ETH_ALEN},
+	[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_AC] = {.type = NLA_U8},
+};
+
 #endif
 
 static const struct nla_policy
@@ -46,6 +144,597 @@ ath12k_ds_policy[QCA_WLAN_VENDOR_ATTR_DS
 
 #ifdef CPTCFG_ATH12K_SAWF
 
+static void ath12k_set_default_values(struct ath12k_sawf_svc_params *param)
+{
+	param->min_throughput_rate = SAWF_SVC_PARAM_DEFAULT_MIN_THRUPUT;
+	param->max_throughput_rate = SAWF_SVC_PARAM_DEFAULT_MAX_THRUPUT;
+	param->burst_size = SAWF_SVC_PARAM_DEFAULT_BURST_SIZE;
+	param->service_interval = SAWF_SVC_PARAM_DEFAULT_SVC_INTERVAL;
+	param->delay_bound = SAWF_SVC_PARAM_DEFAULT_DELAY_BOUND;
+	param->msdu_ttl = SAWF_SVC_PARAM_DEFAULT_TIME_TO_LIVE;
+	param->priority = SAWF_SVC_PARAM_DEFAULT_PRIORITY;
+	param->tid = SAWF_SVC_PARAM_DEFAULT_TID;
+	param->msdu_rate_loss = SAWF_SVC_PARAM_DEFAULT_MSDU_LOSS_RATE;
+	param->ul_burst_size = SAWF_SVC_PARAM_DEFAULT_UL_BURST_SIZE;
+	param->ul_min_tput = SAWF_SVC_PARAM_DEFAULT_UL_MIN_TPUT;
+	param->ul_max_latency = SAWF_SVC_PARAM_DEFAULT_UL_MAX_LATENCY;
+	param->ul_service_interval = SAWF_SVC_PARAM_DEFAULT_UL_SVC_INTERVAL;
+	param->ul_ofdma_disable = SAWF_SVC_PARAM_DEFAULT_UL_OFDMA_DISABLE;
+	param->ul_mu_mimo_disable = SAWF_SVC_PARAM_DEFAULT_UL_MU_MIMO_DISABLE;
+}
+
+static int ath12k_vendor_set_sdwf_config(struct wiphy *wiphy,
+					 struct wireless_dev *wdev,
+					 struct nlattr *svc_params)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX + 1];
+	struct ath12k_sawf_svc_params sdwf_param;
+	int ret = 0;
+
+	memset(&sdwf_param, 0, sizeof(struct ath12k_sawf_svc_params));
+
+	ret = nla_parse_nested(tb, QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX,
+				svc_params,
+				ath12k_vendor_sdwf_svc_policy, NULL);
+	if (ret) {
+		ath12k_err(NULL, "Invalid attribute with SAWF configure command\n");
+		return ret;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_ID]) {
+		sdwf_param.svc_id = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_ID]);
+	} else {
+		ath12k_err(NULL, "Mandatory attributes not available\n");
+		return -EINVAL;
+	}
+
+	ath12k_set_default_values(&sdwf_param);
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MIN_TP])
+		sdwf_param.min_throughput_rate = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MIN_TP]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX_TP])
+		sdwf_param.max_throughput_rate = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX_TP]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_BURST_SIZE])
+		sdwf_param.burst_size = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_BURST_SIZE]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_INTERVAL])
+		sdwf_param.service_interval = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_INTERVAL]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_DELAY_BOUND])
+		sdwf_param.delay_bound = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_DELAY_BOUND]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MSDU_TTL])
+		sdwf_param.msdu_ttl = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MSDU_TTL]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_PRIO])
+		sdwf_param.priority = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_PRIO]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_TID])
+		sdwf_param.tid = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_TID]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MSDU_RATE_LOSS])
+		sdwf_param.msdu_rate_loss = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MSDU_RATE_LOSS]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_SVC_INTERVAL])
+		sdwf_param.ul_service_interval =
+			nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_SVC_INTERVAL]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_BURST_SIZE])
+		sdwf_param.ul_burst_size =
+			nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_BURST_SIZE]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MIN_TPUT])
+		sdwf_param.ul_min_tput =
+			nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MIN_TPUT]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MAX_LATENCY ])
+		sdwf_param.ul_max_latency =
+			nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MAX_LATENCY ]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_OFDMA_DISABLE])
+		sdwf_param.ul_ofdma_disable =
+			nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_OFDMA_DISABLE]);
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MU_MIMO_DISABLE])
+		sdwf_param.ul_mu_mimo_disable =
+			nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MU_MIMO_DISABLE]);
+
+	ret = ath12k_create_send_svc_params(&sdwf_param);
+
+	return ret;
+}
+
+static int ath12k_vendor_disable_sdwf_config(struct nlattr *svc_params)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX + 1];
+	u8 svc_id = 0;
+	int ret = 0;
+
+	ret = nla_parse_nested(tb, QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX,
+			       svc_params,
+			       ath12k_vendor_sdwf_svc_policy, NULL);
+	if (ret) {
+		ath12k_err(NULL, "Invalid attributes with SAWF disable command\n");
+		return ret;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_ID]) {
+		svc_id = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_ID]);
+	} else {
+		ath12k_err(NULL, "Mandatory attribute not available\n");
+		return -EINVAL;
+	}
+
+	ret = ath12k_sawf_disable_config(svc_id);
+	return ret;
+}
+
+static int ath12k_vendor_view_sdwf_config(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+					  struct sk_buff *msg,
+					  const void *data,
+					  int data_len,
+					  unsigned long *storage)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_MAX + 1];
+	struct nlattr *svc[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX + 1];
+	struct ath12k_sawf_ctx *sdwf_ctx;
+	struct ath12k_sawf_svc_params *svc_class;
+	struct nlattr *sdwf_svc_classes, *sdwf_svc_class;
+	int ret = 0, i, j = 0;
+	int tailroom = 0, nest_start_length = 0, nest_end_length = 0, nested_range = 0;
+	u8 svc_id = 0;
+
+	if (!ath12k_sawf_enable)
+		return -EOPNOTSUPP;
+
+	if (!storage)
+		return -ENODATA;
+
+	sdwf_ctx = ath12k_get_sawf_context();
+	if (!sdwf_ctx) {
+		ath12k_err(NULL, "SAWF context not available\n");
+		return -ENODATA;
+	}
+
+	ret = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SDWF_PHY_MAX, data, data_len,
+			 ath12k_vendor_sdwf_phy_policy, NULL);
+
+	if (ret) {
+		ath12k_err(NULL, "Invalid attributes with SAWF commands\n");
+		return -EINVAL;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_OPERATION] &&
+	    nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_OPERATION]) == QCA_WLAN_VENDOR_SDWF_PHY_OPER_SVC_GET) {
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SVC_PARAMS]) {
+			ret = nla_parse_nested(svc, QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX,
+					       tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SVC_PARAMS],
+					       ath12k_vendor_sdwf_svc_policy, NULL);
+			if (ret) {
+				ath12k_err(NULL, "Invalid attribute with SAWF view command\n");
+				return -EINVAL;
+			}
+			if (svc[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_ID]) {
+				bool isconfigured;
+
+				svc_id = nla_get_u8(svc[QCA_WLAN_VENDOR_ATTR_SDWF_SVC_ID]);
+				if (!ath12k_svc_id_valid(svc_id)) {
+					ath12k_err(NULL, "Invalid Service ID: %u\n", svc_id);
+					return -EINVAL;
+				}
+				spin_lock_bh(&sdwf_ctx->sawf_svc_lock);
+				isconfigured = ath12k_svc_id_configured(svc_id);
+				spin_unlock_bh(&sdwf_ctx->sawf_svc_lock);
+				if (!isconfigured)
+					return -EINVAL;
+			}
+		}
+	} else {
+		ath12k_err(NULL, "Invalid attribute with SAWF view command\n");
+		return -EINVAL;
+	}
+	/* return 0 to end the dump */
+	if (*storage == ATH12K_SAWF_SVC_CLASS_MAX)
+		return 0;
+
+	sdwf_svc_classes = nla_nest_start(msg,
+					  QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SVC_PARAMS);
+
+	if (!sdwf_svc_classes)
+		return -ENOBUFS;
+
+	tailroom = skb_tailroom(msg);
+	spin_lock_bh(&sdwf_ctx->sawf_svc_lock);
+	for (i = (svc_id) ? (svc_id - 1) : (*storage);
+	     i < ATH12K_SAWF_SVC_CLASS_MAX && tailroom > nested_range;
+	     i += (svc_id) ? (ATH12K_SAWF_SVC_CLASS_MAX) : (1)) {
+		if (!sdwf_ctx->svc_classes[i].configured)
+			continue;
+
+		svc_class = &sdwf_ctx->svc_classes[i];
+		nest_start_length = msg->len;
+		sdwf_svc_class = nla_nest_start(msg, j);
+		if (!sdwf_svc_class)
+			goto nla_put_failure;
+		if (nla_put_u8(msg, QCA_WLAN_VENDOR_ATTR_SDWF_SVC_ID,
+			       svc_class->svc_id) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MIN_TP,
+				svc_class->min_throughput_rate) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX_TP,
+				svc_class->max_throughput_rate) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_BURST_SIZE,
+				svc_class->burst_size) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_INTERVAL,
+				svc_class->service_interval) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_DELAY_BOUND,
+				svc_class->delay_bound) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MSDU_TTL,
+				svc_class->msdu_ttl) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_PRIO,
+				 svc_class->priority) ||
+		    nla_put_u32(msg, QCA_WLAN_VENDOR_ATTR_SDWF_SVC_TID,
+				svc_class->tid) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MSDU_RATE_LOSS,
+				svc_class->msdu_rate_loss) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_SVC_INTERVAL,
+				svc_class->ul_service_interval) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MIN_TPUT,
+				svc_class->ul_min_tput) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MAX_LATENCY,
+				svc_class->ul_max_latency) ||
+		    nla_put_u32(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_BURST_SIZE,
+				svc_class->ul_burst_size) ||
+		    nla_put_u8(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_OFDMA_DISABLE,
+				svc_class->ul_ofdma_disable) ||
+		    nla_put_u8(msg,
+				QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MU_MIMO_DISABLE,
+				svc_class->ul_mu_mimo_disable))
+			goto nla_put_failure;
+
+		nest_end_length = nla_nest_end(msg, sdwf_svc_class);
+		nested_range = nest_end_length - nest_start_length;
+		tailroom -= nested_range;
+		j++;
+	}
+	spin_unlock_bh(&sdwf_ctx->sawf_svc_lock);
+	nla_nest_end(msg, sdwf_svc_classes);
+
+	*storage = (svc_id) ? (ATH12K_SAWF_SVC_CLASS_MAX) : (i);
+
+	if (!j)
+		return 0;
+
+	return msg->len;
+
+nla_put_failure:
+	spin_unlock_bh(&sdwf_ctx->sawf_svc_lock);
+	return -ENOBUFS;
+}
+
+static int ath12k_vendor_sdwf_def_qmap_req(struct wireless_dev *wdev,
+					   struct nlattr *def_q_params)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAX + 1];
+	struct ath12k_base *ab = NULL;
+	u8 svc_id;
+	u8 *mac_addr_p = NULL;
+	u16 peer_id = 0xFFFF;
+	u8 mac_addr[ATH12K_MAC_ADDR_SIZE] = { 0 };
+	int ret = 0;
+
+	ret = nla_parse_nested(tb, QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAX,
+			       def_q_params,
+			       ath12k_vendor_sdwf_def_qmap_req_policy, NULL);
+	if (ret) {
+		ath12k_warn(NULL, "invalid sawf def q map policy attribute\n");
+		return ret;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAC_ADDR])	{
+		mac_addr_p = nla_data(tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAC_ADDR]);
+		if (sscanf(mac_addr_p,
+			   "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+			   &mac_addr[0],
+			   &mac_addr[1],
+			   &mac_addr[2],
+			   &mac_addr[3],
+			   &mac_addr[4],
+			   &mac_addr[5]) != ATH12K_MAC_ADDR_SIZE) {
+			ath12k_warn(NULL, "invalid Macaddr %s\n", mac_addr_p);
+			return -1;
+		}
+	}
+	svc_id = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_SVC_ID]);
+
+	ath12k_dbg(NULL, ATH12K_DBG_SAWF,
+		   "Default Q map:svcid[%u]macaddr[%pM]\n", svc_id, mac_addr);
+
+	ab = ath12k_sawf_get_ab_from_netdev(wdev->netdev, mac_addr, &peer_id);
+	if (ab)
+		ret = ath12k_sawf_def_qmap_req(ab, svc_id, peer_id);
+
+	return ret;
+}
+
+static int ath12k_vendor_sdwf_def_qunmap_req(struct wireless_dev *wdev,
+					     struct nlattr *def_q_params)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAX + 1];
+	struct ath12k_base *ab;
+	u8 svc_id;
+	u16 peer_id = 0xFFFF;
+	u8 *mac_addr_p = NULL;
+	u8 mac_addr[ATH12K_MAC_ADDR_SIZE] = { 0 };
+	int ret = 0;
+
+	ret = nla_parse_nested(tb, QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAX,
+			       def_q_params,
+			       ath12k_vendor_sdwf_def_qmap_req_policy, NULL);
+	if (ret) {
+		ath12k_warn(NULL, "invalid sawf def q unmap policy attribute\n");
+		return ret;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAC_ADDR]) {
+		mac_addr_p = nla_data(tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAC_ADDR]);
+		if (sscanf(mac_addr_p,
+			   "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+			   &mac_addr[0],
+			   &mac_addr[1],
+			   &mac_addr[2],
+			   &mac_addr[3],
+			   &mac_addr[4],
+			   &mac_addr[5]) != ATH12K_MAC_ADDR_SIZE) {
+			ath12k_warn(NULL, "invalid Macaddr %s\n", mac_addr_p);
+			return -1;
+		}
+	}
+	svc_id = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_SVC_ID]);
+
+	ath12k_dbg(NULL, ATH12K_DBG_SAWF,
+		   "Default Q unmap:svcid[%u]macaddr[%pM]\n", svc_id, mac_addr);
+
+	ab = ath12k_sawf_get_ab_from_netdev(wdev->netdev, mac_addr, &peer_id);
+
+	if (ab)
+		ret = ath12k_sawf_def_qunmap_req(ab, svc_id, peer_id);
+
+	return ret;
+}
+
+static int ath12k_vendor_sdwf_def_qmap_report_req(struct wireless_dev *wdev,
+						  struct nlattr *def_q_params)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAX + 1];
+	struct ath12k_base *ab = NULL;
+	u16 peer_id = 0xFFFF;
+	u8 *mac_addr_p = NULL;
+	u8 mac_addr[ATH12K_MAC_ADDR_SIZE] = { 0 };
+	int ret = 0;
+
+	ret = nla_parse_nested(tb, QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAX,
+			       def_q_params,
+			       ath12k_vendor_sdwf_def_qmap_req_policy, NULL);
+	if (ret) {
+		ath12k_warn(NULL, "invalid sawf def q map report req policy attribute\n");
+		return ret;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAC_ADDR])	{
+		mac_addr_p = nla_data(tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAC_ADDR]);
+		if (sscanf(mac_addr_p,
+			   "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+			   &mac_addr[0],
+			   &mac_addr[1],
+			   &mac_addr[2],
+			   &mac_addr[3],
+			   &mac_addr[4],
+			   &mac_addr[5]) != ATH12K_MAC_ADDR_SIZE) {
+			ath12k_warn(NULL, "invalid Macaddr %s\n", mac_addr_p);
+			return -1;
+		}
+	}
+	ath12k_dbg(NULL, ATH12K_DBG_SAWF,
+		   "Default Q map report:macaddr[%pM]\n", mac_addr);
+
+	ab = ath12k_sawf_get_ab_from_netdev(wdev->netdev, mac_addr, &peer_id);
+	if (ab)
+		ret = ath12k_sawf_def_qmap_report_req(ab, peer_id);
+
+	return ret;
+}
+
+static int ath12k_vendor_telemetry_sdwf_sla_samples_config(struct nlattr *sla_samples)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_MAX + 1];
+	struct ath12k_sla_samples_cfg t_param;
+	int ret = 0;
+
+	if (!ath12k_sawf_enable) {
+		ath12k_warn(NULL, "sawf is not enabled \n");
+		return -ENOSYS;
+	}
+
+	memset(&t_param, 0, sizeof(struct ath12k_sla_samples_cfg));
+
+	ret = nla_parse_nested(tb, QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_MAX,
+			       sla_samples,
+			       ath12k_vendor_telemetry_sdwf_sla_samples_config_policy, NULL);
+	if (ret) {
+		ath12k_warn(NULL, "invalid set telemetry sla samples config policy attribute\n");
+		return ret;
+	}
+
+	t_param.moving_avg_pkt =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_MOVING_AVG_PKT]);
+	t_param.moving_avg_win =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_MOVING_AVG_WIN]);
+	t_param.sla_num_pkt =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_SLA_NUM_PKT]);
+	t_param.sla_time_sec =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_SLA_TIME_SEC]);
+
+	ret = ath12k_telemetry_sawf_sla_samples_config(t_param);
+	return ret;
+}
+
+static int ath12k_vendor_telemetry_sdwf_sla_thershold_config(struct nlattr *sla_threshold)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MAX + 1];
+	struct ath12k_sla_thershold_cfg t_param;
+	int ret = 0;
+
+	memset(&t_param, 0, sizeof(struct ath12k_sla_thershold_cfg));
+
+	ret = nla_parse_nested(tb, QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MAX,
+			       sla_threshold,
+			       ath12k_vendor_telemetry_sdwf_sla_thershold_config_policy, NULL);
+	if (ret) {
+		ath12k_warn(NULL, "invalid telemetry sla thershold config policy attribute\n");
+		return ret;
+	}
+
+	t_param.svc_id =
+		nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_SVC_ID]);
+	t_param.min_throughput_rate =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MIN_TP]);
+	t_param.max_throughput_rate =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MAX_TP]);
+	t_param.burst_size =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_BURST_SIZE]);
+	t_param.service_interval =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_INTERVAL]);
+	t_param.delay_bound =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_DELAY_BOUND]);
+	t_param.msdu_ttl =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MSDU_TTL]);
+	t_param.msdu_rate_loss =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MSDU_RATE_LOSS]);
+
+	ret = ath12k_telemetry_sawf_sla_thershold_config(t_param);
+
+	return ret;
+}
+
+static int ath12k_vendor_telemetry_sdwf_sla_detection_config(struct nlattr *sla_detect)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MAX + 1];
+	struct ath12k_sla_detect_cfg t_param;
+	int ret = 0;
+
+	memset(&t_param, 0, sizeof(struct ath12k_sla_detect_cfg));
+
+	ret = nla_parse_nested(tb, QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MAX,
+			       sla_detect,
+			       ath12k_vendor_telemetry_sdwf_sla_detect_config_policy, NULL);
+	if (ret) {
+		ath12k_warn(NULL, "invalid telemetry sdwf sla detection config policy attribute\n");
+		return ret;
+	}
+
+	t_param.sla_detect =
+		nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_PARAM]);
+	t_param.min_throughput_rate =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MIN_TP]);
+	t_param.max_throughput_rate =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MAX_TP]);
+	t_param.burst_size =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_BURST_SIZE]);
+	t_param.service_interval =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_INTERVAL]);
+	t_param.delay_bound =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_DELAY_BOUND]);
+	t_param.msdu_ttl =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MSDU_TTL]);
+	t_param.msdu_rate_loss =
+		nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MSDU_RATE_LOSS ]);
+
+	ret = ath12k_telemetry_sawf_sla_detection_config(t_param);
+
+	return ret;
+}
+
+static struct ath12k *ath12k_get_ar_from_wdev(struct wireless_dev *wdev, u8 link_id)
+{
+	struct ieee80211_vif *vif =  NULL;
+	struct ath12k_vif *ahvif = NULL;
+	struct ieee80211_hw *hw = NULL;
+	struct ath12k *ar = NULL;
+
+	vif = wdev_to_ieee80211_vif(wdev);
+	if (!vif)
+		return NULL;
+
+	ahvif = (struct ath12k_vif *)vif->drv_priv;
+	if (!ahvif)
+		return NULL;
+
+	mutex_lock(&ahvif->ah->conf_mutex);
+	hw = ahvif->ah->hw;
+	if (!hw) {
+		mutex_unlock(&ahvif->ah->conf_mutex);
+		return NULL;
+	}
+
+	ar = ath12k_get_ar_by_vif(hw, vif, link_id);
+	mutex_unlock(&ahvif->ah->conf_mutex);
+
+	return ar;
+}
+
+static int ath12k_vendor_sdwf_streaming_stats_configure(struct wireless_dev *wdev,
+							struct nlattr *streaming_stats)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_MAX + 1];
+	struct ath12k *ar = NULL;
+	int ret = 0;
+	u8 basic_stats_configure, extnd_stats_configure, link_id;
+
+
+	ret = nla_parse_nested(tb, QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_MAX,
+			       streaming_stats,
+			       ath12k_vendor_sawf_streaming, NULL);
+	if (ret) {
+		ath12k_warn(NULL, "invalid sawf streaming stats configuration\n");
+		return ret;
+	}
+
+	if (wdev->valid_links) { /* MLO case */
+		if (!tb[QCA_WLAN_VENDOR_ATTR_SDWF_MLO_LINK_ID])
+			return -EINVAL;
+		link_id = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_MLO_LINK_ID]);
+		if (!(wdev->valid_links & BIT(link_id)))
+			return -ENOLINK;
+	} else { /* NON-MLO case */
+		if (!tb[QCA_WLAN_VENDOR_ATTR_SDWF_MLO_LINK_ID])
+			link_id = 0;
+		else
+			return -EINVAL;
+	}
+
+	ar = ath12k_get_ar_from_wdev(wdev, link_id);
+	if (!ar)
+		return -ENODATA;
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_BASIC_STATS]) {
+		basic_stats_configure = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_BASIC_STATS]);
+		ret = ath12k_htt_sawf_streaming_stats_configure(ar, HTT_STRM_GEN_MPDUS_STATS,
+								basic_stats_configure, 0, 0, 0, 0);
+		if (ret)
+			return ret;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_EXTND_STATS]) {
+		extnd_stats_configure = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_EXTND_STATS]);
+		ret = ath12k_htt_sawf_streaming_stats_configure(ar, HTT_STRM_GEN_MPDUS_DETAILS_STATS,
+								extnd_stats_configure, 0, 0, 0, 0);
+	}
+
+	return ret;
+}
+
 static int telemetry_build_nd_send_reply_msg(struct wiphy *wiphy, struct stats_config *cfg,
 					     u8 *mac_addr, struct unified_stats *stats)
 {
@@ -261,13 +950,273 @@ static int ath12k_vendor_ds_handler(stru
 
 	return 0;
 }
+
+static int ath12k_vendor_telemetry_sla_reset_stats(struct nlattr *clr_stats)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_MAX + 1];
+	int ret = 0;
+	u8 svc_id, mac_addr[ETH_ALEN] = { 0 }, mld_mac_addr[ETH_ALEN] = { 0 }, set_clear;
+
+	ret = nla_parse_nested(tb, QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_MAX,
+			       clr_stats,
+			       ath12k_telemetric_sla_policy, NULL);
+
+	if (ret) {
+		ath12k_err(NULL, "Invalid attribute with telemetry sla reset stats command\n");
+		return ret;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_SVC_ID])
+		svc_id = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_SVC_ID]);
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MAC] &&
+	    (nla_len(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MAC]) == ETH_ALEN))
+		memcpy(mac_addr, nla_data(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MAC]),
+		       ETH_ALEN);
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MLD_MAC] &&
+	(nla_len(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MLD_MAC]) == ETH_ALEN))
+		memcpy(mld_mac_addr, nla_data(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MLD_MAC]),
+		       ETH_ALEN);
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_SET_CLEAR])
+		set_clear = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_SET_CLEAR]);
+
+	return ath12k_telemetry_sla_reset_stats(svc_id, mac_addr, mld_mac_addr,
+						set_clear);
+}
+
 void ath12k_vendor_telemetry_notify_breach(struct ieee80211_vif *vif, u8 *mac_addr,
 					   u8 svc_id, u8 param, bool set_clear,
 					   u8 tid, u8 *mld_addr)
 {
+	struct nlattr *notify_params;
+	struct wireless_dev *wdev;
+	struct sk_buff *skb;
+	u8 access_category;
+
+	wdev = ieee80211_vif_to_wdev(vif);
+
+	if (!wdev)
+		return;
+
+	if (!wdev->wiphy)
+		return;
+
+	skb = cfg80211_vendor_event_alloc(wdev->wiphy, wdev, NLMSG_DEFAULT_SIZE,
+					  0, GFP_KERNEL);
+	if (!skb) {
+		ath12k_err(NULL, "No memory available to send notify breach event\n");
+		return;
+	}
+
+	switch (tid) {
+	case 0:
+	case 3:
+		access_category = 0; //AC_BE
+		break;
+	case 1:
+	case 2:
+		access_category = 1; //AC_BK
+		break;
+	case 4:
+	case 5:
+		access_category = 2; //AC_VI
+		break;
+	case 6:
+	case 7:
+		access_category = 3; //AC_VO
+		break;
+	default:
+		ath12k_err(NULL, "Invalid TID = %u for notifying breach event\n", tid);
+		goto err;
+	}
+
+	notify_params = nla_nest_start(skb, QCA_WLAN_VENDOR_ATTR_SDWF_DEV_SLA_BREACHED_PARAMS);
+	if (!notify_params)
+		goto err;
+	if (nla_put(skb, QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MAC, ETH_ALEN, mac_addr) ||
+	    (mld_addr && nla_put(skb, QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MLD_MAC,
+	    ETH_ALEN, mld_addr)) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_SVC_ID, svc_id) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_TYPE, param) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_SET_CLEAR, set_clear) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_AC, access_category)) {
+		ath12k_err(NULL, "No memory available at NL to send notify breach event\n");
+		goto err;
+	}
+
+	nla_nest_end(skb, notify_params);
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	return;
+err:
+	kfree(skb);
 	return;
 }
 
+static int ath12k_vendor_sdwf_phy_operations(struct wiphy *wiphy,
+					     struct wireless_dev *wdev,
+					     const void *data,
+					     int data_len)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_MAX + 1];
+	u8 sdwf_oper;
+	int ret = 0;
+
+	if (!ath12k_sawf_enable)
+		return -EOPNOTSUPP;
+
+	ret = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SDWF_PHY_MAX, data, data_len,
+			 ath12k_vendor_sdwf_phy_policy, NULL);
+	if (ret) {
+		ath12k_err(NULL, "Invalid attributes with SAWF radio level commands\n");
+		goto end;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_OPERATION]) {
+		sdwf_oper = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_OPERATION]);
+	} else {
+		ath12k_err(NULL, "SAWF radio level operation missing\n");
+		ret = -EINVAL;
+		goto end;
+	}
+
+	switch (sdwf_oper) {
+	case QCA_WLAN_VENDOR_SDWF_PHY_OPER_SVC_SET:
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SVC_PARAMS]) {
+			ret = ath12k_vendor_set_sdwf_config(wiphy, wdev,
+							    tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SVC_PARAMS]);
+		} else {
+			ath12k_err(NULL, "SAWF svc parameters missing\n");
+			ret = -EINVAL;
+			goto end;
+		}
+		break;
+	case QCA_WLAN_VENDOR_SDWF_PHY_OPER_SVC_DEL:
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SVC_PARAMS]) {
+			ret = ath12k_vendor_disable_sdwf_config(tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SVC_PARAMS]);
+		} else {
+			ath12k_err(NULL, "SAWF service id missing with delete operation\n");
+			ret = -EINVAL;
+			goto end;
+		}
+		break;
+	case QCA_WLAN_VENDOR_SDWF_PHY_OPER_SLA_SAMPLES_SET:
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_SAMPLES_PARAMS]) {
+			ret = ath12k_vendor_telemetry_sdwf_sla_samples_config(tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_SAMPLES_PARAMS]);
+		} else {
+			ath12k_err(NULL, "SAWF sla samples parameters missing\n");
+			ret = -EINVAL;
+			goto end;
+		}
+		break;
+	case QCA_WLAN_VENDOR_SDWF_PHY_OPER_SLA_BREACH_DETECTION_SET:
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_DETECT_PARAMS]) {
+			ret = ath12k_vendor_telemetry_sdwf_sla_detection_config(tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_DETECT_PARAMS]);
+		} else {
+			ath12k_err(NULL, "SAWF sla breach detect parameters missing\n");
+			ret = -EINVAL;
+			goto end;
+		}
+		break;
+	case QCA_WLAN_VENDOR_SDWF_PHY_OPER_SLA_THRESHOLD_SET:
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_THRESHOLD_PARAMS]) {
+			ret = ath12k_vendor_telemetry_sdwf_sla_thershold_config(tb[QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_THRESHOLD_PARAMS]);
+		} else {
+			ath12k_err(NULL, "SAWF sla threshold parameters missing\n");
+			ret = -EINVAL;
+			goto end;
+		}
+		break;
+	default:
+		ath12k_err(NULL, "Invalid operation with SAWF radio level commands\n");
+		ret = -EINVAL;
+	}
+end:
+	return ret;
+}
+
+static int ath12k_vendor_sdwf_dev_operations(struct wiphy *wiphy,
+					     struct wireless_dev *wdev,
+					     const void *data,
+					     int data_len)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_MAX + 1];
+	u8 sdwf_oper;
+	int ret = 0;
+
+	if (!ath12k_sawf_enable)
+		return -EOPNOTSUPP;
+
+	ret = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SDWF_DEV_MAX, data, data_len,
+			ath12k_vendor_sdwf_dev_policy, NULL);
+	if (ret) {
+		ath12k_err(NULL, "Invalid attributes with SAWF device level commands\n");
+		goto end;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_OPERATION]) {
+		sdwf_oper = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_OPERATION]);
+	} else {
+		ath12k_err(NULL, "SAWF device level operation missing\n");
+		ret = -EINVAL;
+		goto end;
+	}
+
+	switch (sdwf_oper) {
+	case QCA_WLAN_VENDOR_SDWF_DEV_OPER_DEF_Q_MAP:
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_DEF_Q_PARAMS]) {
+			ret = ath12k_vendor_sdwf_def_qmap_req(wdev,
+							      tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_DEF_Q_PARAMS]);
+		} else {
+			ath12k_err(NULL, "SAWF default Queue map parameters missing\n");
+			ret = -EINVAL;
+			goto end;
+		}
+		break;
+	case QCA_WLAN_VENDOR_SDWF_DEV_OPER_DEF_Q_UNMAP:
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_DEF_Q_PARAMS]) {
+			ret = ath12k_vendor_sdwf_def_qunmap_req(wdev, tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_DEF_Q_PARAMS]);
+		} else {
+			ath12k_err(NULL, "SAWF default Queue unmap parameters missing\n");
+			ret = -EINVAL;
+			goto end;
+		}
+		break;
+	case QCA_WLAN_VENDOR_SDWF_DEV_OPER_DEF_Q_MAP_GET:
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_DEF_Q_PARAMS]) {
+			ret = ath12k_vendor_sdwf_def_qmap_report_req(wdev, tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_DEF_Q_PARAMS]);
+		} else {
+			ath12k_err(NULL, "SAWF default Queue map report parameters missing\n");
+			ret = -EINVAL;
+			goto end;
+		}
+		break;
+	case QCA_WLAN_VENDOR_SDWF_DEV_OPER_STREAMING_STATS:
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_STREAMING_STATS_PARAMS]) {
+			ret = ath12k_vendor_sdwf_streaming_stats_configure(wdev, tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_STREAMING_STATS_PARAMS]);
+		} else {
+			ath12k_err(NULL, "SAWF default streaming statsparameters missing\n");
+			ret = -EINVAL;
+			goto end;
+		}
+		break;
+	case QCA_WLAN_VENDOR_SDWF_DEV_OPER_RESET_STATS:
+		if (tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_RESET_STATS]) {
+			ret = ath12k_vendor_telemetry_sla_reset_stats(tb[QCA_WLAN_VENDOR_ATTR_SDWF_DEV_RESET_STATS]);
+		} else {
+			ath12k_err(NULL, "SAWF clear telemetry stats parameters missing\n");
+			ret = -EINVAL;
+			goto end;
+		}
+		break;
+	default:
+		ath12k_err(NULL, "Invalid operation = %d with SAWF device level commands\n", sdwf_oper);
+		ret = -EINVAL;
+	}
+end:
+	return ret;
+}
 #endif /* CPTCFG_ATH12K_SAWF */
 
 #define NL_VENDOR_GET_ATTR(res, info, attr, bit) \
@@ -317,6 +1266,22 @@ static struct wiphy_vendor_command ath12
 #ifdef CPTCFG_ATH12K_SAWF
 	{
 		.info.vendor_id = QCA_NL80211_VENDOR_ID,
+		.info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SDWF_PHY_OPS,
+		.doit = ath12k_vendor_sdwf_phy_operations,
+		.dumpit = ath12k_vendor_view_sdwf_config,
+		.policy = ath12k_vendor_sdwf_phy_policy,
+		.maxattr = QCA_WLAN_VENDOR_ATTR_SDWF_PHY_MAX,
+	},
+	{
+		.info.vendor_id = QCA_NL80211_VENDOR_ID,
+		.info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SDWF_DEV_OPS,
+		.doit = ath12k_vendor_sdwf_dev_operations,
+		.policy = ath12k_vendor_sdwf_dev_policy,
+		.maxattr = QCA_WLAN_VENDOR_ATTR_SDWF_DEV_MAX,
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+	},
+	{
+		.info.vendor_id = QCA_NL80211_VENDOR_ID,
 		.info.subcmd = QCA_NL80211_VENDOR_SUBCMD_TELEMETRIC_DATA,
 		.doit = ath12k_vendor_telemetry_getstats,
 		.policy = ath12k_telemetric_req_policy,
@@ -343,6 +1308,12 @@ static struct wiphy_vendor_command ath12
 };
 
 static const struct nl80211_vendor_cmd_info ath12k_vendor_events[] = {
+#ifdef CPTCFG_ATH12K_SAWF
+	{
+		.vendor_id = QCA_NL80211_VENDOR_ID,
+		.subcmd = QCA_NL80211_VENDOR_SUBCMD_SDWF_DEV_OPS,
+	},
+#endif
 };
 
 int ath12k_vendor_register(struct ath12k_hw *ah)
--- a/drivers/net/wireless/ath/ath12k/vendor.h
+++ b/drivers/net/wireless/ath/ath12k/vendor.h
@@ -12,11 +12,194 @@ enum qca_nl80211_vendor_subcmds {
 	QCA_NL80211_VENDOR_SUBCMD_SET_WIFI_CONFIGURATION = 74,
 	QCA_NL80211_VENDOR_SUBCMD_SCS_RULE_CONFIG = 218,
 #ifdef CPTCFG_ATH12K_SAWF
+	QCA_NL80211_VENDOR_SUBCMD_SDWF_PHY_OPS = 235,
+	QCA_NL80211_VENDOR_SUBCMD_SDWF_DEV_OPS = 236,
 	QCA_NL80211_VENDOR_SUBCMD_TELEMETRIC_DATA = 334,
 #endif
 };
 
 #ifdef CPTCFG_ATH12K_SAWF
+enum qca_wlan_vendor_attr_sdwf_phy {
+	QCA_WLAN_VENDOR_ATTR_SDWF_PHY_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SDWF_PHY_OPERATION = 1,
+	QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SVC_PARAMS = 2,
+	QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_SAMPLES_PARAMS = 3,
+	QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_DETECT_PARAMS = 4,
+	QCA_WLAN_VENDOR_ATTR_SDWF_PHY_SLA_THRESHOLD_PARAMS = 5,
+
+	/* keep last */
+	QCA_WLAN_VENDOR_ATTR_SDWF_PHY_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SDWF_PHY_MAX =
+	QCA_WLAN_VENDOR_ATTR_SDWF_PHY_AFTER_LAST - 1,
+};
+
+enum qca_wlan_vendor_sdwf_phy_oper {
+	QCA_WLAN_VENDOR_SDWF_PHY_OPER_SVC_SET = 0,
+	QCA_WLAN_VENDOR_SDWF_PHY_OPER_SVC_DEL = 1,
+	QCA_WLAN_VENDOR_SDWF_PHY_OPER_SVC_GET = 2,
+	QCA_WLAN_VENDOR_SDWF_PHY_OPER_SLA_SAMPLES_SET = 3,
+	QCA_WLAN_VENDOR_SDWF_PHY_OPER_SLA_BREACH_DETECTION_SET = 4,
+	QCA_WLAN_VENDOR_SDWF_PHY_OPER_SLA_THRESHOLD_SET = 5,
+};
+
+enum qca_wlan_vendor_attr_sdwf_svc {
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_ID = 1,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MIN_TP = 2,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX_TP = 3,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_BURST_SIZE = 4,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_INTERVAL = 5,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_DELAY_BOUND = 6,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MSDU_TTL = 7,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_PRIO = 8,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_TID = 9,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MSDU_RATE_LOSS = 10,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_SVC_INTERVAL = 11,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MIN_TPUT = 12,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MAX_LATENCY = 13,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_BURST_SIZE = 14,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_OFDMA_DISABLE = 15,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_UL_MU_MIMO_DISABLE = 16,
+	/* The below are used by MCC */
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_BUFFER_LATENCY_TOLERANCE = 17,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_TX_TRIGGER_DSCP = 18,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_TX_REPLACE_DSCP = 19,
+
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_MAX =
+	QCA_WLAN_VENDOR_ATTR_SDWF_SVC_AFTER_LAST - 1,
+};
+
+enum qca_wlan_vendor_attr_sdwf_sla_samples {
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_MOVING_AVG_PKT = 1,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_MOVING_AVG_WIN = 2,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_SLA_NUM_PKT = 3,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_SLA_TIME_SEC = 4,
+
+	/* keep last */
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_MAX =
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_SAMPLES_AFTER_LAST - 1,
+};
+
+enum qca_wlan_vendor_attr_sdwf_sla_detect {
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_PARAM = 1,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MIN_TP = 2,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MAX_TP = 3,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_BURST_SIZE = 4,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_INTERVAL = 5,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_DELAY_BOUND = 6,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MSDU_TTL = 7,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MSDU_RATE_LOSS = 8,
+
+	/* keep last */
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_MAX =
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_DETECT_AFTER_LAST - 1,
+};
+
+enum qca_wlan_vendor_sdwf_sla_detect_param {
+	QCA_WLAN_VENDOR_SDWF_SLA_DETECT_PARAM_NUM_PACKET,
+	QCA_WLAN_VENDOR_SDWF_SLA_DETECT_PARAM_PER_SECOND,
+	QCA_WLAN_VENDOR_SDWF_SLA_DETECT_PARAM_MOV_AVG,
+	QCA_WLAN_VENDOR_SDWF_SLA_DETECT_PARAM_NUM_SECOND,
+	QCA_WLAN_VENDOR_SDWF_SLA_DETECT_PARAM_MAX,
+};
+
+enum qca_wlan_vendor_attr_sdwf_sla_threshold {
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_SVC_ID = 1,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MIN_TP = 2,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MAX_TP = 3,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_BURST_SIZE = 4,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_INTERVAL = 5,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_DELAY_BOUND = 6,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MSDU_TTL = 7,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MSDU_RATE_LOSS = 8,
+
+	/* keep last */
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_MAX =
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_THRESHOLD_AFTER_LAST - 1,
+};
+
+enum qca_wlan_vendor_attr_sdwf_dev {
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEV_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEV_OPERATION = 1,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEV_DEF_Q_PARAMS = 2,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEV_STREAMING_STATS_PARAMS = 3,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEV_RESET_STATS = 4,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEV_SLA_BREACHED_PARAMS = 5,
+
+	/* keep last */
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEV_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEV_MAX =
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEV_AFTER_LAST - 1,
+};
+
+enum qca_wlan_vendor_sdwf_dev_oper {
+	QCA_WLAN_VENDOR_SDWF_DEV_OPER_DEF_Q_MAP = 0,
+	QCA_WLAN_VENDOR_SDWF_DEV_OPER_DEF_Q_UNMAP = 1,
+	QCA_WLAN_VENDOR_SDWF_DEV_OPER_DEF_Q_MAP_GET = 2,
+	QCA_WLAN_VENDOR_SDWF_DEV_OPER_STREAMING_STATS = 3,
+	QCA_WLAN_VENDOR_SDWF_DEV_OPER_RESET_STATS = 4,
+	QCA_WLAN_VENDOR_SDWF_DEV_OPER_BREACH_DETECTED = 5,
+};
+
+enum qca_wlan_vendor_attr_sdwf_def_q_map {
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_SVC_ID = 1,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAC_ADDR = 2,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_TID = 3,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_STATUS = 4,
+
+	/* keep last */
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_MAX =
+	QCA_WLAN_VENDOR_ATTR_SDWF_DEF_Q_MAP_AFTER_LAST - 1,
+};
+
+enum qca_wlan_vendor_attr_sdwf_streaming_stats {
+	QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_BASIC_STATS = 1,
+	QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_EXTND_STATS = 2,
+	QCA_WLAN_VENDOR_ATTR_SDWF_MLO_LINK_ID = 3,
+
+	/* keep last */
+	QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_MAX =
+	QCA_WLAN_VENDOR_ATTR_SDWF_STREAMING_AFTER_LAST - 1,
+};
+
+enum qca_wlan_vendor_attr_sdwf_sla_breach_param {
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MAC = 1,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_SVC_ID = 2,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_TYPE = 3,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_SET_CLEAR = 4,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_PEER_MLD_MAC = 5,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_AC = 6,
+
+	/* Keep last */
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_MAX =
+	QCA_WLAN_VENDOR_ATTR_SDWF_SLA_BREACH_PARAM_AFTER_LAST - 1
+};
+
+enum qca_wlan_vendor_sdwf_sla_breach_type {
+	QCA_WLAN_VENDOR_SDWF_SLA_BREACH_PARAM_TYPE_INVALID = 0,
+	QCA_WLAN_VENDOR_SDWF_SLA_BREACH_PARAM_TYPE_MIN_THROUGHPUT,
+	QCA_WLAN_VENDOR_SDWF_SLA_BREACH_PARAM_TYPE_MAX_THROUGHPUT,
+	QCA_WLAN_VENDOR_SDWF_SLA_BREACH_PARAM_TYPE_BURST_SIZE,
+	QCA_WLAN_VENDOR_SDWF_SLA_BREACH_PARAM_TYPE_SERVICE_INTERVAL,
+	QCA_WLAN_VENDOR_SDWF_SLA_BREACH_PARAM_TYPE_DELAY_BOUND,
+	QCA_WLAN_VENDOR_SDWF_SLA_BREACH_PARAM_TYPE_MSDU_TTL,
+	QCA_WLAN_VENDOR_SDWF_SLA_BREACH_PARAM_TYPE_MSDU_LOSS,
+	QCA_WLAN_VENDOR_SDWF_SLA_BREACH_PARAM_TYPE_MAX,
+};
+
 /**
  * enum qca_wlan_vendor_attr_telemetric: Defines attributes to be used in
  * request message of QCA_NL80211_VENDOR_SUBCMD_TELEMETRIC_DATA vendor command.
