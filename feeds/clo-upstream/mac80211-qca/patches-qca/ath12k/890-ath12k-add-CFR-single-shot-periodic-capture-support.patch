From 84fb65f43e0ab3bd136d96493c2884bf28218a1d Mon Sep 17 00:00:00 2001
From: Thomas Wu <quic_wthomas@quicinc.com>
Date: Wed, 14 Feb 2024 14:58:37 -0800
Subject: [PATCH] ath12k: add CFR single shot/periodic capture support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This change is to add single shot/periodic CFR capture
support for ath12k chipsets.

To enable/disable CFR feature use command,
echo <val> > /sys/kernel/debug/ieee80211/phyX/ath12k/enable_cfr
where, val: 0 to disable CFR and 1 to enable CFR.

To enable CFR capture for associated peers,
echo "<val> <bw> <periodicity> <method>"
 > /sys/kernel/debug/ieee80211/phyX/netdev\:wlanx/stations/<mac>/cfr_capture0

Val: 0 - stop CFR capture
         1 - start CFR capture
BW: CFR capture bandwidth
        0 - 20MHZ
        1 - 40MHZ
        2 - 80MHZ
Periodicity: Periodicity at which hardware is expected to collect CFR dump.
        0 - single shot capture.
        non zero - for Periodic captures (value should be multiple of 10).
Method: Method used by hardware to collect the CFR dump.
        0 - from the ACKs of QOS NULL packets.

To enable CFR capture for unassociated clients,
echo “<mac address> <val> <periodicity>”
 > /sys/kernel/debug/ieee80211/phyX/ath12k/cfr_unassoc

Mac address: mac address of the client.
Val: 0 - start CFR capture
     1 – stop CFR capture
Periodicity: Periodicity at which hardware is expected to collect CFR dump.
        0 - single shot capture.
        non zero - for Periodic captures (value should be multiple of 10).

To collect the cfr dump,
cat /sys/kernel/debug/ieee80211/phy0/ath12k/cfr_capture0 > /tmp/cfr.bin

Signed-off-by: Thomas Wu <quic_wthomas@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/Kconfig       |   9 +
 drivers/net/wireless/ath/ath12k/Makefile      |   1 +
 drivers/net/wireless/ath/ath12k/cfr.c         | 890 ++++++++++++++++++
 drivers/net/wireless/ath/ath12k/cfr.h         | 445 +++++++++
 drivers/net/wireless/ath/ath12k/core.c        |   7 +
 drivers/net/wireless/ath/ath12k/core.h        |  14 +
 drivers/net/wireless/ath/ath12k/dbring.c      |  27 +-
 drivers/net/wireless/ath/ath12k/dbring.h      |   7 +
 drivers/net/wireless/ath/ath12k/debug.h       |   2 +
 drivers/net/wireless/ath/ath12k/debugfs_sta.c | 165 ++++
 drivers/net/wireless/ath/ath12k/hw.c          | 184 ++++
 drivers/net/wireless/ath/ath12k/hw.h          |  10 +
 drivers/net/wireless/ath/ath12k/mac.c         |  11 +-
 drivers/net/wireless/ath/ath12k/wmi.c         | 157 ++-
 drivers/net/wireless/ath/ath12k/wmi.h         |  98 +-
 local-symbols                                 |   1 +
 16 files changed, 2012 insertions(+), 16 deletions(-)
 create mode 100644 drivers/net/wireless/ath/ath12k/cfr.c
 create mode 100644 drivers/net/wireless/ath/ath12k/cfr.h

--- a/drivers/net/wireless/ath/ath12k/Kconfig
+++ b/drivers/net/wireless/ath/ath12k/Kconfig
@@ -74,6 +74,15 @@ config ATH12K_MEM_PROFILE_512M
 	---help---
 	Enables 512MB memory profile for ath12k
 
+config ATH12K_CFR
+	bool "QCA ath12k CFR support"
+	depends on ATH12K_DEBUGFS
+	depends on RELAY
+	help
+	  Enable ath12k cfr dump support
+
+	  Say Y to enable access to collect cfr data dump via debugfs.
+
 config ATH12K_PPE_DS_SUPPORT
 	bool "QTI ath12k ppe-ds support"
 	depends on ATH12K_DEBUGFS
--- a/drivers/net/wireless/ath/ath12k/Makefile
+++ b/drivers/net/wireless/ath/ath12k/Makefile
@@ -36,6 +36,7 @@ ath12k-$(CPTCFG_ATH12K_AHB) += ahb.o
 ath12k-$(CPTCFG_ATH12K_PPE_DS_SUPPORT) += ppe.o
 ath12k-$(CPTCFG_ATH12K_BONDED_DS_SUPPORT) += bondif.o
 ath12k-$(CPTCFG_ATH12K_SAWF) += sawf.o telemetry.o telemetry_agent_if.o
+ath12k-$(CPTCFG_ATH12K_CFR) += cfr.o
 
 # for tracing framework to find trace.h
 CFLAGS_trace.o := -I$(src)
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/cfr.c
@@ -0,0 +1,891 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#include <linux/relay.h>
+#include "core.h"
+#include "debug.h"
+
+bool peer_is_in_cfr_unassoc_pool(struct ath12k *ar, u8 *peer_mac)
+{
+	struct ath12k_cfr *cfr = &ar->cfr;
+	struct cfr_unassoc_pool_entry *entry;
+	int i;
+
+	if (!ar->cfr.cfr_enabled)
+		return false;
+
+	spin_lock_bh(&cfr->lock);
+	for (i = 0; i < ATH12K_MAX_CFR_ENABLED_CLIENTS; i++) {
+		entry = &cfr->unassoc_pool[i];
+		if (!entry->is_valid)
+			continue;
+
+		if (ether_addr_equal(peer_mac, entry->peer_mac)) {
+			/* Remove entry if it is single shot */
+			if (entry->period == 0) {
+				memset(entry->peer_mac, 0 , ETH_ALEN);
+				entry->is_valid = false;
+				cfr->cfr_enabled_peer_cnt--;
+			}
+			spin_unlock_bh(&cfr->lock);
+			return true;
+		}
+	}
+
+	spin_unlock_bh(&cfr->lock);
+
+	return false;
+}
+
+void ath12k_cfr_lut_update_paddr(struct ath12k *ar, dma_addr_t paddr,
+				 u32 buf_id)
+{
+	struct ath12k_cfr *cfr = &ar->cfr;
+	struct ath12k_cfr_look_up_table *lut;
+
+	if (cfr->lut) {
+		lut = &cfr->lut[buf_id];
+		lut->dbr_address = paddr;
+	}
+}
+
+void ath12k_cfr_decrement_peer_count(struct ath12k *ar,
+				     struct ath12k_link_sta *arsta)
+{
+	struct ath12k_cfr *cfr = &ar->cfr;
+
+	spin_lock_bh(&cfr->lock);
+
+	if (cfr->cfr_enabled_peer_cnt == 0) {
+		spin_unlock_bh(&cfr->lock);
+		return;
+	}
+
+	if (arsta->cfr_capture.cfr_enable)
+		cfr->cfr_enabled_peer_cnt--;
+
+	spin_unlock_bh(&cfr->lock);
+}
+
+struct ath12k_dbring *ath12k_cfr_get_dbring(struct ath12k *ar)
+{
+	if (ar->cfr.cfr_enabled)
+		return &ar->cfr.rx_ring;
+
+	return NULL;
+}
+
+static inline
+void ath12k_cfr_release_lut_entry(struct ath12k_cfr_look_up_table *lut)
+{
+	memset(lut, 0, sizeof(*lut));
+}
+
+static void ath12k_cfr_rfs_write(struct ath12k *ar, const void *head,
+				 u32 head_len, const void *data, u32 data_len,
+				 const void * tail, int tail_data)
+{
+	struct ath12k_cfr *cfr = &ar->cfr;
+
+	if (!ar->cfr.rfs_cfr_capture)
+		return;
+
+	relay_write(cfr->rfs_cfr_capture, head, head_len);
+	relay_write(cfr->rfs_cfr_capture, data, data_len);
+	relay_write(cfr->rfs_cfr_capture, tail, tail_data);
+	relay_flush(cfr->rfs_cfr_capture);
+}
+
+static void ath12k_cfr_free_pending_dbr_events(struct ath12k *ar)
+{
+	struct ath12k_cfr *cfr = &ar->cfr;
+	struct ath12k_cfr_look_up_table *lut = NULL;
+	int i;
+
+	if (!cfr->lut)
+		return;
+
+	for (i = 0; i < cfr->lut_num; i++) {
+		lut = &cfr->lut[i];
+		if (lut->dbr_recv && !lut->tx_recv &&
+		    (lut->dbr_tstamp < cfr->last_success_tstamp)) {
+			ath12k_dbring_bufs_replenish(ar, &cfr->rx_ring, lut->buff,
+						     WMI_DIRECT_BUF_CFR, GFP_ATOMIC);
+			ath12k_cfr_release_lut_entry(lut);
+			cfr->flush_dbr_cnt++;
+		}
+	}
+}
+
+/* Correlate and relay: This function correlate the data coming from
+ * WMI_PDEV_DMA_RING_BUF_RELEASE_EVENT(DBR event) and
+ * WMI_PEER_CFR_CAPTURE_EVENT(Tx capture event). if both the events
+ * are received and PPDU id matches from the both events,
+ * return CORRELATE_STATUS_RELEASE which means relay the correlated data
+ * to user space. Otherwise return CORRELATE_STATUS_HOLD which means wait
+ * for the second event to come. It will return CORRELATE_STATUS_ERR in
+ * case of any error.
+ *
+ * It also check for the pending DBR events and clear those events
+ * in case of corresponding TX capture event is not received for
+ * the PPDU.
+ */
+
+static int ath12k_cfr_correlate_and_relay(struct ath12k *ar,
+					  struct ath12k_cfr_look_up_table *lut,
+					  u8 event_type)
+{
+	struct ath12k_cfr *cfr = &ar->cfr;
+	u64 diff;
+
+	if (event_type == ATH12K_CORRELATE_TX_EVENT) {
+		if (lut->tx_recv)
+			cfr->cfr_dma_aborts++;
+		cfr->tx_evt_cnt++;
+		lut->tx_recv = true;
+	} else if (event_type == ATH12K_CORRELATE_DBR_EVENT) {
+		cfr->dbr_evt_cnt++;
+		lut->dbr_recv = true;
+	}
+
+	if (lut->dbr_recv && lut->tx_recv) {
+		if (lut->dbr_ppdu_id == lut->tx_ppdu_id) {
+			cfr->last_success_tstamp = lut->dbr_tstamp;
+			if (lut->dbr_tstamp > lut->txrx_tstamp) {
+				diff = lut->dbr_tstamp - lut->txrx_tstamp;
+				ath12k_dbg(ar->ab, ATH12K_DBG_CFR,
+					   "txrx event -> dbr event delay = %u ms",
+					   jiffies_to_msecs(diff));
+			} else if (lut->txrx_tstamp > lut->dbr_tstamp) {
+				diff = lut->txrx_tstamp - lut->dbr_tstamp;
+				ath12k_dbg(ar->ab, ATH12K_DBG_CFR,
+					   "dbr event -> txrx event delay = %u ms",
+					   jiffies_to_msecs(diff));
+			}
+			ath12k_cfr_free_pending_dbr_events(ar);
+
+			cfr->release_cnt++;
+			return ATH12K_CORRELATE_STATUS_RELEASE;
+		} else {
+			/*
+			 * When there is a ppdu id mismatch, discard the TXRX
+			 * event since multiple PPDUs are likely to have same
+			 * dma addr, due to ucode aborts.
+			 */
+
+			ath12k_dbg(ar->ab, ATH12K_DBG_CFR,
+				   "Received dbr event twice for the same lut entry");
+			lut->tx_recv = false;
+			lut->tx_ppdu_id = 0;
+			cfr->clear_txrx_event++;
+			cfr->cfr_dma_aborts++;
+			return ATH12K_CORRELATE_STATUS_HOLD;
+		}
+	} else {
+		return ATH12K_CORRELATE_STATUS_HOLD;
+	}
+}
+
+static u8 freeze_reason_to_capture_type(struct ath12k_base *ab, void *freeze_tlv)
+{
+	struct macrx_freeze_capture_channel *freeze =
+		(struct macrx_freeze_capture_channel_v3 *)freeze_tlv;
+	u8 capture_reason = FIELD_GET(MACRX_FREEZE_CC_INFO0_CAPTURE_REASON,
+				      freeze->info0);
+
+	switch (capture_reason) {
+	case FREEZE_REASON_TM:
+		return CFR_CAPTURE_METHOD_TM;
+	case FREEZE_REASON_FTM:
+		return CFR_CAPTURE_METHOD_FTM;
+	case FREEZE_REASON_TA_RA_TYPE_FILTER:
+		return CFR_CAPTURE_METHOD_TA_RA_TYPE_FILTER;
+	case FREEZE_REASON_NDPA_NDP:
+		return CFR_CAPTURE_METHOD_NDPA_NDP;
+	case FREEZE_REASON_ALL_PACKET:
+		return CFR_CAPTURE_METHOD_ALL_PACKET;
+	case FREEZE_REASON_ACK_RESP_TO_TM_FTM:
+		return CFR_CAPTURE_METHOD_ACK_RESP_TO_TM_FTM;
+	default:
+		ath12k_dbg(ab, ATH12K_DBG_CFR,
+			   "CFR Capture Method Type not found");
+	}
+
+	return CFR_CAPTURE_METHOD_AUTO;
+}
+
+static void extract_peer_mac_from_freeze_tlv(void *freeze_tlv, uint8_t *peermac)
+{
+	struct macrx_freeze_capture_channel_v3 *freeze =
+		(struct macrx_freeze_capture_channel_v3 *)freeze_tlv;
+
+	peermac[0] = freeze->packet_ta_lower_16 & 0x00FF;
+	peermac[1] = (freeze->packet_ta_lower_16 & 0xFF00) >> 8;
+	peermac[2] = freeze->packet_ta_mid_16 & 0x00FF;
+	peermac[3] = (freeze->packet_ta_mid_16 & 0xFF00) >> 8;
+	peermac[4] = freeze->packet_ta_upper_16 & 0x00FF;
+	peermac[5] = (freeze->packet_ta_upper_16 & 0xFF00) >> 8;
+}
+
+static int ath12k_cfr_enh_process_data(struct ath12k *ar,
+				       struct ath12k_dbring_data *param)
+{
+	struct ath12k_base *ab = ar->ab;
+	struct ath12k_cfr *cfr = &ar->cfr;
+	struct ath12k_cfr_look_up_table *lut;
+	struct ath12k_csi_cfr_header *header;
+	struct ath12k_cfir_enh_dma_hdr dma_hdr;
+	struct cfr_enh_metadata *meta;
+	void *mu_rx_user_info = NULL, *freeze_tlv = NULL;
+	u8 *peer_macaddr;
+	u8 *data;
+	u32 buf_id;
+	u32 length;
+	u32 freeze_tlv_len = 0;
+	u32 end_magic = ATH12K_CFR_END_MAGIC;
+	u8 freeze_tlv_ver;
+	u8 capture_type;
+	int ret = 0;
+	int status;
+
+	data = param->data;
+	buf_id = param->buf_id;
+
+	memcpy(&dma_hdr, data, sizeof(struct ath12k_cfir_enh_dma_hdr));
+
+	freeze_tlv_ver = FIELD_GET(CFIR_DMA_HDR_INFO2_FREEZ_TLV_VER, dma_hdr.info2);
+
+	if (FIELD_GET(CFIR_DMA_HDR_INFO2_FREEZ_DATA_INC, dma_hdr.info2)) {
+		freeze_tlv = data + sizeof(struct ath12k_cfir_enh_dma_hdr);
+		capture_type = freeze_reason_to_capture_type(ab, freeze_tlv);
+	} else {
+		capture_type = CFR_CAPTURE_METHOD_AUTO;
+	}
+
+	if (FIELD_GET(CFIR_DMA_HDR_INFO2_MURX_DATA_INC, dma_hdr.info2)) {
+		if (freeze_tlv_ver == MACRX_FREEZE_TLV_VERSION_3)
+			freeze_tlv_len = sizeof(struct macrx_freeze_capture_channel_v3);
+		else
+			freeze_tlv_len = sizeof(struct macrx_freeze_capture_channel);
+
+		mu_rx_user_info = data + sizeof(struct ath12k_cfir_enh_dma_hdr) +
+				  freeze_tlv_len;
+	}
+
+	length = FIELD_GET(CFIR_DMA_HDR_INFO0_LEN, dma_hdr.hdr.info0) * 4;
+	length += dma_hdr.total_bytes;
+
+	spin_lock_bh(&cfr->lut_lock);
+
+	if (!cfr->lut) {
+		spin_unlock_bh(&cfr->lut_lock);
+		return -EINVAL;
+	}
+
+	lut = &cfr->lut[buf_id];
+	if (!lut) {
+		ath12k_dbg(ab, ATH12K_DBG_CFR,
+			   "lut failure to process cfr data id:%d\n", buf_id);
+		spin_unlock_bh(&cfr->lut_lock);
+		return -EINVAL;
+	}
+
+
+	ath12k_dbg_dump(ab, ATH12K_DBG_CFR_DUMP,"data_from_buf_rel:", "",
+			data, length);
+
+	lut->buff = param->buff;
+	lut->data = data;
+	lut->data_len = length;
+	lut->dbr_ppdu_id = dma_hdr.hdr.phy_ppdu_id;
+	lut->dbr_tstamp = jiffies;
+	lut->header_length = FIELD_GET(CFIR_DMA_HDR_INFO0_LEN, dma_hdr.hdr.info0);
+	lut->payload_length = dma_hdr.total_bytes;
+	memcpy(&lut->dma_hdr.enh_hdr, &dma_hdr, sizeof(struct ath12k_cfir_enh_dma_hdr));
+
+	header = &lut->header;
+	meta = &header->u.meta_enh;
+	meta->channel_bw = FIELD_GET(CFIR_DMA_HDR_INFO1_UPLOAD_PKT_BW,
+				     dma_hdr.hdr.info1);
+	meta->num_rx_chain =
+		NUM_CHAINS_FW_TO_HOST(FIELD_GET(CFIR_DMA_HDR_INFO1_NUM_CHAINS,
+						dma_hdr.hdr.info1));
+	meta->length = length;
+
+	if (capture_type != CFR_CAPTURE_METHOD_ACK_RESP_TO_TM_FTM) {
+		meta->capture_type = capture_type;
+		meta->sts_count = FIELD_GET(CFIR_DMA_HDR_INFO1_NSS, dma_hdr.hdr.info1) + 1;
+		if (FIELD_GET(CFIR_DMA_HDR_INFO2_MURX_DATA_INC, dma_hdr.info2)) {
+			peer_macaddr = meta->peer_addr.su_peer_addr;
+			if (freeze_tlv)
+				extract_peer_mac_from_freeze_tlv(freeze_tlv, peer_macaddr);
+		}
+	}
+
+	status = ath12k_cfr_correlate_and_relay(ar, lut,
+						ATH12K_CORRELATE_DBR_EVENT);
+
+	if (status == ATH12K_CORRELATE_STATUS_RELEASE) {
+		ath12k_dbg(ab, ATH12K_DBG_CFR,
+			   "releasing CFR data to user space");
+		ath12k_cfr_rfs_write(ar, &lut->header,
+				sizeof(struct ath12k_csi_cfr_header),
+				lut->data, lut->data_len,
+				&end_magic, sizeof(u32));
+		ath12k_cfr_release_lut_entry(lut);
+		ret = ATH12K_CORRELATE_STATUS_RELEASE;
+	} else if (status == ATH12K_CORRELATE_STATUS_HOLD) {
+		ret = ATH12K_CORRELATE_STATUS_HOLD;
+		ath12k_dbg(ab, ATH12K_DBG_CFR,
+			   "tx event is not yet received holding the buf");
+	} else {
+		ath12k_cfr_release_lut_entry(lut);
+		ret = ATH12K_CORRELATE_STATUS_ERR;
+		ath12k_err(ab, "error in processing buf rel event");
+	}
+
+	spin_unlock_bh(&cfr->lut_lock);
+
+	return ret;
+}
+
+int ath12k_process_cfr_capture_event(struct ath12k_base *ab,
+				     struct ath12k_cfr_peer_tx_param *params)
+{
+	struct ath12k *ar;
+	struct ath12k_cfr *cfr;
+	struct ath12k_link_vif *arvif;
+	struct ath12k_cfr_look_up_table *lut = NULL, *temp = NULL;
+	struct ath12k_dbring_element *buff;
+	struct ath12k_csi_cfr_header *header;
+	dma_addr_t buf_addr;
+	u32 end_magic = ATH12K_CFR_END_MAGIC;
+	u8 tx_status;
+	int ret = 0;
+	int status;
+	int i;
+
+	rcu_read_lock();
+	arvif = ath12k_mac_get_arvif_by_vdev_id(ab, params->vdev_id);
+	if (!arvif) {
+		ath12k_warn(ab, "Failed to get arvif for vdev id %d\n",
+			    params->vdev_id);
+		rcu_read_unlock();
+		return -ENOENT;
+	}
+
+	ar = arvif->ar;
+	cfr = &ar->cfr;
+	rcu_read_unlock();
+
+	if (WMI_CFR_CAPTURE_STATUS_PEER_PS & params->status) {
+		ath12k_dbg(ab, ATH12K_DBG_CFR,
+			   "CFR capture failed as peer %pM is in powersave",
+			   params->peer_mac_addr);
+		return -EINVAL;
+	}
+
+	if (!(WMI_CFR_PEER_CAPTURE_STATUS & params->status)) {
+		ath12k_dbg(ab, ATH12K_DBG_CFR,
+			   "CFR capture failed for the peer : %pM",
+			   params->peer_mac_addr);
+		cfr->tx_peer_status_cfr_fail++;
+		return -EINVAL;
+	}
+
+	tx_status = FIELD_GET(WMI_CFR_FRAME_TX_STATUS, params->status);
+
+	if (tx_status != WMI_FRAME_TX_STATUS_OK) {
+		ath12k_dbg(ab, ATH12K_DBG_CFR,
+			   "WMI tx status %d for the peer %pM",
+			   tx_status, params->peer_mac_addr);
+		cfr->tx_evt_status_cfr_fail++;
+		return -EINVAL;
+	}
+
+	buf_addr = (((u64)FIELD_GET(WMI_CFR_CORRELATION_INFO2_BUF_ADDR_HIGH,
+				    params->correlation_info_2)) << 32) |
+		   params->correlation_info_1;
+
+	spin_lock_bh(&cfr->lut_lock);
+
+	if (!cfr->lut) {
+		spin_unlock_bh(&cfr->lut_lock);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < cfr->lut_num; i++) {
+		temp = &cfr->lut[i];
+		if (temp->dbr_address == buf_addr) {
+			lut = &cfr->lut[i];
+			break;
+		}
+	}
+
+	if (!lut) {
+		ath12k_dbg(ab, ATH12K_DBG_CFR,
+			   "lut failure to process tx event\n");
+		cfr->tx_dbr_lookup_fail++;
+		spin_unlock_bh(&cfr->lut_lock);
+		return -EINVAL;
+	}
+
+	lut->tx_ppdu_id = FIELD_GET(WMI_CFR_CORRELATION_INFO2_PPDU_ID,
+				    params->correlation_info_2);
+	lut->tx_address1 = params->correlation_info_1;
+	lut->tx_address2 = params->correlation_info_2;
+	lut->txrx_tstamp = jiffies;
+
+	header = &lut->header;
+	header->start_magic_num = ATH12K_CFR_START_MAGIC;
+	header->vendorid = VENDOR_QCA;
+	header->pltform_type = PLATFORM_TYPE_ARM;
+
+	ab->hw_params->hw_ops->fill_cfr_hdr_info(ar, header, params);
+
+	status = ath12k_cfr_correlate_and_relay(ar, lut,
+						ATH12K_CORRELATE_TX_EVENT);
+	if (status == ATH12K_CORRELATE_STATUS_RELEASE) {
+		ath12k_dbg(ab, ATH12K_DBG_CFR,
+			   "Releasing CFR data to user space");
+		ath12k_cfr_rfs_write(ar, &lut->header,
+				     sizeof(struct ath12k_csi_cfr_header),
+				     lut->data, lut->data_len,
+				     &end_magic, sizeof(u32));
+		buff = lut->buff;
+		ath12k_cfr_release_lut_entry(lut);
+
+		ath12k_dbring_bufs_replenish(ar, &cfr->rx_ring, buff,
+					     WMI_DIRECT_BUF_CFR, GFP_ATOMIC);
+	} else if (status == ATH12K_CORRELATE_STATUS_HOLD) {
+		ath12k_dbg(ab, ATH12K_DBG_CFR,
+			   "dbr event is not yet received holding buf\n");
+	} else {
+		buff = lut->buff;
+		ath12k_cfr_release_lut_entry(lut);
+		ath12k_dbring_bufs_replenish(ar, &cfr->rx_ring, buff,
+					     WMI_DIRECT_BUF_CFR, GFP_ATOMIC);
+		ret = -EINVAL;
+	}
+
+	spin_unlock_bh(&cfr->lut_lock);
+	return ret;
+}
+
+static struct dentry *create_buf_file_handler(const char *filename,
+					      struct dentry *parent,
+					      umode_t mode,
+					      struct rchan_buf *buf,
+					      int *is_global)
+{
+	struct dentry *buf_file;
+
+	buf_file = debugfs_create_file(filename, mode, parent, buf,
+				       &relay_file_operations);
+	*is_global = 1;
+	return buf_file;
+}
+
+static int remove_buf_file_handler(struct dentry *dentry)
+{
+	debugfs_remove(dentry);
+
+	return 0;
+}
+
+static struct rchan_callbacks rfs_cfr_capture_cb = {
+	.create_buf_file = create_buf_file_handler,
+	.remove_buf_file = remove_buf_file_handler,
+};
+
+static ssize_t ath12k_read_file_enable_cfr(struct file *file,
+					   char __user *user_buf,
+					   size_t count, loff_t *ppos)
+{
+	struct ath12k *ar = file->private_data;
+	char buf[32] = {0};
+	size_t len;
+
+	mutex_lock(&ar->conf_mutex);
+	len = scnprintf(buf, sizeof(buf), "%d\n", ar->cfr.cfr_enabled);
+	mutex_unlock(&ar->conf_mutex);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t ath12k_write_file_enable_cfr(struct file *file,
+					    const char __user *ubuf,
+					    size_t count, loff_t *ppos)
+{
+	struct ath12k *ar = file->private_data;
+	bool enable_cfr = false;
+	int ret;
+
+	if (kstrtobool_from_user(ubuf, count, &enable_cfr))
+		return -EINVAL;
+
+	mutex_lock(&ar->conf_mutex);
+
+	if (ar->state != ATH12K_STATE_ON) {
+		ret = -ENETDOWN;
+		goto out;
+	}
+
+	if (!enable_cfr) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (ar->cfr.cfr_enabled == enable_cfr) {
+		ret = count;
+		goto out;
+	}
+
+	ret = ath12k_wmi_pdev_set_param(ar, WMI_PDEV_PARAM_PER_PEER_CFR_ENABLE,
+					enable_cfr, ar->pdev->pdev_id);
+	if (ret) {
+		ath12k_warn(ar->ab,
+			    "Failed to enable/disable per peer cfr (%d)\n",
+			    ret);
+		goto out;
+	}
+
+	ar->cfr.cfr_enabled = enable_cfr;
+	ret = count;
+out:
+	mutex_unlock(&ar->conf_mutex);
+	return ret;
+}
+
+static const struct file_operations fops_enable_cfr = {
+	.read = ath12k_read_file_enable_cfr,
+	.write = ath12k_write_file_enable_cfr,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t ath12k_write_file_cfr_unassoc(struct file *file,
+					     const char __user *ubuf,
+					     size_t count, loff_t *ppos)
+{
+	struct ath12k *ar = file->private_data;
+	struct ath12k_cfr *cfr = &ar->cfr;
+	struct cfr_unassoc_pool_entry *entry;
+	char buf[64] = {0};
+	u8 peer_mac[6];
+	u32 cfr_capture_enable;
+	u32 cfr_capture_period;
+	int available_idx = -1;
+	int ret, i;
+
+	simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, ubuf, count);
+
+	mutex_lock(&ar->conf_mutex);
+	spin_lock_bh(&cfr->lock);
+
+	if (ar->state != ATH12K_STATE_ON) {
+		ret = -ENETDOWN;
+		goto out;
+	}
+
+	if (!ar->cfr.cfr_enabled) {
+		ret = -EINVAL;
+		ath12k_err(ar->ab, "CFR is not enabled on this pdev %d\n",
+			   ar->pdev_idx);
+		goto out;
+	}
+
+	ret = sscanf(buf, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx %u %u",
+		     &peer_mac[0], &peer_mac[1], &peer_mac[2], &peer_mac[3],
+		     &peer_mac[4], &peer_mac[5], &cfr_capture_enable,
+		     &cfr_capture_period);
+
+	if (ret < 1) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (cfr_capture_enable && ret != 8) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (!cfr_capture_enable) {
+		for (i = 0; i < ATH12K_MAX_CFR_ENABLED_CLIENTS; i++) {
+			entry = &cfr->unassoc_pool[i];
+			if (ether_addr_equal(peer_mac, entry->peer_mac)) {
+				memset(entry->peer_mac, 0, ETH_ALEN);
+				entry->is_valid = false;
+				cfr->cfr_enabled_peer_cnt--;
+			}
+		}
+
+		ret = count;
+		goto out;
+	}
+
+
+	if (cfr->cfr_enabled_peer_cnt >= ATH12K_MAX_CFR_ENABLED_CLIENTS) {
+		ath12k_info(ar->ab, "Max cfr peer threshold reached\n");
+		ret = count;
+		goto out;
+	}
+
+	for (i = 0; i < ATH12K_MAX_CFR_ENABLED_CLIENTS; i++) {
+		entry = &cfr->unassoc_pool[i];
+
+		if ((available_idx < 0) && !entry->is_valid)
+			available_idx = i;
+
+		if (ether_addr_equal(peer_mac, entry->peer_mac)) {
+			ath12k_info(ar->ab,
+				    "peer entry already present updating params\n");
+			entry->period = cfr_capture_period;
+			ret = count;
+			goto out;
+		}
+	}
+
+	if (available_idx >= 0) {
+		entry = &cfr->unassoc_pool[available_idx];
+		ether_addr_copy(entry->peer_mac, peer_mac);
+		entry->period = cfr_capture_period;
+		entry->is_valid = true;
+		cfr->cfr_enabled_peer_cnt++;
+	}
+
+	ret = count;
+out:
+	spin_unlock_bh(&cfr->lock);
+	mutex_unlock(&ar->conf_mutex);
+	return ret;
+}
+
+static ssize_t ath12k_read_file_cfr_unassoc(struct file *file,
+					    char __user *ubuf,
+					    size_t count, loff_t *ppos)
+{
+	char buf[512] = {0};
+	struct ath12k *ar = file->private_data;
+	struct ath12k_cfr *cfr = &ar->cfr;
+	struct cfr_unassoc_pool_entry *entry;
+	int len = 0, i;
+
+	mutex_lock(&ar->conf_mutex);
+	spin_lock_bh(&cfr->lock);
+
+	for (i = 0; i < ATH12K_MAX_CFR_ENABLED_CLIENTS; i++) {
+		entry = &cfr->unassoc_pool[i];
+		if (entry->is_valid)
+			len += scnprintf(buf + len, sizeof(buf) - len,
+					 "peer: %pM period: %u\n",
+					 entry->peer_mac, entry->period);
+	}
+
+	spin_unlock_bh(&cfr->lock);
+	mutex_unlock(&ar->conf_mutex);
+
+	return simple_read_from_buffer(ubuf, count, ppos, buf, len);
+}
+
+static const struct file_operations fops_configure_cfr_unassoc = {
+	.write = ath12k_write_file_cfr_unassoc,
+	.read = ath12k_read_file_cfr_unassoc,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static inline void ath12k_cfr_debug_unregister(struct ath12k *ar)
+{
+	debugfs_remove(ar->cfr.enable_cfr);
+	ar->cfr.enable_cfr = NULL;
+	debugfs_remove(ar->cfr.cfr_unassoc);
+	ar->cfr.cfr_unassoc = NULL;
+
+	if (ar->cfr.rfs_cfr_capture) {
+		relay_close(ar->cfr.rfs_cfr_capture);
+		ar->cfr.rfs_cfr_capture = NULL;
+	}
+}
+
+static inline int ath12k_cfr_debug_register(struct ath12k *ar)
+{
+	int ret;
+
+	ar->cfr.rfs_cfr_capture = relay_open("cfr_capture",
+					     ar->debug.debugfs_pdev,
+					     ar->ab->hw_params->cfr_stream_buf_size,
+					     ar->ab->hw_params->cfr_num_stream_bufs,
+					     &rfs_cfr_capture_cb, NULL);
+	if (!ar->cfr.rfs_cfr_capture) {
+		ath12k_warn(ar->ab, "failed to open relay for cfr in pdev %d\n",
+			    ar->pdev_idx);
+		return -EINVAL;
+	}
+
+	ar->cfr.enable_cfr = debugfs_create_file("enable_cfr", 0600,
+						 ar->debug.debugfs_pdev, ar,
+						 &fops_enable_cfr);
+	if (!ar->cfr.enable_cfr) {
+		ath12k_warn(ar->ab, "failed to open debugfs in pdev %d\n",
+			    ar->pdev_idx);
+		ret = -EINVAL;
+		goto debug_unregister;
+	}
+
+	ar->cfr.cfr_unassoc = debugfs_create_file("cfr_unassoc", 0600,
+						  ar->debug.debugfs_pdev, ar,
+						  &fops_configure_cfr_unassoc);
+
+	if (!ar->cfr.cfr_unassoc) {
+		ath12k_warn(ar->ab,
+			    "failed to open debugfs for unassoc pool in pdev %d\n",
+			    ar->pdev_idx);
+		ret = -EINVAL;
+		goto debug_unregister;
+	}
+
+	return 0;
+
+debug_unregister :
+	ath12k_cfr_debug_unregister(ar);
+	return ret;
+}
+
+static int ath12k_cfr_ring_alloc(struct ath12k *ar,
+				 struct ath12k_dbring_cap *db_cap)
+{
+	struct ath12k_cfr *cfr = &ar->cfr;
+	int ret;
+
+	ret = ath12k_dbring_srng_setup(ar, &cfr->rx_ring,
+				       1, db_cap->min_elem);
+	if (ret) {
+		ath12k_warn(ar->ab, "failed to setup db ring\n");
+		return ret;
+	}
+
+	ath12k_dbring_set_cfg(ar, &cfr->rx_ring,
+			      ATH12K_CFR_NUM_RESP_PER_EVENT,
+			      ATH12K_CFR_EVENT_TIMEOUT_MS,
+			      ath12k_cfr_enh_process_data);
+
+	ret = ath12k_dbring_buf_setup(ar, &cfr->rx_ring, db_cap);
+	if (ret) {
+		ath12k_warn(ar->ab, "failed to setup db ring buffer\n");
+		goto srng_cleanup;
+	}
+
+	ret = ath12k_dbring_wmi_cfg_setup(ar, &cfr->rx_ring, WMI_DIRECT_BUF_CFR);
+	if (ret) {
+		ath12k_warn(ar->ab, "failed to setup db ring cfg\n");
+		goto buffer_cleanup;
+	}
+
+	return 0;
+
+buffer_cleanup:
+	ath12k_dbring_buf_cleanup(ar, &cfr->rx_ring);
+srng_cleanup:
+	ath12k_dbring_srng_cleanup(ar, &cfr->rx_ring);
+	return ret;
+}
+
+void ath12k_cfr_ring_free(struct ath12k *ar)
+{
+	struct ath12k_cfr *cfr = &ar->cfr;
+
+	ath12k_dbring_srng_cleanup(ar, &cfr->rx_ring);
+	ath12k_dbring_buf_cleanup(ar, &cfr->rx_ring);
+}
+
+void ath12k_cfr_deinit(struct ath12k_base *ab)
+{
+	struct ath12k *ar;
+	struct ath12k_cfr *cfr;
+	int i;
+
+	if (!test_bit(WMI_TLV_SERVICE_CFR_CAPTURE_SUPPORT, ab->wmi_ab.svc_map) ||
+	    !ab->hw_params->cfr_support)
+		return;
+
+	for (i = 0; i <  ab->num_radios; i++) {
+		ar = ab->pdevs[i].ar;
+		cfr = &ar->cfr;
+
+		spin_lock_bh(&cfr->lut_lock);
+		if (cfr->lut) {
+			kfree(cfr->lut);
+			cfr->lut = NULL;
+		}
+		spin_unlock_bh(&cfr->lut_lock);
+
+		ar->cfr.cfr_enabled = 0;
+		ath12k_cfr_debug_unregister(ar);
+		ath12k_cfr_ring_free(ar);
+	}
+}
+
+int ath12k_cfr_init(struct ath12k_base *ab)
+{
+	struct ath12k *ar;
+	struct ath12k_cfr *cfr;
+	struct ath12k_dbring_cap db_cap;
+	struct ath12k_cfr_look_up_table *lut;
+	u32 num_lut_entries;
+	int ret = 0;
+	int i;
+
+	if (!test_bit(WMI_TLV_SERVICE_CFR_CAPTURE_SUPPORT, ab->wmi_ab.svc_map) ||
+	    !ab->hw_params->cfr_support)
+		return ret;
+
+	for (i = 0; i < ab->num_radios; i++) {
+		ar = ab->pdevs[i].ar;
+		cfr = &ar->cfr;
+
+		ret = ath12k_dbring_get_cap(ar->ab, ar->pdev_idx,
+					    WMI_DIRECT_BUF_CFR, &db_cap);
+		if (ret)
+			continue;
+
+		idr_init(&cfr->rx_ring.bufs_idr);
+		spin_lock_init(&cfr->rx_ring.idr_lock);
+		spin_lock_init(&cfr->lock);
+		spin_lock_init(&cfr->lut_lock);
+
+		num_lut_entries = min((u32)CFR_MAX_LUT_ENTRIES, db_cap.min_elem);
+
+		cfr->lut = kzalloc(num_lut_entries * sizeof(*lut), GFP_KERNEL);
+		if (!cfr->lut) {
+			ath12k_warn(ab, "failed to allocate lut for pdev %d\n", i);
+			return -ENOMEM;
+		}
+
+		ret = ath12k_cfr_ring_alloc(ar, &db_cap);
+		if (ret) {
+			ath12k_warn(ab, "failed to init cfr ring for pdev %d\n", i);
+			goto deinit;
+		}
+
+		spin_lock_bh(&cfr->lock);
+		cfr->lut_num = num_lut_entries;
+		spin_unlock_bh(&cfr->lock);
+
+		ret = ath12k_cfr_debug_register(ar);
+		if (ret) {
+			ath12k_warn(ab, "failed to register cfr for pdev %d\n", i);
+			goto deinit;
+		}
+	}
+	return 0;
+
+deinit:
+	ath12k_cfr_deinit(ab);
+	return ret;
+}
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/cfr.h
@@ -0,0 +1,445 @@
+/* SPDX-License-Identifier: BSD-3-Clause-Clear */
+/*
+ * Copyright (c) 2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef ATH12K_CFR_H
+#define ATH12K_CFR_H
+
+#include "dbring.h"
+#include "wmi.h"
+
+#define ATH12K_CFR_NUM_RESP_PER_EVENT   1
+#define ATH12K_CFR_EVENT_TIMEOUT_MS     1
+
+#define ATH12K_CORRELATE_TX_EVENT 1
+#define ATH12K_CORRELATE_DBR_EVENT 0
+
+#define ATH12K_MAX_CFR_ENABLED_CLIENTS 10
+
+#define ATH12K_CFR_START_MAGIC 0xDEADBEAF
+#define ATH12K_CFR_END_MAGIC 0xBEAFDEAD
+
+#define ATH12K_CFR_RADIO_QCN9274 32
+#define ATH12K_CFR_RADIO_WCN7850 33
+#define ATH12K_CFR_RADIO_IPQ5332 35
+#define ATH12K_CFR_RADIO_QCN6432 38
+
+#define CFR_HDR_MAX_LEN_WORDS_QCN9274 88
+#define CFR_DATA_MAX_LEN_QCN9274 64512
+
+#define CFR_HDR_MAX_LEN_WORDS_WCN7850 16
+#define CFR_DATA_MAX_LEN_WCN7850 16064
+
+#define CFR_HDR_MAX_LEN_WORDS_IPQ5332 22
+#define CFR_DATA_MAX_LEN_IPQ5332 8192
+
+#define CFR_HDR_MAX_LEN_WORDS_QCN6432 30
+#define CFR_DATA_MAX_LEN_QCN6432 32152
+
+#define VENDOR_QCA 0x8cfdf0
+#define PLATFORM_TYPE_ARM 2
+#define NUM_CHAINS_FW_TO_HOST(n) ((1 << ((n) + 1)) - 1)
+
+enum ath12k_cfr_meta_version {
+	ATH12K_CFR_META_VERSION_NONE,
+	ATH12K_CFR_META_VERSION_1,
+	ATH12K_CFR_META_VERSION_2,
+	ATH12K_CFR_META_VERSION_3,
+	ATH12K_CFR_META_VERSION_4,
+	ATH12K_CFR_META_VERSION_5,
+	ATH12K_CFR_META_VERSION_6,
+	ATH12K_CFR_META_VERSION_7,
+	ATH12K_CFR_META_VERSION_8,
+	ATH12K_CFR_META_VERSION_9,
+	ATH12K_CFR_META_VERSION_MAX = 0xFF,
+};
+
+enum ath12k_cfr_data_version {
+	ATH12K_CFR_DATA_VERSION_NONE,
+	ATH12K_CFR_DATA_VERSION_1,
+	ATH12K_CFR_DATA_VERSION_MAX = 0xFF,
+};
+
+enum ath12k_cfr_capture_ack_mode {
+	ATH12K_CFR_CAPTURE_LEGACY_ACK,
+	ATH12K_CFR_CAPTURE_DUP_LEGACY_ACK,
+	ATH12K_CFR_CAPTURE_HT_ACK,
+	ATH12K_CFR_CPATURE_VHT_ACK,
+
+	/*Always keep this at last*/
+	ATH12K_CFR_CPATURE_INVALID_ACK
+};
+
+enum ath12k_cfr_correlate_status {
+	ATH12K_CORRELATE_STATUS_RELEASE,
+	ATH12K_CORRELATE_STATUS_HOLD,
+	ATH12K_CORRELATE_STATUS_ERR,
+};
+
+struct ath12k_cfr_peer_tx_param {
+	u32 capture_method;
+	u32 vdev_id;
+	u8 peer_mac_addr[ETH_ALEN];
+	u32 primary_20mhz_chan;
+	u32 bandwidth;
+	u32 phy_mode;
+	u32 band_center_freq1;
+	u32 band_center_freq2;
+	u32 spatial_streams;
+	u32 correlation_info_1;
+	u32 correlation_info_2;
+	u32 status;
+	u32 timestamp_us;
+	u32 counter;
+	u32 chain_rssi[WMI_MAX_CHAINS];
+	u16 chain_phase[WMI_MAX_CHAINS];
+	u32 cfo_measurement;
+	u8 agc_gain[WMI_MAX_CHAINS];
+	u32 rx_start_ts;
+	u32 rx_ts_reset;
+	uint32_t mcs_rate;
+	uint32_t gi_type;
+	uint8_t agc_gain_tbl_index[WMI_MAX_CHAINS];
+};
+
+#define HOST_MAX_CHAINS 8
+#define MAX_CFR_MU_USERS 4
+
+struct cfr_dbr_metadata {
+	u8 peer_addr[ETH_ALEN];
+	u8 status;
+	u8 capture_bw;
+	u8 channel_bw;
+	u8 phy_mode;
+	u16 prim20_chan;
+	u16 center_freq1;
+	u16 center_freq2;
+	u8 capture_mode;
+	u8 capture_type;
+	u8 sts_count;
+	u8 num_rx_chain;
+	u32 timestamp;
+	u32 length;
+	u32 chain_rssi[HOST_MAX_CHAINS];
+	u16 chain_phase[HOST_MAX_CHAINS];
+	u32 rtt_cfo_measurement;
+	u8 agc_gain[HOST_MAX_CHAINS];
+	u32 rx_start_ts;
+	u16 mcs_rate;
+	u16 gi_type;
+	u8 agc_gain_tbl_index[HOST_MAX_CHAINS];
+} __packed;
+
+struct cfr_su_sig_info {
+	u8 coding;
+	u8 stbc;
+	u8 beamformed;
+	u8 dcm;
+	u8 ltf_size;
+	u8 sgi;
+	u16 reserved;
+} __packed;
+
+struct cfr_enh_metadata {
+	u8 status;
+	u8 capture_bw;
+	u8 channel_bw;
+	u8 phy_mode;
+	u16 prim20_chan;
+	u16 center_freq1;
+	u16 center_freq2;
+	u8 capture_mode;
+	u8 capture_type;
+	u8 sts_count;
+	u8 num_rx_chain;
+	u64 timestamp;
+	u32 length;
+	u8 is_mu_ppdu;
+	u8 num_mu_users;
+	union {
+		u8 su_peer_addr[ETH_ALEN];
+		u8 mu_peer_addr[MAX_CFR_MU_USERS][ETH_ALEN];
+	} peer_addr;
+	u32 chain_rssi[HOST_MAX_CHAINS];
+	u16 chain_phase[HOST_MAX_CHAINS];
+	u32 cfo_measurement;
+	u8 agc_gain[HOST_MAX_CHAINS];
+	u32 rx_start_ts;
+	u16 mcs_rate;
+	u16 gi_type;
+	struct cfr_su_sig_info sig_info;
+	u8 agc_gain_tbl_index[HOST_MAX_CHAINS];
+} __packed;
+
+struct ath12k_csi_cfr_header {
+	u32 start_magic_num;
+	u32 vendorid;
+	u8 cfr_metadata_version;
+	u8 cfr_data_version;
+	u8 chip_type;
+	u8 pltform_type;
+	u32 cfr_metadata_len;
+	u64 host_real_ts;
+	union {
+		struct cfr_dbr_metadata meta_dbr;
+		struct cfr_enh_metadata meta_enh;
+	} u;
+} __packed;
+
+enum ath12k_cfr_preamble_type {
+	ATH12K_CFR_PREAMBLE_TYPE_LEGACY,
+	ATH12K_CFR_PREAMBLE_TYPE_HT,
+	ATH12K_CFR_PREAMBLE_TYPE_VHT,
+};
+
+#define TONES_IN_20MHZ  256
+#define TONES_IN_40MHZ  512
+#define TONES_IN_80MHZ  1024
+#define TONES_IN_160MHZ 2048 /* 160 MHz isn't supported yet */
+#define TONES_INVALID   0
+
+#define CFIR_DMA_HDR_INFO0_TAG GENMASK(7, 0)
+#define CFIR_DMA_HDR_INFO0_LEN GENMASK(13, 8)
+
+#define CFIR_DMA_HDR_INFO1_UPLOAD_DONE	GENMASK(0, 0)
+#define CFIR_DMA_HDR_INFO1_CAPTURE_TYPE	GENMASK(3, 1)
+#define CFIR_DMA_HDR_INFO1_PREABLE_TYPE	GENMASK(5, 4)
+#define CFIR_DMA_HDR_INFO1_NSS		GENMASK(8, 6)
+#define CFIR_DMA_HDR_INFO1_NUM_CHAINS	GENMASK(11, 9)
+#define CFIR_DMA_HDR_INFO1_UPLOAD_PKT_BW GENMASK(14, 12)
+#define CFIR_DMA_HDR_INFO1_SW_PEER_ID_VALID GENMASK(15, 15)
+
+struct ath12k_cfir_dma_hdr {
+	u16 info0;
+	u16 info1;
+	u16 sw_peer_id;
+	u16 phy_ppdu_id;
+};
+
+#define CFIR_DMA_HDR_INFO2_HDR_VER GENMASK(3, 0)
+#define CFIR_DMA_HDR_INFO2_TARGET_ID GENMASK(7, 4)
+#define CFIR_DMA_HDR_INFO2_CFR_FMT BIT(8)
+#define CFIR_DMA_HDR_INFO2_RSVD BIT(9)
+#define CFIR_DMA_HDR_INFO2_MURX_DATA_INC BIT(10)
+#define CFIR_DMA_HDR_INFO2_FREEZ_DATA_INC BIT(11)
+#define CFIR_DMA_HDR_INFO2_FREEZ_TLV_VER GENMASK(15, 12)
+
+#define CFIR_DMA_HDR_INFO3_MU_RX_NUM_USERS GENMASK(7, 0)
+#define CFIR_DMA_HDR_INFO3_DECIMATION_FACT GENMASK(11, 8)
+#define CFIR_DMA_HDR_INFO3_RSVD GENMASK(15, 12)
+
+struct ath12k_cfir_enh_dma_hdr {
+	struct ath12k_cfir_dma_hdr hdr;
+	u16 total_bytes;
+	u16 info2;
+	u16 info3;
+	u16 rsvd;
+};
+
+#define CFR_MAX_LUT_ENTRIES 136
+
+struct ath12k_cfr_look_up_table {
+	bool dbr_recv;
+	bool tx_recv;
+	u8 *data;
+	u32 data_len;
+	u16 dbr_ppdu_id;
+	u16 tx_ppdu_id;
+	dma_addr_t dbr_address;
+	u32 tx_address1;
+	u32 tx_address2;
+	struct ath12k_csi_cfr_header header;
+	union {
+		struct ath12k_cfir_dma_hdr hdr;
+		struct ath12k_cfir_enh_dma_hdr enh_hdr;
+	} dma_hdr;
+	u64 txrx_tstamp;
+	u64 dbr_tstamp;
+	u32 header_length;
+	u32 payload_length;
+	struct ath12k_dbring_element *buff;
+};
+
+enum cfr_capture_type {
+	CFR_CAPTURE_METHOD_NULL_FRAME = 0,
+	CFR_CAPURE_METHOD_NULL_FRAME_WITH_PHASE = 1,
+	CFR_CAPTURE_METHOD_PROBE_RESP = 2,
+	CFR_CAPTURE_METHOD_TM = 3,
+	CFR_CAPTURE_METHOD_FTM = 4,
+	CFR_CAPTURE_METHOD_ACK_RESP_TO_TM_FTM = 5,
+	CFR_CAPTURE_METHOD_TA_RA_TYPE_FILTER = 6,
+	CFR_CAPTURE_METHOD_NDPA_NDP = 7,
+	CFR_CAPTURE_METHOD_ALL_PACKET = 8,
+	/* Add new capture methods before this line */
+	CFR_CAPTURE_METHOD_LAST_VALID,
+	CFR_CAPTURE_METHOD_AUTO = 0xff,
+	CFR_CAPTURE_METHOD_MAX,
+};
+
+/* enum macrx_freeze_tlv_version: Reported by uCode in enh_dma_header
+ * MACRX_FREEZE_TLV_VERSION_1: Single MU UL user info reported by MAC
+ * MACRX_FREEZE_TLV_VERSION_2: Upto 4 MU UL user info reported by MAC
+ * MACRX_FREEZE_TLV_VERSION_3: Upto 37 MU UL user info reported by MAC
+ */
+enum macrx_freeze_tlv_version {
+	MACRX_FREEZE_TLV_VERSION_1 = 1,
+	MACRX_FREEZE_TLV_VERSION_2 = 2,
+	MACRX_FREEZE_TLV_VERSION_3 = 3,
+	MACRX_FREEZE_TLV_VERSION_MAX
+};
+
+enum mac_freeze_capture_reason {
+	FREEZE_REASON_TM = 0,
+	FREEZE_REASON_FTM,
+	FREEZE_REASON_ACK_RESP_TO_TM_FTM,
+	FREEZE_REASON_TA_RA_TYPE_FILTER,
+	FREEZE_REASON_NDPA_NDP,
+	FREEZE_REASON_ALL_PACKET,
+	FREEZE_REASON_MAX,
+};
+
+#define MACRX_FREEZE_CC_INFO0_FREEZE GENMASK(0, 0)
+#define MACRX_FREEZE_CC_INFO0_CAPTURE_REASON GENMASK(3, 1)
+#define MACRX_FREEZE_CC_INFO0_PKT_TYPE GENMASK(5, 4)
+#define MACRX_FREEZE_CC_INFO0_PKT_SUB_TYPE GENMASK(9, 6)
+#define MACRX_FREEZE_CC_INFO0_RSVD GENMASK(14, 10)
+#define MACRX_FREEZE_CC_INFO0_SW_PEER_ID_VALID GENMASK(15, 15)
+
+#define MACRX_FREEZE_CC_INFO1_USER_MASK GENMASK(5, 0)
+#define MACRX_FREEZE_CC_INFO1_DIRECTED GENMASK(6, 6)
+#define MACRX_FREEZE_CC_INFO1_RSVD GENMASK(15, 7)
+
+struct macrx_freeze_capture_channel {
+	u16 info0;
+	u16 sw_peer_id;
+	u16 phy_ppdu_id;
+	u16 packet_ta_lower_16;
+	u16 packet_ta_mid_16;
+	u16 packet_ta_upper_16;
+	u16 packet_ra_lower_16;
+	u16 packet_ra_mid_16;
+	u16 packet_ra_upper_16;
+	u16 tsf_timestamp_15_0;
+	u16 tsf_timestamp_31_16;
+	u16 tsf_timestamp_47_32;
+	u16 tsf_timestamp_63_48;
+	u16 info1;
+};
+
+#define MACRX_FREEZE_CC_V3_INFO0_FREEZE GENMASK(0, 0)
+#define MACRX_FREEZE_CC_V3_INFO0_CAPTURE_REASON GENMASK(3, 1)
+#define MACRX_FREEZE_CC_V3_INFO0_PKT_TYPE GENMASK(5, 4)
+#define MACRX_FREEZE_CC_V3_INFO0_PKT_SUB_TYPE GENMASK(9, 6)
+#define MACRX_FREEZE_CC_V3_INFO0_DIRECTED GENMASK(10, 10)
+#define MACRX_FREEZE_CC_V3_INFO0_RSVD GENMASK(14, 11)
+#define MACRX_FREEZE_CC_V3_INFO0_SW_PEER_ID_VALID GENMASK(15, 15)
+
+/*
+ * freeze_tlv v3 used by qcn9074
+ */
+struct macrx_freeze_capture_channel_v3 {
+	u16 info0;
+	u16 sw_peer_id;
+	u16 phy_ppdu_id;
+	u16 packet_ta_lower_16;
+	u16 packet_ta_mid_16;
+	u16 packet_ta_upper_16;
+	u16 packet_ra_lower_16;
+	u16 packet_ra_mid_16;
+	u16 packet_ra_upper_16;
+	u16 tsf_timestamp_15_0;
+	u16 tsf_timestamp_31_16;
+	u16 tsf_timestamp_47_32;
+	u16 tsf_63_48_or_user_mask_36_32;
+	u16 user_index_or_user_mask_15_0;
+	u16 user_mask_31_16;
+};
+
+struct cfr_unassoc_pool_entry {
+	u8 peer_mac[ETH_ALEN];
+	u32 period;
+	bool is_valid;
+};
+
+struct ath12k_cfr {
+	struct ath12k_dbring rx_ring;
+	/* Protects enabled for ath12k_cfr */
+	spinlock_t lock;
+	struct rchan *rfs_cfr_capture;
+	struct dentry *enable_cfr;
+	struct dentry *cfr_unassoc;
+	u8 cfr_enabled_peer_cnt;
+	struct ath12k_cfr_look_up_table *lut;
+	u32 lut_num;
+	u32 dbr_buf_size;
+	u32 dbr_num_bufs;
+	u32 max_mu_users;
+	/* protect look up table data */
+	spinlock_t lut_lock;
+	u64 tx_evt_cnt;
+	u64 dbr_evt_cnt;
+	u64 total_tx_evt_cnt;
+	u64 release_cnt;
+	u64 tx_peer_status_cfr_fail;
+	u64 tx_evt_status_cfr_fail;
+	u64 tx_dbr_lookup_fail;
+	u64 last_success_tstamp;
+	u64 flush_dbr_cnt;
+	u64 invalid_dma_length_cnt;
+	u64 clear_txrx_event;
+	u64 cfr_dma_aborts;
+	u64 flush_timeout_dbr_cnt;
+	struct cfr_unassoc_pool_entry unassoc_pool[ATH12K_MAX_CFR_ENABLED_CLIENTS];
+	bool cfr_enabled;
+};
+
+#ifdef CPTCFG_ATH12K_CFR
+struct ath12k;
+struct ath12k_base;
+struct ath12k_sta;
+
+int ath12k_cfr_init(struct ath12k_base *ab);
+void ath12k_cfr_deinit(struct ath12k_base *ab);
+struct ath12k_dbring *ath12k_cfr_get_dbring(struct ath12k *ar);
+int ath12k_process_cfr_capture_event(struct ath12k_base *ab,
+				     struct ath12k_cfr_peer_tx_param *params);
+bool peer_is_in_cfr_unassoc_pool(struct ath12k *ar, u8 *peer_mac);
+void ath12k_cfr_lut_update_paddr(struct ath12k *ar, dma_addr_t paddr,
+				 u32 buf_id);
+void ath12k_cfr_decrement_peer_count(struct ath12k *ar, struct ath12k_link_sta *arsta);
+
+#else
+static inline int ath12k_cfr_init(struct ath12k_base *ab)
+{
+	return 0;
+}
+static inline void ath12k_cfr_deinit(struct ath12k_base *ab)
+{
+}
+static inline
+struct ath12k_dbring *ath12k_cfr_get_dbring(struct ath12k *ar)
+{
+	return NULL;
+}
+static inline bool peer_is_in_cfr_unassoc_pool(struct ath12k *ar, u8 *peer_mac)
+{
+	return false;
+}
+static inline
+int ath12k_process_cfr_capture_event(struct ath12k_base *ab,
+				     struct ath12k_cfr_peer_tx_param *params)
+{
+	return 0;
+}
+static inline void ath12k_cfr_lut_update_paddr(struct ath12k *ar,
+					       dma_addr_t paddr, u32 buf_id)
+{
+}
+static inline void ath12k_cfr_decrement_peer_count(struct ath12k *ar,
+						struct ath12k_link_sta *arsta)
+{
+}
+#endif /* CPTCFG_ATH12K_CFR */
+#endif /* ATH12K_CFR_H */
--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -1299,6 +1299,12 @@ static int ath12k_core_pdev_init(struct
 		goto err_spectral_deinit;
 	}
 
+	ret = ath12k_cfr_init(ab);
+	if (ret) {
+		ath12k_err(ab, "failed to init cfr %d\n", ret);
+		goto err_spectral_deinit;
+	}
+
 	ath12k_sawf_init(ab);
 	ath12k_telemetry_init(ab);
 	ath12k_fse_init(ab);
@@ -1328,6 +1334,7 @@ static void ath12k_core_pdev_deinit(stru
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 	ath12k_dp_ppeds_stop(ab);
 #endif
+	ath12k_cfr_deinit(ab);
 	ath12k_spectral_deinit(ab);
 	ath12k_thermal_unregister(ab);
 	ath12k_fse_deinit(ab);
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -30,6 +30,7 @@
 #include "sawf.h"
 #include "vendor.h"
 #include "telemetry_agent_if.h"
+#include "cfr.h"
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 #include <ppe_ds_wlan.h>
 #include <ppe_vp_public.h>
@@ -659,6 +660,13 @@ struct ath12k_htt_tx_stats {
 	u32 mu_group[MAX_MU_GROUP_ID];
 };
 
+struct ath12k_per_peer_cfr_capture {
+	u32 cfr_enable;
+	u32 cfr_period;
+	u32 cfr_bandwidth;
+	u32 cfr_method;
+};
+
 struct ath12k_per_ppdu_tx_stats {
 	u16 succ_pkts;
 	u16 failed_pkts;
@@ -725,6 +733,9 @@ struct ath12k_link_sta {
 	/* will be saved to use during recovery */
 	struct ieee80211_key_conf *keys[WMI_MAX_KEY_INDEX + 1];
 	enum ieee80211_sta_state state;
+#ifdef CPTCFG_ATH12K_CFR
+	struct ath12k_per_peer_cfr_capture cfr_capture;
+#endif
 	u32 rx_retries;
 };
 
@@ -1060,6 +1071,9 @@ struct ath12k {
 #ifdef CPTCFG_ATH12K_SPECTRAL
 	struct ath12k_spectral spectral;
 #endif
+#ifdef CPTCFG_ATH12K_CFR
+	struct ath12k_cfr cfr;
+#endif
 	bool dfs_block_radar_events;
 	struct ath12k_thermal thermal;
 	int monitor_vdev_id;
--- a/drivers/net/wireless/ath/ath12k/dbring.c
+++ b/drivers/net/wireless/ath/ath12k/dbring.c
@@ -35,9 +35,10 @@ static void ath12k_dbring_fill_magic_val
 	memset32(buffer, ATH12K_DB_MAGIC_VALUE, size);
 }
 
-static int ath12k_dbring_bufs_replenish(struct ath12k *ar,
+int ath12k_dbring_bufs_replenish(struct ath12k *ar,
 					struct ath12k_dbring *ring,
 					struct ath12k_dbring_element *buff,
+					enum wmi_direct_buffer_module id,
 					gfp_t gfp)
 {
 	struct ath12k_base *ab = ar->ab;
@@ -78,6 +79,9 @@ static int ath12k_dbring_bufs_replenish(
 		goto err_idr_remove;
 	}
 
+	if (id == WMI_DIRECT_BUF_CFR)
+		ath12k_cfr_lut_update_paddr(ar, paddr, buf_id);
+
 	buff->paddr = paddr;
 
 	dma_sync_single_for_device(ab->dev, paddr, ring->buf_sz, DMA_FROM_DEVICE);
@@ -104,6 +108,7 @@ err:
 
 static int ath12k_dbring_fill_bufs(struct ath12k *ar,
 				   struct ath12k_dbring *ring,
+				   enum wmi_direct_buffer_module id,
 				   gfp_t gfp)
 {
 	struct ath12k_dbring_element *buff;
@@ -128,7 +133,7 @@ static int ath12k_dbring_fill_bufs(struc
 		if (!buff)
 			break;
 
-		ret = ath12k_dbring_bufs_replenish(ar, ring, buff, gfp);
+		ret = ath12k_dbring_bufs_replenish(ar, ring, buff, id, gfp);
 		if (ret) {
 			ath12k_warn(ab, "failed to replenish db ring num_remain %d req_ent %d\n",
 				    num_remain, req_entries);
@@ -208,7 +213,7 @@ int ath12k_dbring_buf_setup(struct ath12
 	ring->hp_addr = ath12k_hal_srng_get_hp_addr(ab, srng);
 	ring->tp_addr = ath12k_hal_srng_get_tp_addr(ab, srng);
 
-	ret = ath12k_dbring_fill_bufs(ar, ring, GFP_ATOMIC);
+	ret = ath12k_dbring_fill_bufs(ar, ring, db_cap->id, GFP_ATOMIC);
 
 	return ret;
 }
@@ -249,7 +254,6 @@ int ath12k_dbring_get_cap(struct ath12k_
 		if (pdev_idx == ab->db_caps[i].pdev_id &&
 		    id == ab->db_caps[i].id) {
 			*db_cap = ab->db_caps[i];
-
 			return 0;
 		}
 	}
@@ -268,14 +272,16 @@ int ath12k_dbring_buffer_release_event(s
 	struct ath12k_buffer_addr desc;
 	u8 *vaddr_unalign;
 	u32 num_entry, num_buff_reaped;
-	u8 pdev_idx, rbm;
+	u8 pdev_idx, rbm, module_id;
 	u32 cookie;
 	int buf_id;
 	int size;
 	dma_addr_t paddr;
 	int ret = 0;
+	int status;
 
 	pdev_idx = le32_to_cpu(ev->fixed.pdev_id);
+	module_id = le32_to_cpu(ev->fixed.module_id);
 
 	if (pdev_idx >= ab->num_radios) {
 		ath12k_warn(ab, "Invalid pdev id %d\n", pdev_idx);
@@ -302,6 +308,9 @@ int ath12k_dbring_buffer_release_event(s
 	case WMI_DIRECT_BUF_SPECTRAL:
 		ring = ath12k_spectral_get_dbring(ar);
 		break;
+	case WMI_DIRECT_BUF_CFR:
+		ring = ath12k_cfr_get_dbring(ar);
+		break;
 	default:
 		ring = NULL;
 		ath12k_warn(ab, "Recv dma buffer release ev on unsupp module %d\n",
@@ -349,12 +358,16 @@ int ath12k_dbring_buffer_release_event(s
 			handler_data.data = PTR_ALIGN(vaddr_unalign,
 						      ring->buf_align);
 			handler_data.data_sz = ring->buf_sz;
+			handler_data.buff = buff;
+			handler_data.buf_id = buf_id;
 
-			ring->handler(ar, &handler_data);
+			status = ring->handler(ar, &handler_data);
+			if (status == ATH12K_CORRELATE_STATUS_HOLD)
+				continue;
 		}
 
 		memset(buff, 0, size);
-		ath12k_dbring_bufs_replenish(ar, ring, buff, GFP_ATOMIC);
+		ath12k_dbring_bufs_replenish(ar, ring, buff, module_id, GFP_ATOMIC);
 	}
 
 	spin_unlock_bh(&srng->lock);
--- a/drivers/net/wireless/ath/ath12k/dbring.h
+++ b/drivers/net/wireless/ath/ath12k/dbring.h
@@ -21,6 +21,8 @@ struct ath12k_dbring_data {
 	void *data;
 	u32 data_sz;
 	struct ath12k_wmi_dma_buf_release_meta_data_params meta;
+	struct ath12k_dbring_element *buff;
+	u32 buf_id;
 };
 
 struct ath12k_dbring_buf_release_event {
@@ -75,6 +77,11 @@ int ath12k_dbring_set_cfg(struct ath12k
 			  u32 event_timeout_ms,
 			  int (*handler)(struct ath12k *,
 					 struct ath12k_dbring_data *));
+int ath12k_dbring_bufs_replenish(struct ath12k *ar,
+				 struct ath12k_dbring *ring,
+				 struct ath12k_dbring_element *buff,
+				 enum wmi_direct_buffer_module id,
+				 gfp_t gfp);
 int ath12k_dbring_wmi_cfg_setup(struct ath12k *ar,
 				struct ath12k_dbring *ring,
 				enum wmi_direct_buffer_module id);
--- a/drivers/net/wireless/ath/ath12k/debug.h
+++ b/drivers/net/wireless/ath/ath12k/debug.h
@@ -35,6 +35,8 @@ enum ath12k_debug_mask {
 	ATH12K_DBG_MODE1_RECOVERY = 0x00200000,
 	ATH12K_DBG_DP_FST       = 0x00400000,
 	ATH12K_DBG_RM		= 0x00800000,
+	ATH12K_DBG_CFR          = 0x01000000,
+	ATH12K_DBG_CFR_DUMP     = 0x02000000,
 
 	/* keep last*/
 	ATH12K_DBG_ANY		= 0xffffffff,
--- a/drivers/net/wireless/ath/ath12k/debugfs_sta.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs_sta.c
@@ -1905,6 +1905,178 @@ static const struct file_operations fops
 };
 #endif /* CPTCFG_ATH12K_SAWF */
 
+#ifdef CPTCFG_ATH12K_CFR
+static ssize_t ath12k_dbg_sta_write_cfr_capture(struct file *file,
+						const char __user *user_buf,
+						size_t count, loff_t *ppos)
+{
+	struct ieee80211_link_sta *link_sta = file->private_data;
+	struct ieee80211_sta *sta = link_sta->sta;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_hw *ah = ahsta->ahvif->ah;
+	struct ath12k_link_sta *arsta;
+	struct ath12k *ar;
+	struct ath12k_cfr *cfr;
+	struct wmi_peer_cfr_capture_conf_arg arg;
+	u8 link_id = link_sta->link_id;
+	u32 cfr_capture_enable = 0, cfr_capture_bw  = 0;
+	u32 cfr_capture_method = 0, cfr_capture_period = 0;
+	int ret;
+	char buf[64] = {0};
+
+	simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, user_buf, count);
+
+	mutex_lock(&ah->conf_mutex);
+
+	if (!(BIT(link_id) & ahsta->links_map)) {
+		mutex_unlock(&ah->conf_mutex);
+		return -ENOENT;
+	}
+
+	arsta = ahsta->link[link_id];
+	if (!arsta || !arsta->arvif->ar) {
+		mutex_unlock(&ah->conf_mutex);
+		return -ENOENT;
+	}
+
+	ar = arsta->arvif->ar;
+	mutex_lock(&ar->conf_mutex);
+
+	if (ar->state != ATH12K_STATE_ON) {
+		ret = -ENETDOWN;
+		goto out;
+	}
+	if (!ar->cfr.cfr_enabled) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = sscanf(buf, "%u %u %u %u", &cfr_capture_enable, &cfr_capture_bw,
+		     &cfr_capture_period, &cfr_capture_method);
+	if ((ret < 1) || (cfr_capture_enable && ret != 4)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (cfr_capture_enable == arsta->cfr_capture.cfr_enable &&
+	    (cfr_capture_period &&
+	     cfr_capture_period == arsta->cfr_capture.cfr_period) &&
+	    cfr_capture_bw == arsta->cfr_capture.cfr_bandwidth &&
+	    cfr_capture_method == arsta->cfr_capture.cfr_method) {
+		ret = count;
+		goto out;
+	}
+
+	if (!cfr_capture_enable &&
+	    cfr_capture_enable == arsta->cfr_capture.cfr_enable) {
+		ret = count;
+		goto out;
+	}
+
+	if (cfr_capture_enable > WMI_PEER_CFR_CAPTURE_ENABLE ||
+	    cfr_capture_bw > sta->deflink.bandwidth ||
+	    cfr_capture_method > CFR_CAPURE_METHOD_NULL_FRAME_WITH_PHASE ||
+	    cfr_capture_period > WMI_PEER_CFR_PERIODICITY_MAX) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (ar->cfr.cfr_enabled_peer_cnt >= ATH12K_MAX_CFR_ENABLED_CLIENTS &&
+	    !arsta->cfr_capture.cfr_enable) {
+		ret = -EINVAL;
+		ath12k_err(ar->ab, "CFR enable peer threshold reached %u\n",
+			   ar->cfr.cfr_enabled_peer_cnt);
+		goto out;
+	}
+
+	if (!cfr_capture_enable) {
+		cfr_capture_bw = arsta->cfr_capture.cfr_bandwidth;
+		cfr_capture_period = arsta->cfr_capture.cfr_period;
+		cfr_capture_method = arsta->cfr_capture.cfr_method;
+	}
+
+	arg.request = cfr_capture_enable;
+	arg.periodicity = cfr_capture_period;
+	arg.bandwidth = cfr_capture_bw;
+	arg.capture_method = cfr_capture_method;
+
+	ret = ath12k_wmi_peer_set_cfr_capture_conf(ar, arsta->arvif->vdev_id,
+						   link_sta->addr, &arg);
+	if (ret) {
+		ath12k_warn(ar, "failed to send cfr capture info: vdev_id %u peer %pM\n",
+			    arsta->arvif->vdev_id, link_sta->addr);
+		goto out;
+	}
+	ret = count;
+
+	spin_lock_bh(&ar->cfr.lock);
+	cfr = &ar->cfr;
+	if (cfr_capture_enable &&
+	    cfr_capture_enable != arsta->cfr_capture.cfr_enable)
+		cfr->cfr_enabled_peer_cnt++;
+	else if (!cfr_capture_enable)
+		cfr->cfr_enabled_peer_cnt--;
+	spin_unlock_bh(&ar->cfr.lock);
+
+	arsta->cfr_capture.cfr_enable = cfr_capture_enable;
+	arsta->cfr_capture.cfr_period = cfr_capture_period;
+	arsta->cfr_capture.cfr_bandwidth = cfr_capture_bw;
+	arsta->cfr_capture.cfr_method = cfr_capture_method;
+out:
+	mutex_unlock(&ar->conf_mutex);
+	mutex_unlock(&ah->conf_mutex);
+	return ret;
+}
+
+static ssize_t ath12k_dbg_sta_read_cfr_capture(struct file *file,
+					       char __user *user_buf,
+					       size_t count, loff_t *ppos)
+{
+	struct ieee80211_link_sta *link_sta = file->private_data;
+	struct ieee80211_sta *sta = link_sta->sta;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta;
+	struct ath12k_hw *ah = ahsta->ahvif->ah;
+	u8 link_id = link_sta->link_id;
+	char buf[512] = {0};
+	int len = 0;
+
+	mutex_lock(&ah->conf_mutex);
+
+	if (!(BIT(link_id) & ahsta->links_map)) {
+		mutex_unlock(&ah->conf_mutex);
+		return -ENOENT;
+	}
+
+	arsta = ahsta->link[link_id];
+	if (!arsta || !arsta->arvif->ar) {
+		mutex_unlock(&ah->conf_mutex);
+		return -ENOENT;
+	}
+
+	len += scnprintf(buf + len, sizeof(buf) - len, "cfr_enabled = %d\n",
+			 arsta->cfr_capture.cfr_enable);
+	len += scnprintf(buf + len, sizeof(buf) - len, "bandwidth = %d\n",
+			 arsta->cfr_capture.cfr_bandwidth);
+	len += scnprintf(buf + len, sizeof(buf) - len, "period = %d\n",
+			 arsta->cfr_capture.cfr_period);
+	len += scnprintf(buf + len, sizeof(buf) - len, "cfr_method = %d\n",
+			 arsta->cfr_capture.cfr_method);
+
+	mutex_unlock(&ah->conf_mutex);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static const struct file_operations fops_peer_cfr_capture = {
+	.write = ath12k_dbg_sta_write_cfr_capture,
+	.read = ath12k_dbg_sta_read_cfr_capture,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+#endif /* CPTCFG_ATH12K_CFR */
+
 void ath12k_debugfs_sta_op_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			       struct ieee80211_sta *sta, struct dentry *dir)
 {
@@ -1994,5 +2166,11 @@ void ath12k_debugfs_link_sta_op_add(stru
 				    &fops_sawf_tx_delay_stats);
 	}
 #endif
+#ifdef CPTCFG_ATH12K_CFR
+	if (test_bit(WMI_TLV_SERVICE_CFR_CAPTURE_SUPPORT,
+		ar->ab->wmi_ab.svc_map))
+		debugfs_create_file("cfr_capture", 0400, dir, link_sta,
+		&fops_peer_cfr_capture);
+#endif/* CPTCFG_ATH12K_CFR */
 	mutex_unlock(&ah->conf_mutex);
 }
--- a/drivers/net/wireless/ath/ath12k/hw.c
+++ b/drivers/net/wireless/ath/ath12k/hw.c
@@ -101,6 +101,142 @@ static bool ath12k_dp_srng_is_comp_ring_
 	return false;
 }
 
+void ath12k_hw_qcn9274_fill_cfr_hdr_info(struct ath12k *ar,
+					 struct ath12k_csi_cfr_header *header,
+					 struct ath12k_cfr_peer_tx_param *params)
+{
+	header->start_magic_num = ATH12K_CFR_START_MAGIC;
+	header->vendorid = VENDOR_QCA;
+	header->pltform_type = PLATFORM_TYPE_ARM;
+	header->cfr_metadata_len = sizeof(struct cfr_enh_metadata);
+	header->cfr_data_version = ATH12K_CFR_DATA_VERSION_1;
+	header->host_real_ts = ktime_to_ns(ktime_get_real());
+
+	header->cfr_metadata_version = ATH12K_CFR_META_VERSION_9;
+	header->chip_type = ATH12K_CFR_RADIO_QCN9274;
+
+	header->u.meta_enh.status = FIELD_GET(WMI_CFR_PEER_CAPTURE_STATUS,
+					      params->status);
+	header->u.meta_enh.capture_bw = params->bandwidth;
+	header->u.meta_enh.phy_mode = params->phy_mode;
+	header->u.meta_enh.prim20_chan = params->primary_20mhz_chan;
+	header->u.meta_enh.center_freq1 = params->band_center_freq1;
+	header->u.meta_enh.center_freq2 = params->band_center_freq2;
+	header->u.meta_enh.capture_mode = params->bandwidth ?
+		ATH12K_CFR_CAPTURE_DUP_LEGACY_ACK : ATH12K_CFR_CAPTURE_LEGACY_ACK;
+	header->u.meta_enh.capture_type = params->capture_method;
+	header->u.meta_enh.num_rx_chain = ar->cfg_rx_chainmask;
+	header->u.meta_enh.sts_count = params->spatial_streams;
+	header->u.meta_enh.timestamp = params->timestamp_us;
+	header->u.meta_enh.rx_start_ts = params->rx_start_ts;
+	header->u.meta_enh.cfo_measurement = params->cfo_measurement;
+	header->u.meta_enh.mcs_rate = params->mcs_rate;
+	header->u.meta_enh.gi_type = params->gi_type;
+
+	memcpy(header->u.meta_enh.peer_addr.su_peer_addr,
+	       params->peer_mac_addr, ETH_ALEN);
+	memcpy(header->u.meta_enh.chain_rssi, params->chain_rssi,
+	       sizeof(params->chain_rssi));
+	memcpy(header->u.meta_enh.chain_phase, params->chain_phase,
+	       sizeof(params->chain_phase));
+	memcpy(header->u.meta_enh.agc_gain, params->agc_gain,
+	       sizeof(params->agc_gain));
+	memcpy(header->u.meta_enh.agc_gain_tbl_index, params->agc_gain_tbl_index,
+	       sizeof(params->agc_gain_tbl_index));
+}
+
+void ath12k_hw_wcn7850_fill_cfr_hdr_info(struct ath12k *ar,
+					 struct ath12k_csi_cfr_header *header,
+					 struct ath12k_cfr_peer_tx_param *params)
+{
+	header->start_magic_num = ATH12K_CFR_START_MAGIC;
+	header->vendorid = VENDOR_QCA;
+	header->pltform_type = PLATFORM_TYPE_ARM;
+	header->cfr_metadata_len = sizeof(struct cfr_enh_metadata);
+	header->cfr_data_version = ATH12K_CFR_DATA_VERSION_1;
+	header->host_real_ts = ktime_to_ns(ktime_get_real());
+
+	header->cfr_metadata_version = ATH12K_CFR_META_VERSION_9;
+	header->chip_type = ATH12K_CFR_RADIO_WCN7850;
+
+	header->u.meta_enh.status = FIELD_GET(WMI_CFR_PEER_CAPTURE_STATUS,
+					      params->status);
+	header->u.meta_enh.capture_bw = params->bandwidth;
+	header->u.meta_enh.phy_mode = params->phy_mode;
+	header->u.meta_enh.prim20_chan = params->primary_20mhz_chan;
+	header->u.meta_enh.center_freq1 = params->band_center_freq1;
+	header->u.meta_enh.center_freq2 = params->band_center_freq2;
+	header->u.meta_enh.capture_mode = params->bandwidth ?
+		ATH12K_CFR_CAPTURE_DUP_LEGACY_ACK : ATH12K_CFR_CAPTURE_LEGACY_ACK;
+	header->u.meta_enh.capture_type = params->capture_method;
+	header->u.meta_enh.num_rx_chain = ar->cfg_rx_chainmask;
+	header->u.meta_enh.sts_count = params->spatial_streams;
+	header->u.meta_enh.timestamp = params->timestamp_us;
+	header->u.meta_enh.rx_start_ts = params->rx_start_ts;
+	header->u.meta_enh.cfo_measurement = params->cfo_measurement;
+	header->u.meta_enh.mcs_rate = params->mcs_rate;
+	header->u.meta_enh.gi_type = params->gi_type;
+
+	memcpy(header->u.meta_enh.peer_addr.su_peer_addr,
+	       params->peer_mac_addr, ETH_ALEN);
+	memcpy(header->u.meta_enh.chain_rssi, params->chain_rssi,
+	       sizeof(params->chain_rssi));
+	memcpy(header->u.meta_enh.chain_phase, params->chain_phase,
+	       sizeof(params->chain_phase));
+	memcpy(header->u.meta_enh.agc_gain, params->agc_gain,
+	       sizeof(params->agc_gain));
+	memcpy(header->u.meta_enh.agc_gain_tbl_index, params->agc_gain_tbl_index,
+	       sizeof(params->agc_gain_tbl_index));
+}
+
+void ath12k_hw_ipq5332_fill_cfr_hdr_info(struct ath12k *ar,
+					 struct ath12k_csi_cfr_header *header,
+					 struct ath12k_cfr_peer_tx_param *params)
+{
+	header->start_magic_num = ATH12K_CFR_START_MAGIC;
+	header->vendorid = VENDOR_QCA;
+	header->pltform_type = PLATFORM_TYPE_ARM;
+	header->cfr_metadata_len = sizeof(struct cfr_enh_metadata);
+	header->cfr_data_version = ATH12K_CFR_DATA_VERSION_1;
+	header->host_real_ts = ktime_to_ns(ktime_get_real());
+
+	header->cfr_metadata_version = ATH12K_CFR_META_VERSION_7;
+
+	if(ar->ab->hw_rev == ATH12K_HW_QCN6432_HW10)
+		header->chip_type = ATH12K_CFR_RADIO_QCN6432;
+	else
+		header->chip_type = ATH12K_CFR_RADIO_IPQ5332;
+
+	header->u.meta_enh.status = FIELD_GET(WMI_CFR_PEER_CAPTURE_STATUS,
+					      params->status);
+	header->u.meta_enh.capture_bw = params->bandwidth;
+	header->u.meta_enh.phy_mode = params->phy_mode;
+	header->u.meta_enh.prim20_chan = params->primary_20mhz_chan;
+	header->u.meta_enh.center_freq1 = params->band_center_freq1;
+	header->u.meta_enh.center_freq2 = params->band_center_freq2;
+	header->u.meta_enh.capture_mode = params->bandwidth ?
+		ATH12K_CFR_CAPTURE_DUP_LEGACY_ACK : ATH12K_CFR_CAPTURE_LEGACY_ACK;
+	header->u.meta_enh.capture_type = params->capture_method;
+	header->u.meta_enh.num_rx_chain = ar->cfg_rx_chainmask;
+	header->u.meta_enh.sts_count = params->spatial_streams;
+	header->u.meta_enh.timestamp = params->timestamp_us;
+	header->u.meta_enh.rx_start_ts = params->rx_start_ts;
+	header->u.meta_enh.cfo_measurement = params->cfo_measurement;
+	header->u.meta_enh.mcs_rate = params->mcs_rate;
+	header->u.meta_enh.gi_type = params->gi_type;
+
+	memcpy(header->u.meta_enh.peer_addr.su_peer_addr,
+	       params->peer_mac_addr, ETH_ALEN);
+	memcpy(header->u.meta_enh.chain_rssi, params->chain_rssi,
+	       sizeof(params->chain_rssi));
+	memcpy(header->u.meta_enh.chain_phase, params->chain_phase,
+	       sizeof(params->chain_phase));
+	memcpy(header->u.meta_enh.agc_gain, params->agc_gain,
+	       sizeof(params->agc_gain));
+	memcpy(header->u.meta_enh.agc_gain_tbl_index, params->agc_gain_tbl_index,
+	       sizeof(params->agc_gain_tbl_index));
+}
+
 static const struct ath12k_hw_ops qcn9274_ops = {
 	.get_hw_mac_from_pdev_id = ath12k_hw_qcn9274_mac_from_pdev_id,
 	.mac_id_to_pdev_id = ath12k_hw_mac_id_to_pdev_id_qcn9274,
@@ -108,6 +244,7 @@ static const struct ath12k_hw_ops qcn927
 	.rxdma_ring_sel_config = ath12k_dp_rxdma_ring_sel_config_qcn9274,
 	.get_ring_selector = ath12k_hw_get_ring_selector_qcn9274,
 	.dp_srng_is_tx_comp_ring = ath12k_dp_srng_is_comp_ring_qcn9274,
+	.fill_cfr_hdr_info = ath12k_hw_qcn9274_fill_cfr_hdr_info,
 };
 
 static const struct ath12k_hw_ops wcn7850_ops = {
@@ -117,6 +254,7 @@ static const struct ath12k_hw_ops wcn785
 	.rxdma_ring_sel_config = ath12k_dp_rxdma_ring_sel_config_wcn7850,
 	.get_ring_selector = ath12k_hw_get_ring_selector_wcn7850,
 	.dp_srng_is_tx_comp_ring = ath12k_dp_srng_is_comp_ring_wcn7850,
+	.fill_cfr_hdr_info = ath12k_hw_wcn7850_fill_cfr_hdr_info,
 };
 
 static const struct ath12k_hw_ops ipq5332_ops = {
@@ -126,6 +264,7 @@ static const struct ath12k_hw_ops ipq533
 	.rxdma_ring_sel_config = ath12k_dp_rxdma_ring_sel_config_qcn9274,
 	.get_ring_selector = ath12k_hw_get_ring_selector_ipq5332,
 	.dp_srng_is_tx_comp_ring = ath12k_dp_srng_is_comp_ring_ipq5332,
+	.fill_cfr_hdr_info = ath12k_hw_ipq5332_fill_cfr_hdr_info,
 };
 
 
@@ -1661,6 +1800,15 @@ static struct ath12k_hw_params ath12k_hw
 		.fw_mem_mode = ATH12K_QMI_TARGET_MEM_MODE,
 		.is_plink_preferable = true,
 		.support_fse = true,
+		.cfr_support = true,
+		.cfr_dma_hdr_size = sizeof(struct ath12k_cfir_enh_dma_hdr),
+		.cfr_num_stream_bufs = 127,
+		/* sizeof (ath12k_csi_cfr_header) + max cfr header(200 bytes) +
+		 * max cfr payload(16384 bytes)
+		 */
+		.cfr_stream_buf_size = sizeof(struct ath12k_csi_cfr_header) +
+					(CFR_HDR_MAX_LEN_WORDS_QCN9274 *4) +
+					CFR_DATA_MAX_LEN_QCN9274,
 	},
 	{
 		.name = "wcn7850 hw2.0",
@@ -1734,6 +1882,15 @@ static struct ath12k_hw_params ath12k_hw
 		.fw_mem_mode = ATH12K_QMI_TARGET_MEM_MODE,
 		.is_plink_preferable = true,
 		.support_fse = true,
+		.cfr_support = true,
+		.cfr_dma_hdr_size = sizeof(struct ath12k_cfir_enh_dma_hdr),
+		.cfr_num_stream_bufs = 255,
+		/* sizeof (ath12k_csi_cfr_header) + max cfr header(200 bytes) +
+		 * max cfr payload(16384 bytes)
+		 */
+		.cfr_stream_buf_size = sizeof(struct ath12k_csi_cfr_header) +
+					(CFR_HDR_MAX_LEN_WORDS_WCN7850 *4) +
+					CFR_DATA_MAX_LEN_WCN7850,
 	},
 	{
 		.name = "qcn9274 hw2.0",
@@ -1820,6 +1977,15 @@ static struct ath12k_hw_params ath12k_hw
 		.fw_mem_mode = ATH12K_QMI_TARGET_MEM_MODE,
 		.is_plink_preferable = true,
 		.support_fse = true,
+		.cfr_support = true,
+		.cfr_dma_hdr_size = sizeof(struct ath12k_cfir_enh_dma_hdr),
+		.cfr_num_stream_bufs = 127,
+		/* sizeof (ath12k_csi_cfr_header) + max cfr header(200 bytes) +
+		 * max cfr payload(16384 bytes)
+		 */
+		.cfr_stream_buf_size = sizeof(struct ath12k_csi_cfr_header) +
+					(CFR_HDR_MAX_LEN_WORDS_QCN9274 *4) +
+					CFR_DATA_MAX_LEN_QCN9274,
 	},
 	{
 		.name = "ipq5332 hw1.0",
@@ -1910,6 +2076,15 @@ static struct ath12k_hw_params ath12k_hw
 		.fw_mem_mode = ATH12K_QMI_TARGET_MEM_MODE,
 		.is_plink_preferable = false,
 		.support_fse = true,
+		.cfr_support = true,
+		.cfr_dma_hdr_size = sizeof(struct ath12k_cfir_enh_dma_hdr),
+		.cfr_num_stream_bufs = 255,
+		/* sizeof (ath12k_csi_cfr_header) + max cfr header(200 bytes) +
+		 * max cfr payload(16384 bytes)
+		 */
+		.cfr_stream_buf_size = sizeof(struct ath12k_csi_cfr_header) +
+					(CFR_HDR_MAX_LEN_WORDS_IPQ5332 *4) +
+					CFR_DATA_MAX_LEN_IPQ5332,
 	},
 	{
 		.name = "qcn6432 hw1.0",
@@ -1993,6 +2168,15 @@ static struct ath12k_hw_params ath12k_hw
 		.fw_mem_mode = ATH12K_QMI_TARGET_MEM_MODE,
 		.is_plink_preferable = true,
 		.support_fse = true,
+		.cfr_support = true,
+		.cfr_dma_hdr_size = sizeof(struct ath12k_cfir_enh_dma_hdr),
+		.cfr_num_stream_bufs = 128,
+		/* sizeof (ath12k_csi_cfr_header) + max cfr header(200 bytes) +
+		 * max cfr payload(16384 bytes)
+		 */
+		.cfr_stream_buf_size = sizeof(struct ath12k_csi_cfr_header) +
+					(CFR_HDR_MAX_LEN_WORDS_QCN6432 *4) +
+					CFR_DATA_MAX_LEN_QCN6432,
 	},
 };
 
--- a/drivers/net/wireless/ath/ath12k/hw.h
+++ b/drivers/net/wireless/ath/ath12k/hw.h
@@ -12,6 +12,9 @@
 #include "wmi.h"
 #include "hal.h"
 
+struct ath12k_csi_cfr_header;
+struct ath12k_cfr_peer_tx_param;
+
 /* Target configuration defines */
 
 #ifdef CPTCFG_ATH12K_MEM_PROFILE_512M
@@ -255,6 +258,10 @@ struct ath12k_hw_params {
 	int fw_mem_mode;
 	bool is_plink_preferable;
 	bool support_fse;
+	bool cfr_support;
+	u32 cfr_dma_hdr_size;
+	u32 cfr_num_stream_bufs;
+	u32 cfr_stream_buf_size;
 };
 
 struct ath12k_hw_ops {
@@ -264,6 +271,9 @@ struct ath12k_hw_ops {
 	int (*rxdma_ring_sel_config)(struct ath12k_base *ab);
 	u8 (*get_ring_selector)(struct sk_buff *skb);
 	bool (*dp_srng_is_tx_comp_ring)(int ring_num);
+	void (*fill_cfr_hdr_info)(struct ath12k *ar,
+				  struct ath12k_csi_cfr_header *header,
+				  struct ath12k_cfr_peer_tx_param *params);
 };
 
 static inline
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -7593,6 +7593,9 @@ static int ath12k_mac_handle_link_sta_st
 		if (ret)
 			ath12k_warn(ar->ab, "Failed to remove station: %pM for VDEV: %d\n",
 				    arsta->addr, arvif->vdev_id);
+
+		ath12k_cfr_decrement_peer_count(ar, arsta);
+
 		if (sta->valid_links)
 			ath12k_mac_free_unassign_link_sta(arvif->ahvif->ah,
 							  arsta->ahsta, arsta->link_id);
@@ -9136,6 +9139,7 @@ static int ath12k_mac_mgmt_tx_wmi(struct
 	int buf_id;
 	int ret;
 	bool link_agnostic;
+	bool tx_params_valid = false;
 
 	spin_lock_bh(&ar->txmgmt_idr_lock);
 	buf_id = idr_alloc(&ar->txmgmt_idr, skb, 0,
@@ -9179,10 +9183,13 @@ static int ath12k_mac_mgmt_tx_wmi(struct
 	if (info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) {
 		ret = ath12k_wmi_offchan_mgmt_send(ar, arvif->vdev_id, buf_id, skb);
 	} else {
-		link_agnostic = ATH12K_SKB_CB(skb)->flags & ATH12K_SKB_MGMT_LINK_AGNOSTIC;
+		if (ar->cfr.cfr_enabled && ieee80211_is_probe_resp(hdr->frame_control) &&
+		    peer_is_in_cfr_unassoc_pool(ar, hdr->addr1))
+			tx_params_valid = true;
 
+		link_agnostic = ATH12K_SKB_CB(skb)->flags & ATH12K_SKB_MGMT_LINK_AGNOSTIC;
 		ret = ath12k_wmi_mgmt_send(ar, arvif->vdev_id, buf_id, skb,
-					   link_agnostic);
+					   link_agnostic, tx_params_valid);
 	}
 	if (ret) {
 		ath12k_warn(ar->ab, "failed to send mgmt frame: %d\n", ret);
--- a/drivers/net/wireless/ath/ath12k/wmi.c
+++ b/drivers/net/wireless/ath/ath12k/wmi.c
@@ -1195,12 +1195,14 @@ struct sk_buff *ath12k_wmi_alloc_skb(str
 }
 
 int ath12k_wmi_mgmt_send(struct ath12k *ar, u32 vdev_id, u32 buf_id,
-			 struct sk_buff *frame, bool link_agnostic)
+			 struct sk_buff *frame, bool link_agnostic,
+			 bool tx_params_valid)
 {
 	struct ath12k_wmi_pdev *wmi = ar->wmi;
 	struct wmi_mgmt_send_cmd *cmd;
 	struct wmi_mlo_mgmt_send_params *ml_params;
 	struct wmi_tlv *frame_tlv;
+	struct wmi_mgmt_send_params *params;
 	struct sk_buff *skb;
 	u32 buf_len;
 	int ret, len;
@@ -1215,6 +1217,9 @@ int ath12k_wmi_mgmt_send(struct ath12k *
 		len += sizeof(struct wmi_mgmt_send_params) +
 				TLV_HDR_SIZE + sizeof(*ml_params);
 
+	if (tx_params_valid)
+		len += sizeof(*params);
+
 	skb = ath12k_wmi_alloc_skb(wmi->wmi_ab, len);
 	if (!skb)
 		return -ENOMEM;
@@ -1229,7 +1234,7 @@ int ath12k_wmi_mgmt_send(struct ath12k *
 	cmd->paddr_hi = cpu_to_le32(upper_32_bits(ATH12K_SKB_CB(frame)->paddr));
 	cmd->frame_len = cpu_to_le32(frame->len);
 	cmd->buf_len = cpu_to_le32(buf_len);
-	cmd->tx_params_valid = 0;
+	cmd->tx_params_valid = tx_params_valid;
 
 	frame_tlv = (struct wmi_tlv *)(skb->data + sizeof(*cmd));
 	frame_tlv->header = ath12k_wmi_tlv_hdr(WMI_TAG_ARRAY_BYTE, roundup(buf_len, sizeof(u32)));
@@ -1259,6 +1264,13 @@ int ath12k_wmi_mgmt_send(struct ath12k *
 
 	ml_params->hw_link_id = WMI_MLO_MGMT_TID;
 
+	if (tx_params_valid) {
+		params = (struct wmi_mgmt_send_params *)(skb->data + (len - sizeof(*params)));
+		params->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_TX_SEND_PARAMS) |
+				     FIELD_PREP(WMI_TLV_LEN, sizeof(*params) - TLV_HDR_SIZE);
+		params->tx_param_dword1 |= WMI_TX_PARAMS_DWORD1_CFR_CAPTURE;
+	}
+
 send:
 	ret = ath12k_wmi_cmd_send(wmi, skb, WMI_MGMT_TX_SEND_CMDID);
 	if (ret) {
@@ -5588,6 +5600,45 @@ ath12k_wmi_append_prb_resp_cu_params(str
 	return ptr;
 }
 
+int ath12k_wmi_peer_set_cfr_capture_conf(struct ath12k *ar,
+					 u32 vdev_id, const u8 *mac_addr,
+					 struct wmi_peer_cfr_capture_conf_arg *arg)
+{
+	struct wmi_peer_cfr_capture_cmd_fixed_param *cmd;
+	struct sk_buff *skb;
+	int ret;
+
+	skb = ath12k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));
+	if (!skb)
+		return -ENOMEM;
+
+	cmd = (struct wmi_peer_cfr_capture_cmd_fixed_param *)skb->data;
+	cmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,
+				     WMI_TAG_PEER_CFR_CAPTURE_CMD) |
+			  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);
+
+	ether_addr_copy(cmd->mac_addr.addr, mac_addr);
+	cmd->request = arg->request;
+	cmd->vdev_id = vdev_id;
+	cmd->periodicity = arg->periodicity;
+	cmd->bandwidth = arg->bandwidth;
+	cmd->capture_method = arg->capture_method;
+
+	ret = ath12k_wmi_cmd_send(ar->wmi, skb, WMI_PEER_CFR_CAPTURE_CMDID);
+	if (ret) {
+		ath12k_warn(ar->ab,
+			    "WMI vdev %d failed to send peer cfr capture cmd\n",
+			    vdev_id);
+		dev_kfree_skb(skb);
+	}
+
+	ath12k_dbg(ar->ab, ATH12K_DBG_WMI,
+		   "WMI vdev %i set cfr capture conf cmd->request=%d cmd->vdev_id=%d cmd->periodicity=%d cmd->bandwidth=%d cmd->capture_method=%d",
+		   vdev_id, cmd->request, cmd->vdev_id, cmd->periodicity,
+	           cmd->bandwidth, cmd->capture_method);
+	return ret;
+}
+
 int ath12k_wmi_probe_resp_tmpl(struct ath12k *ar, u32 vdev_id,
 			       struct sk_buff *tmpl)
 {
@@ -13298,8 +13349,8 @@ ath12k_wmi_rssi_dbm_conv_event_parser(st
 }
 
 static struct
-ath12k *ath12k_wmi_rssi_dbm_process_fixed_param( struct ath12k_base *ab,
-						 u8 *ptr, size_t len)
+ath12k *ath12k_wmi_rssi_dbm_process_fixed_param(struct ath12k_base *ab,
+						u8 *ptr, size_t len)
 {
 	struct ath12k *ar;
 	const struct wmi_tlv *tlv;
@@ -14559,6 +14610,101 @@ static void ath12k_wmi_event_ani_ofdm_le
 	complete(&ar->ani_ofdm_event);
 }
 
+
+static void ath12k_wmi_tlv_cfr_cpature_event_fixed_param(const void *ptr,
+							 void *data)
+{
+	struct ath12k_cfr_peer_tx_param *tx_params =
+			(struct ath12k_cfr_peer_tx_param *)data;
+	struct ath12k_wmi_cfr_peer_tx_event_param *params =
+			(struct ath12k_wmi_cfr_peer_tx_event_param *)ptr;
+
+	tx_params->capture_method = params->capture_method;
+	tx_params->vdev_id = params->vdev_id;
+	ether_addr_copy(tx_params->peer_mac_addr, params->mac_addr.addr);
+	tx_params->primary_20mhz_chan = params->chan_mhz;
+	tx_params->bandwidth = params->bandwidth;
+	tx_params->phy_mode = params->phy_mode;
+	tx_params->band_center_freq1 = params->band_center_freq1;
+	tx_params->band_center_freq2 = params->band_center_freq2;
+	tx_params->spatial_streams = params->sts_count;
+	tx_params->correlation_info_1 = params->correlation_info_1;
+	tx_params->correlation_info_2 = params->correlation_info_2;
+	tx_params->status = params->status;
+	tx_params->timestamp_us = params->timestamp_us;
+	tx_params->counter = params->counter;
+	memcpy(tx_params->chain_rssi, params->chain_rssi,
+	       sizeof(tx_params->chain_rssi));
+
+	if (WMI_CFR_CFO_MEASUREMENT_VALID & params->cfo_measurement)
+		tx_params->cfo_measurement = FIELD_GET(WMI_CFR_CFO_MEASUREMENT_RAW_DATA,
+						       params->cfo_measurement);
+	else
+		tx_params->cfo_measurement = 0;
+
+	tx_params->rx_start_ts = params->rx_start_ts;
+	tx_params->rx_ts_reset = params->rx_ts_reset;
+}
+
+static void ath12k_wmi_tlv_cfr_cpature_phase_fixed_param(const void *ptr,
+							 void *data)
+{
+	struct ath12k_cfr_peer_tx_param *tx_params =
+			(struct ath12k_cfr_peer_tx_param *)data;
+	struct ath12k_wmi_cfr_peer_tx_event_phase_param *params =
+			(struct ath12k_wmi_cfr_peer_tx_event_phase_param *)ptr;
+	int i;
+
+	for (i = 0; i < WMI_MAX_CHAINS; i++) {
+		tx_params->chain_phase[i] = params->chain_phase[i];
+		tx_params->agc_gain[i] = params->agc_gain[i];
+	}
+}
+
+static int ath12k_wmi_tlv_cfr_capture_evt_parse(struct ath12k_base *ab,
+						u16 tag, u16 len,
+						const void *ptr, void *data)
+{
+	switch (tag) {
+	case WMI_TAG_PEER_CFR_CAPTURE_EVENT:
+		ath12k_wmi_tlv_cfr_cpature_event_fixed_param(ptr, data);
+		break;
+	case WMI_TAG_CFR_CAPTURE_PHASE_PARAM:
+		ath12k_wmi_tlv_cfr_cpature_phase_fixed_param(ptr, data);
+		break;
+	default:
+		ath12k_warn(ab, "Invalid tag received tag %d len %d\n",
+		tag, len);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void ath12k_wmi_parse_cfr_capture_event(struct ath12k_base *ab,
+					       struct sk_buff *skb)
+{
+	struct ath12k_cfr_peer_tx_param params = {};
+	int ret;
+
+	ath12k_dbg_dump(ab, ATH12K_DBG_CFR_DUMP, "cfr_dump:", "",
+			skb->data, skb->len);
+
+	ret = ath12k_wmi_tlv_iter(ab, skb->data, skb->len,
+				  ath12k_wmi_tlv_cfr_capture_evt_parse,
+				  &params);
+	if (ret) {
+		ath12k_warn(ab, "failed to parse cfr capture event tlv %d\n",
+			    ret);
+		return;
+	}
+
+	ret = ath12k_process_cfr_capture_event(ab, &params);
+	if (ret)
+		ath12k_warn(ab, "failed to process cfr cpature ret = %d\n",
+			    ret);
+}
+
 static void ath12k_wmi_op_rx(struct ath12k_base *ab, struct sk_buff *skb)
 {
 	struct wmi_cmd_hdr *cmd_hdr;
@@ -14695,6 +14841,9 @@ static void ath12k_wmi_op_rx(struct ath1
 	case WMI_CTRL_PATH_STATS_EVENTID:
 		ath12k_wmi_ctrl_path_stats_event(ab, skb);
 		break;
+	case WMI_PEER_CFR_CAPTURE_EVENTID:
+		ath12k_wmi_parse_cfr_capture_event(ab, skb);
+		break;
 	case WMI_PDEV_RSSI_DBM_CONVERSION_PARAMS_INFO_EVENTID:
 		ath12k_wmi_rssi_dbm_conversion_param_info(ab, skb);
 		break;
--- a/drivers/net/wireless/ath/ath12k/wmi.h
+++ b/drivers/net/wireless/ath/ath12k/wmi.h
@@ -932,6 +932,8 @@ enum wmi_tlv_event_id {
 	WMI_PEER_RESERVED9_EVENTID,
 	WMI_PEER_RESERVED10_EVENTID,
 	WMI_PEER_OPER_MODE_CHANGE_EVENTID,
+	WMI_PEER_TX_PN_RESPONSE_EVENTID,
+	WMI_PEER_CFR_CAPTURE_EVENTID,
 	WMI_MGMT_RX_EVENTID = WMI_TLV_CMD(WMI_GRP_MGMT),
 	WMI_HOST_SWBA_EVENTID,
 	WMI_TBTTOFFSET_UPDATE_EVENTID,
@@ -1228,6 +1230,7 @@ enum wmi_tlv_pdev_param {
 	WMI_PDEV_PARAM_RADIO_DIAGNOSIS_ENABLE,
 	WMI_PDEV_PARAM_MESH_MCAST_ENABLE,
 	WMI_PDEV_PARAM_SET_CONG_CTRL_MAX_MSDUS = 0xa6,
+	WMI_PDEV_PARAM_PER_PEER_CFR_ENABLE = 0xa8,
 	WMI_PDEV_PARAM_SUB_CHANNEL_MARKING = 0xb0,
 	WMI_PDEV_PARAM_SET_CMD_OBSS_PD_THRESHOLD = 0xbc,
 	WMI_PDEV_PARAM_SET_CMD_OBSS_PD_PER_AC = 0xbe,
@@ -2144,7 +2147,9 @@ enum wmi_tlv_tag {
 	/* TODO add all the missing cmds */
 	WMI_TAG_PDEV_PEER_PKTLOG_FILTER_CMD = 0x301,
 	WMI_TAG_PDEV_PEER_PKTLOG_FILTER_INFO,
+	WMI_TAG_PEER_CFR_CAPTURE_EVENT = 0x317,
 	WMI_TAG_MUEDCA_PARAMS_CONFIG_EVENT = 0x32a,
+	WMI_TAG_CFR_CAPTURE_PHASE_PARAM = 0x33b,
 	WMI_TAG_SERVICE_READY_EXT2_EVENT = 0x334,
 	WMI_TAG_FILS_DISCOVERY_TMPL_CMD = 0x344,
 	WMI_TAG_MULTIPLE_VDEV_RESTART_RESPONSE_EVENT = 0x365,
@@ -2539,7 +2544,7 @@ enum wmi_direct_buffer_module {
 	WMI_DIRECT_BUF_SPECTRAL = 0,
 	WMI_DIRECT_BUF_CFR = 1,
 	WMI_CONFIG_MODULE_CV_UPLOAD = 2,
-
+	WMI_CONFIG_MODULE_WIFI_RADAR = 3,
 	/* keep it last */
 	WMI_DIRECT_BUF_MAX
 };
@@ -4177,6 +4182,88 @@ struct wmi_bssid_arg {
 	const u8 *bssid;
 };
 
+enum ath12k_wmi_frame_tx_status {
+	WMI_FRAME_TX_STATUS_OK,
+	WMI_FRAME_TX_STATUS_XRETRY,
+	WMI_FRAME_TX_STATUS_DROP,
+	WMI_FRAME_TX_STATUS_FILTERED,
+};
+
+struct wmi_peer_cfr_capture_conf_arg {
+	u32 request;
+	u32 periodicity;
+	u32 bandwidth;
+	u32 capture_method;
+};
+
+struct wmi_peer_cfr_capture_cmd_fixed_param {
+	u32 tlv_header;
+	u32 request;
+	struct wmi_mac_addr mac_addr;
+	u32 vdev_id;
+	u32 periodicity;
+	u32 bandwidth;
+	u32 capture_method;
+} __packed;
+
+#define WMI_PEER_CFR_CAPTURE_ENABLE   1
+#define WMI_PEER_CFR_CAPTURE_DISABLE  0
+
+/* periodicity in ms */
+#define WMI_PEER_CFR_PERIODICITY_MAX  (10*60*1000)
+
+#define WMI_CFR_FRAME_TX_STATUS GENMASK(1, 0)
+#define WMI_CFR_CAPTURE_STATUS_PEER_PS BIT(30)
+#define WMI_CFR_PEER_CAPTURE_STATUS BIT(31)
+
+#define WMI_CFR_CORRELATION_INFO2_BUF_ADDR_HIGH GENMASK(3, 0)
+#define WMI_CFR_CORRELATION_INFO2_PPDU_ID GENMASK(31, 16)
+
+#define WMI_CFR_CFO_MEASUREMENT_VALID BIT(0)
+#define WMI_CFR_CFO_MEASUREMENT_RAW_DATA GENMASK(14, 1)
+
+struct ath12k_wmi_cfr_peer_tx_event_param {
+	u32 capture_method;
+	u32 vdev_id;
+	struct wmi_mac_addr mac_addr;
+	u32 chan_mhz;
+	u32 bandwidth;
+	u32 phy_mode;
+	u32 band_center_freq1;
+	u32 band_center_freq2;
+	u32 sts_count;
+	u32 correlation_info_1;
+	u32 correlation_info_2;
+	u32 status;
+	u32 timestamp_us;
+	u32 counter;
+	u32 chain_rssi[WMI_MAX_CHAINS];
+	u32 cfo_measurement;
+	u32 rx_start_ts;
+	u32 rx_ts_reset;
+} __packed;
+
+struct ath12k_wmi_cfr_peer_tx_event_phase_param {
+	u32 chain_phase[WMI_MAX_CHAINS];
+	u8 agc_gain[WMI_MAX_CHAINS];
+} __packed;
+
+enum ath12k_wmi_cfr_capture_bw {
+	WMI_PEER_CFR_CAPTURE_BW_20MHZ,
+	WMI_PEER_CFR_CAPTURE_BW_40MHZ,
+	WMI_PEER_CFR_CAPTURE_BW_80MHZ,
+	WMI_PEER_CFR_CAPTURE_BW_160MHZ,
+	WMI_PEER_CFR_CAPTURE_BW_80_80MHZ,
+	WMI_PEER_CFR_CAPTURE_BW_MAX,
+};
+
+struct ath12k_wmi_peer_cfr_capture_conf {
+	u32 request;
+	u32 periodicity;
+	u32 bandwidth;
+	u32 capture_method;
+};
+
 struct wmi_start_scan_arg {
 	u32 scan_id;
 	u32 scan_req_id;
@@ -4663,7 +4750,8 @@ struct wmi_scan_chan_list_cmd {
 #define WMI_TX_PARAMS_DWORD1_BW_MASK		GENMASK(14, 8)
 #define WMI_TX_PARAMS_DWORD1_PREAMBLE_TYPE	GENMASK(19, 15)
 #define WMI_TX_PARAMS_DWORD1_FRAME_TYPE		BIT(20)
-#define WMI_TX_PARAMS_DWORD1_RSVD		GENMASK(31, 21)
+#define WMI_TX_PARAMS_DWORD1_CFR_CAPTURE        BIT(21)
+#define WMI_TX_PARAMS_DWORD1_RSVD		GENMASK(31, 22)
 
 struct wmi_mgmt_send_cmd {
 	__le32 tlv_header;
@@ -8492,7 +8580,8 @@ int ath12k_wmi_cmd_send(struct ath12k_wm
 			u32 cmd_id);
 struct sk_buff *ath12k_wmi_alloc_skb(struct ath12k_wmi_base *wmi_sc, u32 len);
 int ath12k_wmi_mgmt_send(struct ath12k *ar, u32 vdev_id, u32 buf_id,
-			 struct sk_buff *frame, bool link_agnostic);
+			 struct sk_buff *frame, bool link_agnostic,
+			 bool tx_params_valid);
 int ath12k_wmi_offchan_mgmt_send(struct ath12k *ar, u32 vdev_id, u32 buf_id,
 				 struct sk_buff *frame);
 int ath12k_wmi_bcn_tmpl(struct ath12k *ar, u32 vdev_id,
@@ -8657,6 +8746,9 @@ int ath12k_wmi_pdev_get_tpc_table_cmdid(
 void ath12k_wmi_free_tpc_stats_mem(struct ath12k *ar);
 int ath12k_wmi_send_wmi_ctrl_stats_cmd(struct ath12k *ar,
 				       struct wmi_ctrl_path_stats_cmd_param *param);
+int ath12k_wmi_peer_set_cfr_capture_conf(struct ath12k *ar,
+					 u32 vdev_id, const u8 *mac,
+					 struct wmi_peer_cfr_capture_conf_arg *arg);
 int ath12k_wmi_mlo_setup(struct ath12k *ar,
 			 struct wmi_mlo_setup_params *mlo_params);
 int ath12k_wmi_mlo_ready(struct ath12k *ar);
--- a/local-symbols
+++ b/local-symbols
@@ -188,6 +188,7 @@ ATH12K_TRACING=
 ATH12K_PPE_DS_SUPPORT=
 ATH12K_SPECTRAL=
 ATH12K_PKTLOG=
+ATH12K_CFR=
 ATH12K_MEM_PROFILE_512M=
 ATH12K_SAWF=
 ATH12K_POWER_OPTIMIZATION=
