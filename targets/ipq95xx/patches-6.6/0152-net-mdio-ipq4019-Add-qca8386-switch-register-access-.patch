From 7826ae0e80f74fb89ae9627bb07604c9a0e310ff Mon Sep 17 00:00:00 2001
From: Luo Jie <quic_luoj@quicinc.com>
Date: Wed, 22 Mar 2023 18:08:43 +0800
Subject: [PATCH 097/500] net: mdio-ipq4019: Add qca8386 switch register access
 function.

When the IPQ MDIO driver works with qca8386 switch, there are
some initialization such as PHY address fixup and clock configuration
needed before the qca8386 embedded PHY probed.

Change-Id: Ife0597d49b2dc124dcd42d209675e1decc5c256c
Signed-off-by: Luo Jie <quic_luoj@quicinc.com>
---
 drivers/net/mdio/mdio-ipq4019.c | 56 +++++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)

diff --git a/drivers/net/mdio/mdio-ipq4019.c b/drivers/net/mdio/mdio-ipq4019.c
index 78b93de636f5..74d0c5a38080 100644
--- a/drivers/net/mdio/mdio-ipq4019.c
+++ b/drivers/net/mdio/mdio-ipq4019.c
@@ -37,6 +37,9 @@
 
 #define IPQ_PHY_SET_DELAY_US	100000
 
+#define IPQ_HIGH_ADDR_PREFIX	0x18
+#define IPQ_LOW_ADDR_PREFIX	0x10
+
 struct ipq4019_mdio_data {
 	void __iomem	*membase;
 	void __iomem *eth_ldo_rdy;
@@ -203,6 +206,59 @@ static int ipq4019_mdio_write_c22(struct mii_bus *bus, int mii_id, int regnum,
 	return 0;
 }
 
+static inline void split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page, u16 *sw_addr)
+{
+	*r1 = regaddr & 0x1c;
+
+	regaddr >>= 5;
+	*r2 = regaddr & 0x7;
+
+	regaddr >>= 3;
+	*page = regaddr & 0xffff;
+
+	regaddr >>= 16;
+	*sw_addr = regaddr & 0xff;
+}
+
+u32 ipq_mii_read(struct mii_bus *bus, unsigned int reg)
+{
+	u16 r1, r2, page, sw_addr;
+	u16 lo, hi;
+
+	split_addr(reg, &r1, &r2, &page, &sw_addr);
+
+	/* There is no competition, so the lock is not needed.
+	 * since this function is only called before mii_bus registered.
+	 */
+	bus->write(bus, IPQ_HIGH_ADDR_PREFIX | (sw_addr >> 5), sw_addr & 0x1f, page);
+
+	lo = bus->read(bus, IPQ_LOW_ADDR_PREFIX | r2, r1);
+	hi = bus->read(bus, IPQ_LOW_ADDR_PREFIX | r2, r1 | BIT(1));
+
+	return hi << 16 | lo;
+};
+
+int ipq_mii_write(struct mii_bus *bus, unsigned int reg, unsigned int val)
+{
+	u16 r1, r2, page, sw_addr;
+	u16 lo, hi;
+
+	lo = val & 0xffff;
+	hi = (u16)(val >> 16);
+
+	split_addr(reg, &r1, &r2, &page, &sw_addr);
+
+	/* There is no competition, so the lock is not needed.
+	 * since this function is only called before mii_bus registered.
+	 */
+	bus->write(bus, IPQ_HIGH_ADDR_PREFIX | (sw_addr >> 5), sw_addr & 0x1f, page);
+
+	bus->write(bus, IPQ_LOW_ADDR_PREFIX | r2, r1, lo);
+	bus->write(bus, IPQ_LOW_ADDR_PREFIX | r2, r1 | BIT(1), hi);
+
+	return 0;
+};
+
 static int ipq_mdio_reset(struct mii_bus *bus)
 {
 	struct ipq4019_mdio_data *priv = bus->priv;
-- 
2.34.1

