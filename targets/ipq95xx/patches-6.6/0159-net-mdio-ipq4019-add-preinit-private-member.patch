From 8f799cf9613508c7d47ffc3208511f2d63dd64f7 Mon Sep 17 00:00:00 2001
From: Luo Jie <quic_luoj@quicinc.com>
Date: Mon, 24 Jul 2023 12:42:59 +0800
Subject: [PATCH 104/500] net: mdio-ipq4019: add preinit private member

Add the cmn block reset if the DTS cmn_blk reg defined.

Change-Id: I956a6c0929c49b62cb87e452c449ec1a5c7a6b89
Signed-off-by: Luo Jie <quic_luoj@quicinc.com>
---
 drivers/net/mdio/mdio-ipq4019.c | 129 ++++++++++++++++++++++++--------
 1 file changed, 99 insertions(+), 30 deletions(-)

diff --git a/drivers/net/mdio/mdio-ipq4019.c b/drivers/net/mdio/mdio-ipq4019.c
index dda898e9a629..3ec8287d91f4 100644
--- a/drivers/net/mdio/mdio-ipq4019.c
+++ b/drivers/net/mdio/mdio-ipq4019.c
@@ -72,6 +72,10 @@
 #define PHY_MMD1_CTRL2ANA_OPTION2_REG		0x40018102
 #define ETH_LDO_RDY_CNT				3
 
+#define CMN_PLL_REFCLK_INDEX	GENMASK(3, 0)
+#define CMN_PLL_REFCLK_EXTERNAL	BIT(9)
+#define CMN_ANA_EN_SW_RSTN	BIT(6)
+
 enum mdio_clk_id {
 	MDIO_CLK_MDIO_AHB,
 	MDIO_CLK_UNIPHY0_AHB,
@@ -82,10 +86,11 @@ enum mdio_clk_id {
 };
 
 struct ipq4019_mdio_data {
-	void __iomem	*membase;
+	void __iomem	*membase[2];
 	void __iomem *eth_ldo_rdy[ETH_LDO_RDY_CNT];
 	int clk_div;
 	struct gpio_descs *reset_gpios;
+	void (*preinit)(struct mii_bus *bus);
 	struct clk *clk[MDIO_CLK_CNT];
 };
 
@@ -99,7 +104,7 @@ static int ipq4019_mdio_wait_busy(struct mii_bus *bus)
 	struct ipq4019_mdio_data *priv = bus->priv;
 	unsigned int busy;
 
-	return readl_poll_timeout(priv->membase + MDIO_CMD_REG, busy,
+	return readl_poll_timeout(priv->membase[0] + MDIO_CMD_REG, busy,
 				  (busy & MDIO_CMD_ACCESS_BUSY) == 0,
 				  IPQ4019_MDIO_SLEEP, IPQ4019_MDIO_TIMEOUT);
 }
@@ -114,23 +119,23 @@ static int ipq4019_mdio_read_c45(struct mii_bus *bus, int mii_id, int mmd,
 	if (ipq4019_mdio_wait_busy(bus))
 		return -ETIMEDOUT;
 
-	data = readl(priv->membase + MDIO_MODE_REG);
+	data = readl(priv->membase[0] + MDIO_MODE_REG);
 
 	data |= MDIO_MODE_C45;
 	data |= FIELD_PREP(MDIO_CLK_DIV_MASK, priv->clk_div);
 
-	writel(data, priv->membase + MDIO_MODE_REG);
+	writel(data, priv->membase[0] + MDIO_MODE_REG);
 
 	/* issue the phy address and mmd */
-	writel((mii_id << 8) | mmd, priv->membase + MDIO_ADDR_REG);
+	writel((mii_id << 8) | mmd, priv->membase[0] + MDIO_ADDR_REG);
 
 	/* issue reg */
-	writel(reg, priv->membase + MDIO_DATA_WRITE_REG);
+	writel(reg, priv->membase[0] + MDIO_DATA_WRITE_REG);
 
 	cmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_C45_ADDR;
 
 	/* issue read command */
-	writel(cmd, priv->membase + MDIO_CMD_REG);
+	writel(cmd, priv->membase[0] + MDIO_CMD_REG);
 
 	/* Wait read complete */
 	if (ipq4019_mdio_wait_busy(bus))
@@ -138,13 +143,13 @@ static int ipq4019_mdio_read_c45(struct mii_bus *bus, int mii_id, int mmd,
 
 	cmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_C45_READ;
 
-	writel(cmd, priv->membase + MDIO_CMD_REG);
+	writel(cmd, priv->membase[0] + MDIO_CMD_REG);
 
 	if (ipq4019_mdio_wait_busy(bus))
 		return -ETIMEDOUT;
 
 	/* Read and return data */
-	return readl(priv->membase + MDIO_DATA_READ_REG);
+	return readl(priv->membase[0] + MDIO_DATA_READ_REG);
 }
 
 static int ipq4019_mdio_read_c22(struct mii_bus *bus, int mii_id, int regnum)
@@ -156,27 +161,27 @@ static int ipq4019_mdio_read_c22(struct mii_bus *bus, int mii_id, int regnum)
 	if (ipq4019_mdio_wait_busy(bus))
 		return -ETIMEDOUT;
 
-	data = readl(priv->membase + MDIO_MODE_REG);
+	data = readl(priv->membase[0] + MDIO_MODE_REG);
 
 	data &= ~MDIO_MODE_C45;
 	data |= FIELD_PREP(MDIO_CLK_DIV_MASK, priv->clk_div);
 
-	writel(data, priv->membase + MDIO_MODE_REG);
+	writel(data, priv->membase[0] + MDIO_MODE_REG);
 
 	/* issue the phy address and reg */
-	writel((mii_id << 8) | regnum, priv->membase + MDIO_ADDR_REG);
+	writel((mii_id << 8) | regnum, priv->membase[0] + MDIO_ADDR_REG);
 
 	cmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_READ;
 
 	/* issue read command */
-	writel(cmd, priv->membase + MDIO_CMD_REG);
+	writel(cmd, priv->membase[0] + MDIO_CMD_REG);
 
 	/* Wait read complete */
 	if (ipq4019_mdio_wait_busy(bus))
 		return -ETIMEDOUT;
 
 	/* Read and return data */
-	return readl(priv->membase + MDIO_DATA_READ_REG);
+	return readl(priv->membase[0] + MDIO_DATA_READ_REG);
 }
 
 static int ipq4019_mdio_write_c45(struct mii_bus *bus, int mii_id, int mmd,
@@ -189,31 +194,31 @@ static int ipq4019_mdio_write_c45(struct mii_bus *bus, int mii_id, int mmd,
 	if (ipq4019_mdio_wait_busy(bus))
 		return -ETIMEDOUT;
 
-	data = readl(priv->membase + MDIO_MODE_REG);
+	data = readl(priv->membase[0] + MDIO_MODE_REG);
 
 	data |= MDIO_MODE_C45;
 	data |= FIELD_PREP(MDIO_CLK_DIV_MASK, priv->clk_div);
 
-	writel(data, priv->membase + MDIO_MODE_REG);
+	writel(data, priv->membase[0] + MDIO_MODE_REG);
 
 	/* issue the phy address and mmd */
-	writel((mii_id << 8) | mmd, priv->membase + MDIO_ADDR_REG);
+	writel((mii_id << 8) | mmd, priv->membase[0] + MDIO_ADDR_REG);
 
 	/* issue reg */
-	writel(reg, priv->membase + MDIO_DATA_WRITE_REG);
+	writel(reg, priv->membase[0] + MDIO_DATA_WRITE_REG);
 
 	cmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_C45_ADDR;
 
-	writel(cmd, priv->membase + MDIO_CMD_REG);
+	writel(cmd, priv->membase[0] + MDIO_CMD_REG);
 
 	if (ipq4019_mdio_wait_busy(bus))
 		return -ETIMEDOUT;
 
 	/* issue write data */
-	writel(value, priv->membase + MDIO_DATA_WRITE_REG);
+	writel(value, priv->membase[0] + MDIO_DATA_WRITE_REG);
 
 	cmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_C45_WRITE;
-	writel(cmd, priv->membase + MDIO_CMD_REG);
+	writel(cmd, priv->membase[0] + MDIO_CMD_REG);
 
 	/* Wait write complete */
 	if (ipq4019_mdio_wait_busy(bus))
@@ -233,23 +238,23 @@ static int ipq4019_mdio_write_c22(struct mii_bus *bus, int mii_id, int regnum,
 		return -ETIMEDOUT;
 
 	/* Enter Clause 22 mode */
-	data = readl(priv->membase + MDIO_MODE_REG);
+	data = readl(priv->membase[0] + MDIO_MODE_REG);
 
 	data &= ~MDIO_MODE_C45;
 	data |= FIELD_PREP(MDIO_CLK_DIV_MASK, priv->clk_div);
 
-	writel(data, priv->membase + MDIO_MODE_REG);
+	writel(data, priv->membase[0] + MDIO_MODE_REG);
 
 	/* issue the phy address and reg */
-	writel((mii_id << 8) | regnum, priv->membase + MDIO_ADDR_REG);
+	writel((mii_id << 8) | regnum, priv->membase[0] + MDIO_ADDR_REG);
 
 	/* issue write data */
-	writel(value, priv->membase + MDIO_DATA_WRITE_REG);
+	writel(value, priv->membase[0] + MDIO_DATA_WRITE_REG);
 
 	/* issue write command */
 	cmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_WRITE;
 
-	writel(cmd, priv->membase + MDIO_CMD_REG);
+	writel(cmd, priv->membase[0] + MDIO_CMD_REG);
 
 	/* Wait write complete */
 	if (ipq4019_mdio_wait_busy(bus))
@@ -592,12 +597,65 @@ void ipq_mii_preinit(struct mii_bus *bus)
 }
 EXPORT_SYMBOL_GPL(ipq_mii_preinit);
 
+static void ipq_cmn_clk_reset(struct mii_bus *bus)
+{
+	u32 reg_val;
+	const char *cmn_ref_clk;
+	struct ipq4019_mdio_data *priv = bus->priv;
+
+	if (priv && priv->membase[1]) {
+		/* Select reference clock source */
+		reg_val = readl(priv->membase[1] + 4);
+		reg_val &= ~(CMN_PLL_REFCLK_EXTERNAL | CMN_PLL_REFCLK_INDEX);
+
+		cmn_ref_clk = of_get_property(bus->parent->of_node, "cmn_ref_clk", NULL);
+		if (!cmn_ref_clk) {
+			/* Internal 48MHZ selected by default */
+			reg_val |= FIELD_PREP(CMN_PLL_REFCLK_INDEX, 7);
+		} else {
+			if (!strcmp(cmn_ref_clk, "external_25MHz"))
+				reg_val |= (CMN_PLL_REFCLK_EXTERNAL |
+						FIELD_PREP(CMN_PLL_REFCLK_INDEX, 3));
+			else if (!strcmp(cmn_ref_clk, "external_31250KHz"))
+				reg_val |= (CMN_PLL_REFCLK_EXTERNAL |
+						FIELD_PREP(CMN_PLL_REFCLK_INDEX, 4));
+			else if (!strcmp(cmn_ref_clk, "external_40MHz"))
+				reg_val |= (CMN_PLL_REFCLK_EXTERNAL |
+						FIELD_PREP(CMN_PLL_REFCLK_INDEX, 6));
+			else if (!strcmp(cmn_ref_clk, "external_48MHz"))
+				reg_val |= (CMN_PLL_REFCLK_EXTERNAL |
+						FIELD_PREP(CMN_PLL_REFCLK_INDEX, 7));
+			else if (!strcmp(cmn_ref_clk, "external_50MHz"))
+				reg_val |= (CMN_PLL_REFCLK_EXTERNAL |
+						FIELD_PREP(CMN_PLL_REFCLK_INDEX, 8));
+			else
+				reg_val |= FIELD_PREP(CMN_PLL_REFCLK_INDEX, 7);
+		}
+
+		writel(reg_val, priv->membase[1] + 4);
+
+		/* Do the cmn clock reset */
+		reg_val = readl(priv->membase[1]);
+		reg_val &= ~CMN_ANA_EN_SW_RSTN;
+		writel(reg_val, priv->membase[1]);
+		msleep(1);
+
+		reg_val |= CMN_ANA_EN_SW_RSTN;
+		writel(reg_val, priv->membase[1]);
+		msleep(1);
+
+		dev_info(bus->parent, "CMN clock reset done\n");
+	}
+}
+
 static int ipq_mdio_reset(struct mii_bus *bus)
 {
 	struct ipq4019_mdio_data *priv = bus->priv;
 	u32 val;
 	int ret, i;
 
+	ipq_cmn_clk_reset(bus);
+
 	/* For the platform ipq5332, the uniphy clock should be configured for resetting
 	 * the connected device such as qca8386 switch or qca8081 PHY.
 	 */
@@ -665,7 +723,7 @@ static int ipq_mdio_reset(struct mii_bus *bus)
 		mdelay(10);
 
 		/* Configure the fixup PHY address and clocks for qca8386 chip if specified */
-		ipq_mii_preinit(bus);
+		priv->preinit(bus);
 	}
 
 	return ret;
@@ -684,9 +742,19 @@ static int ipq4019_mdio_probe(struct platform_device *pdev)
 
 	priv = bus->priv;
 
-	priv->membase = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(priv->membase))
-		return PTR_ERR(priv->membase);
+	priv->membase[0] = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(priv->membase[0]))
+		return PTR_ERR(priv->membase[0]);
+
+	/* The CMN block resource is for providing clock to ethernet, which is only
+	 * for the platform ipq95xx/ipq53xx.
+	 */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cmn_blk");
+	if (ret) {
+		priv->membase[1] = devm_ioremap_resource(bus->parent, res);
+		if (IS_ERR(priv->membase[1]))
+			return PTR_ERR(priv->membase[1]);
+	}
 
 	for (i = 0; i < MDIO_CLK_CNT; i++) {
 		priv->clk[i] = devm_clk_get_optional(&pdev->dev, ppe_clk_name[i]);
@@ -715,6 +783,7 @@ static int ipq4019_mdio_probe(struct platform_device *pdev)
 
 	/* MDIO default frequency is 6.25MHz */
 	priv->clk_div = 0xf;
+	priv->preinit = ipq_mii_preinit;
 
 	bus->name = "ipq4019_mdio";
 	bus->read = ipq4019_mdio_read_c22;
-- 
2.34.1

