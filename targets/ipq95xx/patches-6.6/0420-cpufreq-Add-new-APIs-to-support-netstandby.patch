From adc8207de2fbb90377a4fc0dbbbb42aafaeafd55 Mon Sep 17 00:00:00 2001
From: Hariharan K <quic_harihk@quicinc.com>
Date: Mon, 6 Nov 2023 11:00:00 +0530
Subject: [PATCH 430/500] cpufreq: Add new APIs to support netstandby

Add new API to support the netstandby by forcing
the CPU to userspace governor and lowest possible
frequency. Another API to exit from the netstandby
by configuring the old governor.

This is a snapshot of the commit
de3332a516d1b19a4afb6d0b3ca6e0b90b4c2d45
from win.linuxopenwrt.2.1 branch and
oss/kernel/linux-ipq-5.4 project

Change-Id: I73b6d60b61d21bdbb80f52128be0dd05c674e31d
Signed-off-by: Hariharan K <quic_harihk@quicinc.com>
---
 drivers/cpufreq/cpufreq.c | 51 +++++++++++++++++++++++++++++++++++++++
 include/linux/cpufreq.h   |  2 ++
 2 files changed, 53 insertions(+)

diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 60ed89000e82..eb043fdd6543 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -2718,6 +2718,57 @@ void cpufreq_update_limits(unsigned int cpu)
 }
 EXPORT_SYMBOL_GPL(cpufreq_update_limits);
 
+char *cpufreq_enter_standby(void)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get(0);
+	struct cpufreq_governor *new_gov;
+	char *old_gov_name;
+	int ret;
+
+	if (!policy)
+		return ERR_PTR(-ENODEV);
+
+	old_gov_name = policy->governor->name;
+
+	new_gov = cpufreq_parse_governor("userspace");
+	if (!new_gov)
+		return ERR_PTR(-EINVAL);
+
+	ret = cpufreq_set_policy(policy, new_gov, CPUFREQ_POLICY_UNKNOWN);
+	module_put(new_gov->owner);
+
+	policy->governor->store_setspeed(policy, policy->min);
+
+	if (ret)
+		return ERR_PTR(ret);
+
+	return old_gov_name;
+}
+EXPORT_SYMBOL_GPL(cpufreq_enter_standby);
+
+int cpufreq_exit_standby(char *old_gov_name)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get(0);
+	struct cpufreq_governor *old_gov;
+	int ret;
+
+	if (!policy)
+		return -ENODEV;
+
+	if (!old_gov_name)
+		return -EINVAL;
+
+	old_gov = cpufreq_parse_governor(old_gov_name);
+	if (!old_gov)
+		return -EINVAL;
+
+	ret = cpufreq_set_policy(policy, old_gov, CPUFREQ_POLICY_UNKNOWN);
+	module_put(old_gov->owner);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cpufreq_exit_standby);
+
 /*********************************************************************
  *               BOOST						     *
  *********************************************************************/
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 71d186d6933a..081e5c7057d7 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -235,6 +235,8 @@ int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 void refresh_frequency_limits(struct cpufreq_policy *policy);
 void cpufreq_update_policy(unsigned int cpu);
 void cpufreq_update_limits(unsigned int cpu);
+char *cpufreq_enter_standby(void);
+int cpufreq_exit_standby(char *old_gov_name);
 bool have_governor_per_policy(void);
 bool cpufreq_supports_freq_invariance(void);
 struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
-- 
2.34.1

